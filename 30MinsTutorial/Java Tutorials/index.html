<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="编程语言快速入门,Java,NIO,Java基础,异常,泛型,反射,多线程," />










<meta name="description" content="![title](/images/Java Tutorials/Java-Series-Title.png) 数据类型基本数据类型Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),Java没有bit类型, 但可以使用BitSet类代替.  by">
<meta name="keywords" content="编程语言快速入门,Java,NIO,Java基础,异常,泛型,反射,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Tutorials">
<meta property="og:url" content="https://whatsrtos.github.io/30MinsTutorial/Java Tutorials/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="![title](/images/Java Tutorials/Java-Series-Title.png) 数据类型基本数据类型Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),Java没有bit类型, 但可以使用BitSet类代替.  by">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-01-23T01:19:42.430Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Tutorials">
<meta name="twitter:description" content="![title](/images/Java Tutorials/Java-Series-Title.png) 数据类型基本数据类型Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),Java没有bit类型, 但可以使用BitSet类代替.  by">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://whatsrtos.github.io/30MinsTutorial/Java Tutorials/"/>





  <title>Java Tutorials | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://whatsrtos.github.io/30MinsTutorial/Java Tutorials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whatsrtos">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Tutorials</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  44,012
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>![title](/images/Java Tutorials/Java-Series-Title.png)</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),<br>Java没有bit类型, 但可以使用<code>BitSet</code>类代替.</p>
<ul>
<li>byte: 1字节, 范围-128~127</li>
<li>short: 2字节, 范围-32768~32767, 为什么最小是-32768 ?</li>
<li>int/long: <code>100L</code>表示long类型, 0x/0/0b前缀分别表示16/8/2进制<ul>
<li>如果<code>long l = 3600 * 24 * 30 * 1000</code>，1000后面不加L，右边会按int计算并产生溢出</li>
</ul>
</li>
<li>float/double: 3.14F表示float类型, 3.14和3.14D都表示double</li>
<li>char: 单引号, ‘\u2122’或’A’</li>
</ul>
<h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><p>浮点数(基本类型)之间的等值判断，基本数据类型不能用==来比较，浮点数包装数据类型不能用 equals 来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例1:</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.0F</span> - <span class="number">0.9F</span>; <span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">  <span class="comment">// 预期进入此代码块，执行其它业务逻辑 // 但事实上 a==b 的结果为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例2:</span></span><br><span class="line">Float x = Float.valueOf(a);</span><br><span class="line">Float y = Float.valueOf(b);</span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">  <span class="comment">// 预期进入此代码块，执行其它业务逻辑</span></span><br><span class="line">  <span class="comment">// 但事实上 equals 的结果为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例:</span></span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>; <span class="keyword">float</span> diff = <span class="number">1e-6F</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">  System.out.println(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitSet bits = <span class="keyword">new</span> BitSet(<span class="number">16</span>); <span class="comment">// 初始大小对性能的影响</span></span><br><span class="line">bits.set(index, <span class="keyword">true</span>);</span><br><span class="line">bits.get(index)</span><br></pre></td></tr></table></figure>

<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><h3 id="包装器API"><a href="#包装器API" class="headerlink" title="包装器API"></a>包装器API</h3><p>基本类型对应包装器为Character, Byte, Short, Integer, Long, Float, Double, 包装器与基本类型互转:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer ii = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i = ii.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Integer 可以直接与int比较 */</span></span><br><span class="line"><span class="keyword">if</span>(ii == i) &#123;</span><br><span class="line">  <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &lt;-&gt; int</span></span><br><span class="line">String s = String.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i2 = Integer.parseInt(<span class="string">"1011"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坑</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> Long(<span class="number">1</span>).equals(<span class="number">1</span>)) &#123;</span><br><span class="line">  printf(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面并没有打印出True, 因为`equals(obj)`方法自动把int的1装箱为"Integer"类型,</span></span><br><span class="line"><span class="comment">在equals里第一步check类型就返回false了:(</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Double类的一些方法:</p>
<ul>
<li><code>Double.compareTo(Double)</code> : 大于小于直接比较, =的判断是把double转成一个LongBit? Native方法, 需要看一下浮点数的内存</li>
<li><code>isNaN()</code> 返回true表示不是正常数字, 比如除以0, 负数的平方根. 代码里如何得到一个NaN?</li>
</ul>
<h3 id="装箱拆箱的实现"><a href="#装箱拆箱的实现" class="headerlink" title="装箱拆箱的实现"></a>装箱拆箱的实现</h3><p>▶ 何时发生装箱/拆箱:</p>
<ul>
<li>什么是自动装箱: int → Integer, 实际调用 <code>Integer.valueOf(int)</code></li>
<li>什么时候发生自动装箱:<ul>
<li>创建对象: <code>Integer i = 3</code></li>
<li>方法参数传递: <code>void method(Integer i)</code></li>
</ul>
</li>
<li>什么是自动拆箱: Integer → int, 实际调用 <code>integer.intValue()</code></li>
<li>什么时候发生自动拆箱:<ul>
<li>加法: <code>integer1 + integer2</code>, 先拆箱转换为int …</li>
<li>需要注意的是<code>if (integer3 == integer1 + integer2)</code>, 首先右边1和2拆箱为int, 变成<code>if (integer3 == int)</code>, 这时不是发生(int→integer)装箱, 而是继续拆箱, 最终比较的是<code>if (int == int)</code></li>
</ul>
</li>
</ul>
<p>▶ Integer/Long自动装箱 <code>valueOf(x)</code>的实现</p>
<ul>
<li>Integer/Long的<code>valueOf(i)</code>使用了享元模式, 在<code>static</code>代码块中预先创建了范围<code>-128~127</code>的对象, 缓存在Cache里;</li>
<li>当调用<code>valueOf(i)</code>的时候，先判断i的范围是否是-128~127，如果是则直接从cache里返回对象，减少类的创建;</li>
<li>下面创建Integer的效率, 前者可能更高: <code>Integer i = 3</code> , <code>Integer i = new Integer(3)</code>;</li>
<li>Float/Double的<code>valueOf(f)</code>没有使用享元模式;</li>
</ul>
<p>▶ 代码example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long l1 = Long.valueOf(<span class="number">128</span>);</span><br><span class="line">Long l2 = Long.valueOf(<span class="number">128</span>);</span><br><span class="line">System.out.println(<span class="string">"l1==l2 "</span> + (l1==l2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Long l3 = Long.valueOf(<span class="number">127</span>);</span><br><span class="line">Long l4 = Long.valueOf(<span class="number">127</span>);</span><br><span class="line">System.out.println(<span class="string">"l3==l4 "</span> + (l3==l4));</span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1==i2 "</span> + (i1==i2));</span><br><span class="line">System.out.println(<span class="string">"i1==i2+i3 "</span> + (i1==i2+i3));</span><br></pre></td></tr></table></figure>

<p>输出: false, true, false, true</p>
<blockquote>
<p>@Ref <a href="https://www.jianshu.com/p/0ce2279c5691" target="_blank" rel="noopener">Java 自动装箱与拆箱的实现原理 - 简书</a></p>
</blockquote>
<h3 id="慎用Long-equals"><a href="#慎用Long-equals" class="headerlink" title="慎用Long.equals()"></a>慎用Long.equals()</h3><p>以下代码会输出false:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Long(<span class="number">1</span>).equals(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>原因是，<code>Long.equals(Object)</code>，进入equals是会对整形参数1进行一次装箱，i被包装成<code>Integer(1)</code>，<br>和其他类的equals行为一样，<code>Long.equals(Integer(1))</code>会先判断输入参数的类型<code>if (obj instanceof Long)</code>，这里就返回false了。</p>
<p>所以用Long的正确条例是，<code>Long</code>的方法传参数都用明确的long型：<code>new Long(1L)</code>, <code>longObj.equals(1L)</code>。</p>
<h3 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger, BigDecimal"></a>BigInteger, BigDecimal</h3><p>Java还提供了两个用于大数运算的类: <code>BigInteger</code>(任意大整数)和<code>BigDecimal</code>(任意大小的带小数点的数字). 常用方法: <code>add()</code>, <code>subtract()</code>, <code>multiply()</code>, <code>divide()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger big1 = <span class="keyword">new</span> BigInteger(<span class="string">"99"</span>);</span><br><span class="line">BigInteger big2 = BigInteger.valueOf(<span class="number">99</span>);</span><br><span class="line">BigInteger big3 = big1.add(big2).multiply(big2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。 说明:equals()方法会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo()则会忽略精度。</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>Java中数组本质上也是对象, 拥有所有Object的方法, 不同于int/double等基本类型.<ul>
<li>Java对象在内存里前几个字节是”对象头”, 非数组对象的的对象头占用2字节, 数组对象的对象头占用3字节, 多的1字节用来存储对象长度</li>
<li>数组可以通过属性<code>length</code>获取长度, 遍历数组: <code>for(int i = 0; i &lt; array.length; i++)</code></li>
</ul>
</li>
<li>数组创建后会记住元素类型和大小, 所以:<ul>
<li><code>A[]</code>类型的数组可以强转换为<code>Object[]</code>, 但不能反过来执行;</li>
<li>用<code>new A[1]</code>方式创建的数组, 只能向内存储<code>A</code>类型或者<code>A的派生类</code>的对象, 试图存入其他类型对象会抛ArrayStoreException;</li>
<li>数组创建后不再能改变长度;</li>
</ul>
</li>
</ul>
<p>▶ 数组如果作为形参 or 返回值, 可以使用<code>Object</code>, 而不是用<code>Object[]</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射方式创建新数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">copyOfGenericArray</span><span class="params">(Object src, <span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> newLength&gt;<span class="number">0</span> : <span class="string">"assert length failed"</span>;</span><br><span class="line">  <span class="keyword">if</span>(!src.getClass().isArray()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Class cl = src.getClass().getComponentType();</span><br><span class="line">  Object newArray = Array.newInstance(cl, newLength);</span><br><span class="line">  <span class="keyword">int</span> length = Array.getLength(src);</span><br><span class="line">  System.arraycopy(src, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>▶ 数组与list互转:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list -&gt; array</span></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">Object[] objArray = list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array -&gt; list</span></span><br><span class="line">List&lt;Object&gt; newList = Arrays.asList(objArray);</span><br></pre></td></tr></table></figure>

<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Java核心类库有两个Arrays类:</p>
<ul>
<li><code>java.lang.reflect.Array</code>: 提供了数组的反射相关方法;</li>
<li><code>java.utils.Arrays</code>: 类似Collections类, 提供了merge/sort等方法</li>
</ul>
<p>示例代码: 用反射创建数组, 拷贝数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.reflect.Array创建数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = (<span class="keyword">int</span>[])Array.newInstance(<span class="keyword">int</span>.class,length)  <span class="comment">// &lt;Core Java&gt; P207</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝数组</span></span><br><span class="line">System.arraycopy(src[], srcPos, dest[], destPos, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用java.utils.Arrays拷贝:</span></span><br><span class="line">Object[] newArr = Arrays.copyOf(Obj[], length)</span><br><span class="line"><span class="comment">// Arrays工具类还提供了sort, binarySearch, asList()</span></span><br><span class="line"></span><br><span class="line">Entry[] entries = <span class="keyword">new</span> Entry[<span class="number">1</span>];</span><br><span class="line">Object[] objs = (Object[])entries; <span class="comment">// 向上转型数组ok</span></span><br></pre></td></tr></table></figure>

<h4 id="java-util-Arrays"><a href="#java-util-Arrays" class="headerlink" title="java.util.Arrays"></a>java.util.Arrays</h4><p><code>java.util.Arrays</code> 包含了许多处理数组的实用方法：</p>
<ul>
<li><p><code>asList</code>: 将一个数组(变长参数的语法糖实现就是数组)转变成一个List（确切的来说是 <code>ArrayList</code>），注意这个List是定长的，企图添加或者删除数据都会报错（<code>java.lang.UnsupportedOperationException</code>）.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 下面这种用法是错误的:</span></span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sort</code>: 对数组进行排序。适合byte,char,double,float,int,long,short等基本类型，还有Object类型（实现了Comparable接口），如果提供了比较器Comparator也可以适用于泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span>; <span class="comment">// 需要类实现Comparable接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>; <span class="comment">// 带比较器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>binarySearch</code>: 通过二分查找法对已排序（譬如经过Arrays.sort排序，且按照升序进行排序。如果数组没有经过排序，那么检索结果未知）的数组进行查找。适合byte,char,double,float,int,long,short等基本类型，还有Object类型和泛型</p>
</li>
<li><p><code>copyOf</code>: 数组拷贝，并返回新数组，底层采用System.arrayCopy（native方法）实现。</p>
</li>
<li><p><code>copyOfRange</code>: 数组拷贝，指定一定的范围，<code>String str2[] = Arrays.copyOfRange(arr,1,3)</code>;</p>
</li>
<li><p><code>equals</code>和<code>deepEquals</code>:</p>
<ul>
<li>equals：判断两个数组的每一个对应的元素是否equals</li>
<li>deepEquals：主要针对一个数组中的元素还是数组的情况</li>
</ul>
</li>
<li><p><code>toString</code>和<code>deepToString</code> : 参考<code>equals</code>和<code>deepEquals</code></p>
</li>
<li><p><code>hashCode</code>和<code>deepHashCode</code> :</p>
<ul>
<li>hashCode：计算一个数组的hashCode. 每个元素的<code>element.hashCode()</code>都要参与计算</li>
</ul>
</li>
<li><p><code>fill</code>: 给数组赋值。填充数组。<code>Arrays.fill(intArr, 1);</code></p>
</li>
</ul>
<h4 id="Java-lang-reflect-Array"><a href="#Java-lang-reflect-Array" class="headerlink" title="Java.lang.reflect.Array"></a>Java.lang.reflect.Array</h4><p>施工中</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li>Java在SE5中才添加了emum特性, 在定义一个enum时会自动创建<code>toString()</code>和<code>value()</code>方法(均是static方法), enum还支持类似Objec的私有属性,和构造;<ul>
<li>enum 类型不支持<code>public</code>和<code>protected</code>修饰符的构造方法, 因此构造函数一定要是<code>private</code>或 <code>friendly</code>的. 也正因为如此, 所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的.</li>
<li>枚举可以出现在switch语句中, 若要判断两个枚举类型常量的值是否相等, 使用<code>==</code>, 或<code>equals()</code>都可以. 前者更好因为可以可以判断null的情况</li>
<li>比较两个枚举类型常量的值的大小要使用<code>compareTo()</code>方法.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个基本的枚举:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> COLOR &#123;</span><br><span class="line">  RED(<span class="number">1</span>),</span><br><span class="line">  GREEN(<span class="number">2</span>) <span class="comment">// GREEN后面没有分号哟...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个带属性和构造器的枚举:</span></span><br><span class="line"><span class="keyword">public</span> emum ApiUrl &#123;</span><br><span class="line">    REGIST(<span class="string">"http://changyan.com/api/open/reg"</span>,<span class="number">1</span>),</span><br><span class="line">    LOGIN(<span class="string">"http://changyan.com/api/open/validate"</span>,<span class="number">2</span>),</span><br><span class="line">    SSO(<span class="string">"http://changyan.com/api/open/set-cookie"</span>,<span class="number">3</span>); <span class="comment">// 分号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 私有的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ApiUrl</span><span class="params">(String url, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">// 私有的构造器!!!</span></span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getUrl</span><span class="params">()</span> </span>&#123; ...&#125; <span class="comment">// Getter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index + <span class="string">"_"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ApiUrl apiUrl = ApiUrl.REGIST; <span class="comment">// 初始化枚举变量</span></span><br><span class="line">System.out.print(ApiUrl.REGIST.toString());</span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>赋值: 类实例的赋值操作<code>a=b</code>实际是把b这个”对象引用”指向了a的指向的对象, 如果b原来的对象的引用数为0, 在一定条件下会被JVM销毁.</li>
<li>对于基本数据类型, <code>==</code>判断的是值, 而不是”是否指向同一个引用”;</li>
<li>用<code>==</code>比较Object, 如果a和b是否指向的是同一块内存则为true</li>
<li>判断两个字符串的内容是否相同不能用<code>if(str1==str2)</code>, 要用<code>str1.equals(str2)</code>方法.</li>
<li>大部分jdk中的类实现了<code>Object.equals(Object)</code>这个方法(判断两值是否相等), 但是对于某些自定义的类要留意其<code>equals</code>方法, 因为<code>Object.equals</code>默认行为是比较引用的<code>this==obj</code>;</li>
</ul>
<blockquote>
<p>hashCode和equals更多参考: (五)面向对象</p>
</blockquote>
<h2 id="左右结合"><a href="#左右结合" class="headerlink" title="左右结合"></a>左右结合</h2><p>Java中赋值<code>=</code>, 单目运算<code>++</code>等, 条件运算符<code>?:</code>是右结合, 其他都是左结合,<br>比如<code>x=y=z</code>, 相当于<code>x=(y=z)</code></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><ul>
<li>左移&lt;&lt; : 丢弃最高位(符号位同样丢弃), 0补最低位. 当byte和short左移时, 自动升级为int型.<ul>
<li>数学意义: 左移n位相等于乘以2^n</li>
</ul>
</li>
<li>右移&gt;&gt; : 高位补充符号位, 正数右移补充0, 负数右移补充1, 当byte和short右移时, 自动升级为int型.<ul>
<li>数学意义:  右移n位相当于除以2^n</li>
</ul>
</li>
<li>无符号右移&gt;&gt;&gt; : 无论正负, 高位补充0<ul>
<li>无符号右移只是对32位和64位的值有意义</li>
</ul>
</li>
</ul>
<p>关于补码/反码参考脚注[^1]</p>
<h2 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h2><ul>
<li>abs: <code>return v&gt;0?v:-v;</code></li>
<li>sqrt: native</li>
<li>pow: native</li>
</ul>
<h1 id="控制流程和语句"><a href="#控制流程和语句" class="headerlink" title="控制流程和语句"></a>控制流程和语句</h1><ul>
<li>Java的<code>if</code>, <code>for</code>, <code>while</code>, <code>do-while</code>, <code>if...else if</code>和C++完全一样, 此外Java还多了foreach:  <code>for(int i : integerArray) {...}</code></li>
<li><code>switch</code>语句支持String类型和<code>enum</code>类型</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li>Java的参数传递为<code>值传递</code>. 也就是说, 当我们传递一个参数时, 方法内将获得该参数的一个拷贝.</li>
<li>基本类型(int/char等)的参数传递, 方法内获得是一个拷贝. Java方法对变量的修改不会影响到原变量.</li>
<li>对象类型作为形参传递, 函数内获得一个引用的拷贝.</li>
<li><a href="http://segmentfault.com/q/1010000000332606" target="_blank" rel="noopener">Java不能实现C/C++中的swap功能</a></li>
</ul>
<blockquote>
<p>对象类型都是通过引用拷贝(跟C++中引用不同)传参, 通过该引用能够更改其指向的对象内部值, 如果只是更改该引用值, 仅对函数内部可见, 函数外部的实参依然没有改变;</p>
</blockquote>
<h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Java对普通类型的变量 or 引用类型的变量, 都无法简单通过<code>=</code>赋值实现 Swap,</p>
<p>折中的做法有: 使用数组, 作为成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void swap1(int[] data, int a, int b) &#123;</span><br><span class="line">      int t = data[a];</span><br><span class="line">      data[a] = data[b];</span><br><span class="line">      data[b] = t;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void swap2(int a, int b) &#123;</span><br><span class="line">       this.a = b;</span><br><span class="line">       this.b = a;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><p>Java也支持变参函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//第一种形式</span></span><br><span class="line">    foreach(String arg : args) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para, String... args)</span> </span>&#123; <span class="comment">//第二种形式</span></span><br><span class="line">    <span class="comment">// 遍历方法同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="Object的一些默认方法"><a href="#Object的一些默认方法" class="headerlink" title="Object的一些默认方法"></a>Object的一些默认方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">int</span> hash = obj.hashCode(); <span class="comment">// navive方法, 返回内存地址, 但String.hashCode不是这样</span></span><br><span class="line"><span class="keyword">boolean</span> b = obj.equals(obj); <span class="comment">// return obj==this;</span></span><br><span class="line">Class cl = obj.getClass(); <span class="comment">// navive方法</span></span><br><span class="line">Object newObject = obj.clone(); <span class="comment">// error ! clone是protected native方法</span></span><br></pre></td></tr></table></figure>

<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>Object的equals方法默认是比较引用地址. equals方法的特点:</p>
<ul>
<li>自反性: a.eq(a)==true</li>
<li>对称性: if a.eq(b)==true, then b.eq(a)==true</li>
<li>传递性: a-&gt;b, b-&gt;c, a-&gt;c</li>
</ul>
<p>所以伪码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if super.equals==false false</span><br><span class="line">if this==obj true</span><br><span class="line">if obj==null false</span><br><span class="line">if class!=obj.class false</span><br><span class="line">if [!obj instanceof this] false</span><br><span class="line">其他的属性比较...</span><br></pre></td></tr></table></figure>

<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p><code>hashCode()</code>返回int类型, 返回值可以看成是对象的”消息摘要”</p>
<h3 id="比较equals和hashCode"><a href="#比较equals和hashCode" class="headerlink" title="比较equals和hashCode"></a>比较equals和hashCode</h3><ul>
<li>如果重新了equals方法, 就必须重写hashCode方法, 以便可以将对象插入到HashMap中(摘自Java核心技术卷1, 为什么?)</li>
<li>如果两个对象equals, 那么hashCode一定相同, 如果两个对象hashCode相同, 但不一定equals, 为什么?</li>
<li>equals要依次比较每个属性的值, hashCode是对”需要比较的属性”求散列, 所以如果哈希方法不够好出现碰撞, hashCode相同但是每个属性不equals</li>
<li>因为HashMap插入时用Key的hashCode作为数组的下标, 所以hashCode返回必须是正int</li>
<li>好的hashCode方法应该对”需要比较的每个属性”充分散列</li>
</ul>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>Object.clone默认是浅拷贝;</p>
<h4 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h4><p><code>Cloneable</code>和<code>Serializable</code> 一样都是标记型接口，它们内部都没有方法和属性，<code>implements Cloneable</code>表示该对象能被克隆，能使用<code>Object.clone()</code>方法。<br>如果没有<code>implements Cloneable</code>的类调用<code>Object.clone()</code>方法就会抛出 <strong>CloneNotSupportedException</strong></p>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example类的 <code>clone()</code>默认调用了 <code>Object.clone()</code>, 这是一个Native方法, 默认是 <strong>浅克隆（shallow clone）</strong></p>
<blockquote>
<p>浅拷贝（浅克隆）复制出来的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。<br>深拷贝（深克隆）复制出来的所有变量都含有与原来的对象相同的值，那些引用其他对象的变量将指向复制出来的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
</blockquote>
<p>如何实现 deep clone:<br>clone方法里要对每个引用类型的成员都调用一次 <code>clone()</code>, 例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Wheel wheel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Car car = (Car)<span class="keyword">super</span>.clone();</span><br><span class="line">        car.wheel = (Wheel)<span class="keyword">this</span>.wheel.clone();</span><br><span class="line">        <span class="keyword">return</span> car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用Serializable实现深克隆（deep clone）:</strong></p>
<p>略</p>
<h2 id="构造和销毁"><a href="#构造和销毁" class="headerlink" title="构造和销毁"></a>构造和销毁</h2><p>构造器(constructor):<br>Java的构造器实际上是一个static函数, 因为在没有实例化之前就可以调用构造, 但是一般来说, static方法里不能使用<code>this</code>关键字, 因为<code>this</code>的含义是指向类实例本身的一个引用(C++的this是指向类实例自身的指针), 但是构造器这个特殊的static方法里却可以使用<code>this</code>关键字.</p>
<h3 id="继承和构造顺序"><a href="#继承和构造顺序" class="headerlink" title="继承和构造顺序"></a>继承和构造顺序</h3><p>派生类被实例化时, 总是先调用<code>super()</code>, 即基类的默认构造方法. 在派生类的构造函数中, 也可以使用<code>super(args...)</code>调用指定的基类构造方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"parent"</span>); <span class="comment">// 通过super调用基类的"非默认构造器"</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"child"</span>); <span class="comment">// 通过this调用Override的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>如果一个类没有定义<em>任何</em>构造方法, 那么编译器会为这个类自动生成一个不带参数的<code>默认构造方法</code>,</p>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ul>
<li>Java允许在类中定义一个<code>finalize()</code>方法, 这个方法里可以做什么? JVM何时调用这个方法?</li>
<li>Efftive Java中提到<code>finalize()</code>方法可用作”守卫方法”, 比如socket在这里做最后的关闭检查:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">protect <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  close();</span><br><span class="line">  <span class="keyword">super</span>.finalize(); <span class="comment">// 不要忘记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ul>
<li>在调用Java的方法时, 会隐式的将”指向自身的引用”作为方法的第一个参数<code>function(this, param)</code>, C++的this是”指向类实例自身”的指针;</li>
<li>static方法的第一个参数则是null.</li>
</ul>
<h2 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h2><ul>
<li>没有任何权限修饰, 默认是包内可见, friendly的;</li>
<li>访问权限 public &gt; protected &gt; friendly &gt; private<ul>
<li>protected: 包可见, 子类可见;</li>
<li>friendly: 包可见, 子类不可见 (没有这个关键字, 什么都不加默认是friendly);</li>
<li>private: 只有同一类型可见;</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>Java不支持多重继承class, 但支持多重继承interface. 思考一个问题:</li>
</ul>
<blockquote>
<p>“有两个类B1和B2继承自A. 假设B1和B2都继承了A的方法并各自进行了覆盖, 编写了自己的实现. 假设C通过多重继承继承了B1和B2, 那么C应该同时继承B1和B2的重载方法, 那么它应该继承哪个的呢？是B1的还是B2的呢？”</p>
</blockquote>
<p>C++中经常会掉入这个陷阱, 虽然它也提出了替代的方法来解决这个问题. 我们在Java中就不会出现这个问题. 就算两个接口拥有同样的方法, 实现的类只会有一个方法, 这个方法由实现的类编写. 动态的加载类会让多重继承的实现变得困难.</p>
<blockquote>
<p>因为在C++没有Interface, 在C++中使用”虚拟继承”解决上面的问题:</p>
<ol>
<li>B和C去虚拟继承A: <code>class B : public virtual A</code> ,</li>
<li>D多重继承A和B: <code>class D : public B1, public B2</code> ;</li>
</ol>
</blockquote>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ul>
<li>含有抽象方法(abstract function)的类是抽象类(abstract class).</li>
<li>任何子类都必须实现抽象类的抽象方法, 或者自身也声明为抽象类;</li>
</ul>
<p>抽象类<code>public abstract class A</code>, 和接口的异同:</p>
<ul>
<li>抽象类和接口都能有自己的属性成员, 不同的是接口中的成员属性都是static和final的, 因此比较合适的做法是在interface里放置一些常量.</li>
<li>抽象类里还可以定义自己的方法实现, 并能被派生类继承, 但接口不能含有任何方法实现.</li>
</ul>
<h3 id="Java和C-实现多态的对比"><a href="#Java和C-实现多态的对比" class="headerlink" title="Java和C++实现多态的对比"></a>Java和C++实现多态的对比</h3><table>
<thead>
<tr>
<th>C++</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>virtual func</td>
<td>普通方法</td>
</tr>
<tr>
<td>virtual f()=0</td>
<td>abstract func()</td>
</tr>
<tr>
<td>abstract class</td>
<td>interface</td>
</tr>
</tbody></table>
<h2 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h2><p>多态的含义就是一个方法多种实现, 分静态和动态, 在同一个类中实现多态是通过<code>函数重载</code> -Overload, 在继承中实现多态是通过<code>运行时绑定</code>.</p>
<ul>
<li>在Java的继承中, 除了static和final方法(private也是final的)之外, 其他的方法都是<code>运行时绑定</code>的,</li>
<li>类的属性成员并不在多态的讨论范围内, “多态”仅仅指方法的多态. 比如基类和派生类都有field属性, 那么在派生类实例中, 将包含两个field, 通过<code>基类.field</code>也只能访问基类的field, 因为 <strong>属性没有多态</strong>.</li>
<li>类的构造方法不具备多态性, 因为类的构造器默认是static属性的, 对比C++的构造也不具备多态性(C++通过虚函数实现), 原因是构造期间尚未生成虚函数表.</li>
<li>在派生类中, 覆写(Override)基类的私有方法不会编译报错, 但不会照期望的执行, 结论就是: 只有非private方法才可以被派生类覆写(Override).</li>
<li>Override和Overload都可以看成是多态性的表现, 前者是基类和派生类之间的多态, 后者是一个类内部的多态表现. // 疑似C++理论</li>
</ul>
<h2 id="final-static-关键字"><a href="#final-static-关键字" class="headerlink" title="final, static 关键字"></a>final, static 关键字</h2><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>Java中的<code>final</code>关键字和C++中的<code>const</code>关键字一样, 都表示不可改变.</p>
<p>final关键字可以修饰:</p>
<ul>
<li>成员: 表示常量, 也可以在final成员定义时不给初值, 在构造方法里赋初值;</li>
<li>形参: 表示这个参数引用指向的内容不能被改变.</li>
<li>方法: 表示这个方法不能在派生类中被”覆写”(Override), 但可以被继承使用. 类中所有private方法都被隐式的声明为final的.</li>
<li>类: 表示这个类不能被继承, final类中所有的方法也被隐式声明为final的, 设计类时候, 如果这个类不需要有子类, 类的实现细节不允许改变, 并且确信这个类不会载被扩展, 那么就设计为final类. final和abstract这两个关键字是反相关的, final类就不可能是abstract的</li>
<li>C++的const类成员和Java的final类属性: 在C/Java的类中, 都支持<code>public final int ee = 1</code> 这样的声明+赋初值的方式, 也支持先声明再初值的方式(这种情况下, 都需要在构造函数里初值). 这样的设计的好处是可以做到一个类中final域在不同的对象有不同的值.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List Loans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"home loan"</span>);  <span class="comment">//valid</span></span><br><span class="line">list.add(<span class="string">"personal loan"</span>); <span class="comment">//valid</span></span><br><span class="line">loans = <span class="keyword">new</span> Vector();  <span class="comment">//not valid</span></span><br></pre></td></tr></table></figure>

<p>下面总结了一些使用final关键字的好处:</p>
<ul>
<li>final关键字提高了性能, JVM和Java应用都会缓存final变量.</li>
<li>final变量可以安全的在多线程环境下进行共享, 而不需要额外的同步开销.</li>
<li>使用final关键字, JVM会对方法/变量及类进行优化.</li>
</ul>
<blockquote>
<p>摘自《Java编程思想》第四版第143页：<br>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“</p>
</blockquote>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>使用static块初始化final的Map:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; myMap;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; aMap = ....;</span><br><span class="line">        aMap.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        aMap.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        myMap = Collections.unmodifiableMap(aMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回顾C-的const"><a href="#回顾C-的const" class="headerlink" title="回顾C++的const"></a>回顾C++的const</h3><p>可以修饰函数(修饰返回值or修饰形参or修饰类的函数成员),</p>
<blockquote>
<p>const int* ptr; // ptr指向的内容无法修改<br>int* const ptr; // 指针ptr本身的值无法被修改<br>修饰形参: void func(const int *ptr);<br>修饰返回值: const &amp;aaa func(void); //<br>修饰类的函数成员: void func(int, int) const; // 函数内不能修改类成员的值</p>
</blockquote>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>@TODO</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="一般内部类"><a href="#一般内部类" class="headerlink" title="一般内部类"></a>一般内部类</h3><ul>
<li>外部类不一定有内部类实例, 但内部类一定有对应的外部类,</li>
<li>内部类的成员不能是static, 也不能有static代码块(但内部类可以是static的, 嵌套类)</li>
<li>外部类和内部类可以 <strong>互相访问</strong> 所有成员(包括private);<ul>
<li>外部类可以访问内部类的一切成员, 无论这个内部类是public还是private的, 无论内部类的成员是public还是private的, 外部类通过<code>内部类实例.成员名</code>访问内部类的成员;</li>
<li>内部类可以访问外部类的一切成员, 包括外部类的private成员, 访问方式是<code>外部类类名.this.func()</code>, 或者也可以”直接调用”外部类的成员.</li>
</ul>
</li>
<li>在编译成功后, 会出现这样两个class文件: <code>Outer.class</code>和<code>Outer$Inner.class</code>;</li>
</ul>
<p>定义一个内部类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * public可有可无, 默认public的内部类是包内可见, friendly</span></span><br><span class="line"><span class="comment">   * 内部类可以单独继承一个抽象类或实现一个接口 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      show(); <span class="comment">// 可以这样调用外部类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="外部类如何访问内部类"><a href="#外部类如何访问内部类" class="headerlink" title="外部类如何访问内部类"></a>外部类如何访问内部类</h4><ul>
<li>内部类访问外部类属性: <code>println(OutterClass.this.propertyName);</code></li>
<li>外部类访问内部类属性: <code>println(inner.propertyName)</code> // 必须先创建内部类实例inner</li>
<li>在拥有外部类对象之前, 是不可能创建内部类对象的, 换句话说, 其他人只能通过外部类对象才能访问内部类:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outter.Inner in = <span class="keyword">new</span> Outter.Inner(); <span class="comment">// ERROR! 要先创建外部类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的创建内部类对象:</span></span><br><span class="line">Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner in = out.getInner(); <span class="comment">// 在getter里返回Inner对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种创建方式:</span></span><br><span class="line">Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner in = out.new Inner(); <span class="comment">// obj.new语法</span></span><br></pre></td></tr></table></figure>

<h4 id="其他类如何访问内部类"><a href="#其他类如何访问内部类" class="headerlink" title="其他类如何访问内部类"></a>其他类如何访问内部类</h4><ul>
<li>public的内部类 的public成员是包可见;</li>
<li>public的内部类 的private成员包不可见, 仅对外部类可见;</li>
<li>当Inner是private时, 其他类不能通过<code>Outter.Inner in = out.getInner()</code>或者<code>Outter.Inner in = out.new Inner</code>的方式创建Inner对象, 因为Inner类就是private的;<br>但是, 如果private的Inner继承自一个Base类, 这个Base类又是包可见（Public）的, 那么可以通过<code>Base base = out.getInner()</code>的方式创建内部类对象, 换句话说, 这个Base是内部类的一个对外接口, 只能通过这个对外接口访问private的内部类;</li>
</ul>
<p>以上参考: <a href="http://zhangjunhd.blog.51cto.com/113473/65624/" target="_blank" rel="noopener">探讨Java内部类的可见性;</a> @Ref</p>
<h3 id="内部类的必要性"><a href="#内部类的必要性" class="headerlink" title="内部类的必要性?"></a>内部类的必要性?</h3><ol>
<li>Java不允许多重继承, 使用内部类可以”继承”外部类的方法, 并且内部类可以独立的继承自另一个抽象类或者接口.</li>
<li>把实现细节放在内部类, 相当于是对外隐藏细节, 封装.</li>
<li>事件监听大量用到匿名内部类.</li>
<li>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现, 所以无论外围类是否已经继承了某个（接口的）实现, 对于内部类都没有影响[Think in Java]</li>
</ol>
<h3 id="局部内部类-amp-匿名类"><a href="#局部内部类-amp-匿名类" class="headerlink" title="局部内部类 &amp; 匿名类"></a>局部内部类 &amp; 匿名类</h3><ul>
<li>匿名类首先要有一个Interface or 基类;</li>
<li>匿名类没有名字, 也<strong>没有构造方法</strong>, 没有访问修饰符;</li>
<li>匿名类可以访问外部的变量, 但是<strong>创建匿名类的方法参数是final的</strong>;</li>
</ul>
<p>定义一个匿名类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匿名类要有一个接口或基类 */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pool <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 传入匿名类的参数要声明为final的 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pool() &#123;</span><br><span class="line">        <span class="keyword">int</span> number = num++;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;    <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UI中大量使用的事件callback:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h3><ul>
<li>static的内部类被称为嵌套类, 嵌套内部类不需要由外部类创建, 也就没有隐藏的外部类引用</li>
<li>不能调用非static的外部类成员, 也不能访问<code>Outter.this.property</code>;</li>
<li>外部类初始化的时候, 不会触发嵌套内部类的初始化.</li>
</ul>
<blockquote>
<p>静态内部类的初始化的时机( 初始化时会执行static代码块, 初始化static成员变量, JVM会把这些操作放在一个叫 <code>clint</code>的方法中执行 ):</p>
</blockquote>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>String是一个特殊的类, 不需要构造函数就可以创建实例<code>String s = &quot;hello world&quot;</code>;</li>
<li>String的<code>char[]</code>是final static的, 只有一份拷贝.一旦String被创建, 字符串的内容就不可改变了 // Question: 当new一个String时, 是如何判断字符串池里是否已经有相同字符串的?</li>
<li>字符串的比较不能使用<code>==</code>: <code>==</code>仍然比较的是引用, 而应该使用<code>String.equals()</code></li>
</ul>
<h2 id="String一些方法和实现"><a href="#String一些方法和实现" class="headerlink" title="String一些方法和实现"></a>String一些方法和实现</h2><ul>
<li><code>bool contains(String str)</code> : 判断参数s是否被包含在字符串中，并返回一个布尔类型的值</li>
<li><code>int indexOf(String str, int fromIndex)</code> :</li>
<li><code>String substring(int beginIndex, int endIndex)</code> : 该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。</li>
<li><code>int compareTo(String anotherString)</code> : 该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。</li>
<li><code>boolean equals(Object anotherObject)</code> : 比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<ul>
<li>比较引用是否相等</li>
<li>要比较的对象是否 <code>instanceof String</code></li>
<li>比较数组的长度 &amp; 依次比较每个char</li>
</ul>
</li>
<li><code>String concat(String str)</code> : 将参数中的字符串str连接到当前字符串的后面, 生成一个新字符串返回</li>
<li><code>String replace(char oldChar, char newChar)</code> : 用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</li>
<li><code>String replaceAll(String regex, String replacement)</code> : 该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。</li>
</ul>
<h2 id="String-不可被继承"><a href="#String-不可被继承" class="headerlink" title="String 不可被继承"></a>String 不可被继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure>

<h2 id="比较StringBuffer"><a href="#比较StringBuffer" class="headerlink" title="比较StringBuffer"></a>比较StringBuffer</h2><ul>
<li>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。两者的<code>char []</code> 不是final的, 可以修改;</li>
<li>StringBuffer线程安全, 所有方法都是synchronized的;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 比较 `String concat(String)`, `+`, 以及 StringBuffer 效率*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认StringBuilder的char[]初始长度是16</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">1000</span>; i++)  &#123;</span><br><span class="line">  sb.append(<span class="string">" "</span>);</span><br><span class="line">  <span class="comment">// 可以看到sb.append的实现, 每次拷贝要扩容char[], 所以StringBuilder(len)设置好初始值</span></span><br><span class="line">  <span class="comment">// 拼接字符串使用sb.append()的代价最小, 因为不用频繁创建Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// concat的实现&gt;</span></span><br><span class="line"><span class="comment">/* 计算拼接后的长度len, 创建一个char[len]</span></span><br><span class="line"><span class="comment"> * 拷贝str2的cha[] 到上面创建的数组</span></span><br><span class="line"><span class="comment"> * 调用String(char[]) 生成了新的String对象</span></span><br><span class="line"><span class="comment"> * 所以, 每次对String改变都会导致创建新的对象, 性能差异在这里</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">str.concat(<span class="string">" "</span>).concat(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会把下面的string + 的操作转为StringBuild, 但生成1000次StringBuilder实例, 操作符+效率差在这里</span></span><br><span class="line">String str2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">1000</span>; i++)  &#123;</span><br><span class="line">  str2 = str2 + <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-char-byte的互转"><a href="#String-char-byte的互转" class="headerlink" title="String,char,byte的互转"></a>String,char,byte的互转</h2><ul>
<li>String是由<code>char[]</code>存储数据, char是unicode, 用16bit(2字节)的数值表示一个char: <code>char c = &#39;\u554a&#39;;</code></li>
<li>String和char都可以用<code>\u0000</code>这种方式初始化.</li>
<li>byte是字节, String/char转为byte[]时, 不能确定byte[]的长度, 视转换用哪种编码(GBK/UTF-8)而定.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string = <span class="string">"\u0048\u0069"</span>; <span class="comment">// Unicode对应的字符串是"Hi"</span></span><br><span class="line"><span class="keyword">char</span>[] chars = string.toCharArray();</span><br><span class="line">System.out.printf(<span class="string">"str_len= %d, arr_len= %d"</span>, string.length(), chars.length); <span class="comment">// 输出2 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串指定位置的Unicode值:</span></span><br><span class="line"><span class="keyword">int</span> index = s.offsetByCodePoints(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(index + <span class="string">":"</span> + s.codePointAt(index)); <span class="comment">// 输出72</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"嘿H1"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b1 = str.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b2 = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="comment">// str, b1, b2, c的length分别是?</span></span><br></pre></td></tr></table></figure>

<p>unicode编码只指定了编码值, gbk和utf8定义了如何存储编码值.</p>
<ul>
<li>一个char存储的是16位的unicode, 范围0~0xFFFF(65535), 超过这个范围的汉字, 比如”𩄀”, 要用两个char也就是4字节表示.</li>
<li>如果unicode用gbk编码, 一个中文3字节, 一个英文1字节;</li>
<li>如果unicode用utf-8编码, 中文2字节, 英文一字节;</li>
<li>所以上面的输出分别是3, 5, 6, 3;</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="String-amp-StringBuffer"><a href="#String-amp-StringBuffer" class="headerlink" title="String &amp; StringBuffer"></a>String &amp; StringBuffer</h2><p>见 <a href="#字符串">字符串</a></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>见 <a href="#数据类型">数据类型</a></p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>@TODO</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><blockquote>
<p>使用 DateTimeFormatter 替换 SimpleDateFormat: <a href="https://zhuanlan.zhihu.com/p/51695220" target="_blank" rel="noopener">你真的会使用SimpleDateFormat吗？ - 知乎</a></p>
</blockquote>
<h1 id="反射和RTTI"><a href="#反射和RTTI" class="headerlink" title="反射和RTTI"></a>反射和RTTI</h1><ul>
<li>RTTI: Run-Time Type Indentification, 运行时类型识别. 并非Java体系中的概念, 来自Thinking in C++</li>
<li>Reflection(反射): 允许在程序运行期间探知并分析类对象的结构.</li>
</ul>
<h2 id="Class类和Class对象"><a href="#Class类和Class对象" class="headerlink" title="Class类和Class对象"></a>Class类和Class对象</h2><ul>
<li>每个类实例都有一个相对应的”Class对象”, 所以类实例在进行向上转型时不会丢失原有的类型信息, 这个Class对象的类型就是”Class类”, 位于<code>java.lang.Class</code>;<ul>
<li><code>T.class</code>: 获取类型T的Class对象, 基本类型<code>int</code>也可以通过<code>int.class</code>获取, 虽然int等基本类型不是类, 但是也可以<code>Class cl = int.class;</code></li>
<li><code>t.getClass()</code>: 返回的也是Class对象, <code>getClass()</code>是Object类的方法;</li>
<li>可以用<code>==</code>判断class对象是否相等: <code>if(a.getClass() == A.class)</code>;</li>
</ul>
</li>
<li>JVM通过”Class对象”创建”类对象”, 然后通过”类对象”创建类实例:<ol>
<li>加载, 加载器(Class Loader)从磁盘上找到并加载.class文件, 加载.class文件可以看成是加载字节码, 并创建Class对象;</li>
<li>链接, 分为三个步骤: 验证字节码(语法层面), 为static分配空间但不初始化(基本类型置为0,引用置为null), 解析这个类对其他类的引用;</li>
<li>初始化, 首先初始化该类的超类, 然后是static成员和static块, 最后才是构造器执行(构造器也可以看成是static方法).</li>
</ol>
</li>
</ul>
<h3 id="用反射创建类"><a href="#用反射创建类" class="headerlink" title="用反射创建类"></a>用反射创建类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1:</span></span><br><span class="line">Human human = <span class="keyword">new</span> Human();</span><br><span class="line">Class c1 = human.class;</span><br><span class="line">Human human = (Human)c1.newInstance(); <span class="comment">// Class.newInstance()返回的是Object类型</span></span><br><span class="line"><span class="comment">// 方式2:</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"org.xxx.Human"</span>);</span><br><span class="line">Human human = (Human)c1.newInstance();</span><br></pre></td></tr></table></figure>

<h3 id="使用反射API分析类"><a href="#使用反射API分析类" class="headerlink" title="使用反射API分析类"></a>使用反射API分析类</h3><p>Class, Constructor(构造方法), Field(属性), Method(方法), Modifier(作用域)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cl = Class.forName(<span class="string">"orj.xxx.ClassName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.newINstance创建类对象, 这调用类的默认构造器</span></span><br><span class="line">ClassName obj = cl.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的public static</span></span><br><span class="line">String modify = Modifier.toString(cl.getModifiers());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造器</span></span><br><span class="line">Constructor[] contructors = cl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method[] methods = cl.getDeclaredMethods();</span><br><span class="line"><span class="comment">// Class Method.getReturnType(); // 获得方法返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的限定</span></span><br><span class="line">String methodModiifier = Modifier.toString(method.getModifiers());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用任意方法</span></span><br><span class="line">Class clazz = ConcurrentHashMap.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取concurrentHashMap.containsKey()方法</span></span><br><span class="line"><span class="comment">// 第二个参数是可变参数Class&lt;?&gt;... parameterTypes</span></span><br><span class="line">Method method = clazz.getMethod(<span class="string">"containsKey"</span>, Object.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一参数是类实例, 如果调用static方法, 第一个参数穿null</span></span><br><span class="line"><span class="comment">// 第二个参数是可变参数Object... args</span></span><br><span class="line">method.invoke(<span class="keyword">new</span> ConcurrentHashMap&lt;String,String&gt;(), <span class="string">"ThisIsKey"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Class类的方法列表"><a href="#Class类的方法列表" class="headerlink" title="Class类的方法列表"></a>Class类的方法列表</h3><ul>
<li><code>Class&lt;?&gt; forName(String className)</code></li>
<li><code>Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code></li>
<li><code>T newInstance()</code>:</li>
<li><code>boolean isInstance(Object)</code> : Native方法, 注意区别<code>instanceof</code>二元操作符</li>
<li><code>boolean isArray()</code>: 是否是数组, Native方法</li>
<li><code>Class&lt;?&gt; getComponentType()</code>: 返回Class类型, 返回的Class是数组元素的类型, 示例代码: <code>String[].class.getComponentType()</code></li>
<li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 返回指定方法名和形参的方法</li>
<li>以下用来获取构造器/方法/属性的列表:<ul>
<li><code>Constructor[] getDeclaredConstructors()</code></li>
<li><code>Method[] getDeclaredMethods()</code></li>
<li><code>Field[] getDeclaredFields()</code></li>
</ul>
</li>
</ul>
<h2 id="数组和反射"><a href="#数组和反射" class="headerlink" title="数组和反射"></a>数组和反射</h2><p><code>java.lang.reflect.Array</code>类提供了数组的反射方法, 注意区分<code>java.util.Arrays</code></p>
<h3 id="用反射创建数组"><a href="#用反射创建数组" class="headerlink" title="用反射创建数组"></a>用反射创建数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array.newInstance 创建数组</span></span><br><span class="line"><span class="keyword">int</span>[] array1 = (<span class="keyword">int</span>[])Array.newInstance(<span class="keyword">int</span>.class, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class.newInstance 创建数组, 这里会抛异常, 因为数组类型T[]没有默认构造函数</span></span><br><span class="line"><span class="comment"> * 这也是Array.newInstence和Class.newInstance的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class intArrClass = array1.getClass();</span><br><span class="line"><span class="keyword">int</span>[] array2 = (<span class="keyword">int</span>[])intArrClass.newInstance(); <span class="comment">// 异常 !!</span></span><br></pre></td></tr></table></figure>

<h3 id="用反射分析数组"><a href="#用反射分析数组" class="headerlink" title="用反射分析数组"></a>用反射分析数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class.getComponentType 获取数组元素类型</span></span><br><span class="line">Class c = array.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.getLength获取长度</span></span><br><span class="line"><span class="keyword">int</span> l = Array.getLength(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非数组的类型调用getComponentType会发生什么? 返回Null</span></span><br><span class="line">Class c2 = Object.class.getComponentType();</span><br></pre></td></tr></table></figure>

<h3 id="reflect-Array类的方法列表"><a href="#reflect-Array类的方法列表" class="headerlink" title="reflect.Array类的方法列表"></a>reflect.Array类的方法列表</h3><ul>
<li><code>Object newInstance(Class&lt;?&gt; componentType, int length)</code></li>
<li>reflect.Array并没有探测数组元素类型, 和数组长度的方法:(<code>Class</code>类提供了一个: <code>array.getClass().getComponentType().toString());</code></li>
<li><code>int Array.getLength(Object arr)</code> : 返回值是int, 数组大小最大只能是int ?</li>
<li>…</li>
</ul>
<h2 id="安全的类型转换"><a href="#安全的类型转换" class="headerlink" title="安全的类型转换"></a>安全的类型转换</h2><ul>
<li>向上转型:  <code>List&lt;Object&gt; list = new ArrayList&lt;Object&gt;()</code>;</li>
<li>向下转型: <code>ChildA child = (obj instanceof ChildA ? (ChildA)obj : null);</code></li>
</ul>
<blockquote>
<p>instanceof关键字用于判断一个引用类型变量所指向的对象是否是一个类（或接口、抽象类、父类）的实例。</p>
</blockquote>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>图-Java异常类的层次结构:<br>![Java Exception](/images/Java Tutorials/java_exception.png)</p>
<h2 id="Error-amp-Exception"><a href="#Error-amp-Exception" class="headerlink" title="Error &amp; Exception"></a>Error &amp; Exception</h2><p>在 Java 语言规范中，所有异常都是 Throwable 类或者其子类的实例。Throwable 有两大直接子类。第一个是 Error，涵盖程序不应捕获的异常。当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。第二子类则是 Exception，涵盖程序可能需要捕获并且处理的异常。</p>
<ul>
<li><strong>Error</strong> 是程序无法处理的, 内存不足或JVM的错误, 比如 <code>OutOfMemoryError</code>, <code>ThreadDeath</code></li>
<li><strong>Exception</strong> 可由程序处理, 又分为”CheckedException”(受捡异常, 上图粉红色), 和”UncheckedException”(不受检异常, 上图蓝色)<ul>
<li>前者是程序需要捕获并处理的异常(比如打开文件错误, 网络超时等待), 需要throws-try-catch语句显式的捕获;</li>
<li>后者是代码错误, 比如数组越界, 这种不需要明确throws, 如果throws了也不强制代码必须catch, 其实Error也能算是不受检异常;</li>
</ul>
</li>
</ul>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Throwable</span><br><span class="line">    Error: 也算是&quot;不受检&quot;</span><br><span class="line">      OutOfMemoryError</span><br><span class="line">      ThreadDeath</span><br><span class="line">    Exception:</span><br><span class="line">      UserDefinedException: 用户自定义异常继承者Exception</span><br><span class="line">      ClassNotFoundException: 调用Class.forName时</span><br><span class="line">      InstantiationException: 调用Class.NewInstance时</span><br><span class="line">      IOException: 有一大堆派生自IOException的异常...</span><br><span class="line">      EOFException: 抛出此类异常，表示连接丢失，也就是说网络连接的另一端非正常关闭连接（可能是主机断电、网线出现故障等导致）</span><br><span class="line">      ConnectException：connection refused connect.</span><br><span class="line">      BindException：address already in use</span><br><span class="line">      RuntimeException (不受检异常):</span><br><span class="line">        NullPointerException: 最著名的不受检异常</span><br><span class="line">        IndexOutOfBoundsException: 数组越界</span><br><span class="line">        IllegalArgumentException: 调用方法时参数异常</span><br><span class="line">        IllegalAccessException: 方法对类没有访问权限</span><br><span class="line">        ArithmeticException: 数学算数异常</span><br><span class="line">        ArrayStoreException: 试图向数组存入不支持的类型</span><br><span class="line">        ClassCastException: 调用Class.cast(Object)时</span><br><span class="line">        NotSerializableException: 尝试对没有声明 Serializable接口的类进行序列化</span><br></pre></td></tr></table></figure>

<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>如果该异常被 catch 代码块捕获，finally 代码块则在 catch 代码块之后运行。<br>在某些不幸的情况下，catch 代码块也触发了异常，那么 finally 代码块同样会运行，并会抛出 catch 代码块触发的异常。<br>在某些极端不幸的情况下，finally 代码块也触发了异常，那么只好中断当前 finally 代码块的执行，并往外抛异常。</p>
<h2 id="try语句中的return"><a href="#try语句中的return" class="headerlink" title="try语句中的return"></a>try语句中的return</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x返回多少? 会打印出什么?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testTryCatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out.println(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.println(<span class="string">"finally"</span>);</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="comment">// return ++x; // 如果finally里也有return?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>try{return}</code>, 但finally没有return语句(比如上面的代码), 仍旧会执行<code>finally</code>块, try中的”返回值”被保存在局部变量中, jsr指令跳到finally块执行, 然后返回之前保存在局部变量的返回值.</li>
<li>如果上面代码finally也有return, 执行顺序是: try里的++x, finally里的++x, finally里的return</li>
<li>如果try和Catch都有return, 返回catch块的return</li>
<li>如果try和finally块都有return, try中<code>return表达式</code>仍会执行, 但不会返回try块的返回值, 而是执行finally块的return.</li>
</ul>
<blockquote>
<p>转自: <a href="http://blogread.cn/it/article/7423" target="_blank" rel="noopener">“你真的了解try{ return }finally{}中的return？</a></p>
</blockquote>
<h2 id="getMessage-vs-toString"><a href="#getMessage-vs-toString" class="headerlink" title="getMessage vs toString"></a>getMessage vs toString</h2><p>![Exception_toString](/images/Java Tutorials/exception-tostring.png)</p>
<p>如代码所示,<br><code>e.toString()</code>获取的信息包括异常类型和异常详细消息，而<code>e.getMessage()</code>只是获取了异常的详细消息字符串,<br>所以推荐在Catch中使用<code>e.toString()</code></p>
<h2 id="常见异常及解释"><a href="#常见异常及解释" class="headerlink" title="常见异常及解释"></a>常见异常及解释</h2><blockquote>
<p><a href="http://www.importnew.com/16725.html" target="_blank" rel="noopener">Java常见异常及解释 - ImportNew</a></p>
</blockquote>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul>
<li>表达式<code>assert 表达式:错误消息</code> 比如<code>assert x&gt;y : &quot;断言失败!&quot;</code></li>
<li>如何开启关闭断言? 单点为某个类开启断言? <code>java -ea Xxx</code> , <code>java -ea:MyClass Xxx</code></li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合类继承关系"><a href="#集合类继承关系" class="headerlink" title="集合类继承关系"></a>集合类继承关系</h2><p>Java核心类库提供了两大类容器, Collection(集合)和Map, 其中Collection接口又派生出List, Queue, Set三种接口:</p>
<p>![Hierarchy of Collection](/images/Java Tutorials/java-collection-hierarchy.gif)</p>
<p>容器顶层接口Collection/Map以及主要实现类 &amp; 继承关系:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.Collection [I]</span><br><span class="line">    java.util.List [I]</span><br><span class="line">        ArrayList</span><br><span class="line">        LinkedList</span><br><span class="line">        Vector</span><br><span class="line">            Stack</span><br><span class="line">    java.util.Queue [I]</span><br><span class="line">        LinkedList</span><br><span class="line">        PriorityQueue</span><br><span class="line">    java.util.Deque [I]</span><br><span class="line">        LinkedList</span><br><span class="line">    java.util.Set [I]</span><br><span class="line">        TreeSet</span><br><span class="line">        HashSet</span><br><span class="line">            LinkedHashSet</span><br><span class="line">java.util.Map [I]</span><br><span class="line">        TreeMap</span><br><span class="line">        HashMap</span><br><span class="line">            LinkedHashMap</span><br></pre></td></tr></table></figure>

<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection接口方法:</p>
<ul>
<li><code>add()</code>: ArrayList和LinkedList都是append to end</li>
<li><code>remove(Object)</code>:  遍历整个并equals判断是否相等, 然后删除</li>
<li><code>contains(Object)</code>: 都是O(N)遍历</li>
<li><code>containsAll(Collection&lt;?&gt; c):</code> 不是测试是否包含连续的集合, 比如String.indexOf那样</li>
<li><code>size()</code>:</li>
<li><code>toArray()</code>: 生成数组</li>
<li><code>iterator()</code>: 返回迭代器Iterator<e>, 它具有next()方法, 用于每次返回一个元素, 直到循环器中元素穷尽:</e></li>
<li>从Obj继承的<code>equals()</code>, <code>hashCode()</code></li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口常用方法:</p>
<ul>
<li><code>add(int index, E element)</code>:<br>Inserts the specified element at the specified position in this list (optional operation).</li>
<li><code>addAll(Collection&lt;? extends E&gt; c)</code>:<br>Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection’s iterator (optional operation).</li>
<li><code>contains(Object o)</code>:<br>Returns true if this list contains the specified element.</li>
<li><code>containsAll(Collection&lt;?&gt; c)</code>:<br>Returns true if this list contains all of the elements of the specified collection.</li>
<li><code>retainAll(Collection&lt;?&gt; c)</code>:<br>Retains only the elements in this list that are contained in the specified collection (optional operation).</li>
<li><code>sort(Comparator&lt;? super E&gt; c)</code>:<br>Sorts this list according to the order induced by the specified Comparator.</li>
<li><code>subList(int fromIndex, int toIndex)</code>:<br>Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive.</li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList内部是<code>Object[]</code>数组实现, 数组初始大小10, 每次扩展原大小的两倍, 随机访问性能好, 插入/删除代价较大, iterator是整数封装.<br>ArrayList实现了List接口:</p>
<ul>
<li><code>iterator()</code>, <code>listIterator()</code>, <code>listIterator(index)</code></li>
<li><code>add(E)</code>, <code>add(index,E)</code>, <code>addAll(Collection)</code></li>
<li><code>remove(E)</code>, <code>remove(index)</code>, <code>removeAll(Collection)</code></li>
<li><code>set(index,E)</code></li>
<li><code>sort(Comparator&lt;? super E&gt; c)</code>: 实际调用了<code>Arrays.sort()</code></li>
<li><code>subList(start,end)</code>: 返回的并不是ArrayList ,而是ArrayList的一个视图, 对于SubList的所有操作最终会反映到原列表上。</li>
<li><code>retainAll(Collection)</code> 保留ArrayList中和Collection中共有的元素(但会改变ArrayList, 没有在Collection中的元素会从ArrayList里删除)</li>
<li><code>Object[] toArray()</code>: 对该方法返回的数组, 进行操作（增删改查）都不会影响原集合的数据（ArrayList中elementData）</li>
<li>使用工具类<code>Arrays</code>的 <code>asList()</code>方法把数组转换成集合后, 不能使用该集合的<code>add</code>/<code>remove</code>/<code>clear</code>方法会, 否则抛出 <code>UnsupportedOperationException</code> 异常。<blockquote>
<p>说明:asList 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式,只是转换接口,后台的数据仍是数组。</p>
</blockquote>
</li>
</ul>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p><code>ArrayList()</code> 创建的数组大小是0, 第一次add()的时候会把数组扩容到<code>DEFAULT_CAPACITY</code>, 也就是10,<br>每次调用<code>add()</code>的时候都会检查一下添加后的数组大小是否比当前的数组大, 如果是则扩大到 1.5倍原数组的大小.  <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> // 为什么是x1.5倍?<br>所以ArrayList(默认构造函数)每次扩容的大小是: 0, 10, 15, 22, 33, 49 …<br>如果在构造ArrayList时就指定了初始大小为N, 则扩容大小是, N, 1.5N …</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>链表实现, 随机访问性能差, 插入/删除较快, iterator是引用封装.<br>LinkedList同时实现了List, Deque接口:</p>
<ul>
<li><code>add(E)</code>, <code>add(index,E)</code>, <code>addAll(Collection)</code></li>
<li><code>addFirst(E)</code>, <code>addLast(E)</code>, <code>offerFirst(E)</code>, <code>offerLast(E)</code> … 所有Deque接口的方法</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>类似ArrayList, Object[]数组实现, 包括的方法参考ArrayList, synchronized同步 @弃用</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p><code>push()</code>入栈, <code>pop()</code>弹出栈顶部元素, <code>peek()</code>获取栈顶但不弹出顶部元素,<br>Stack实际就是对Vector包装了一层, 所以也是synchronized同步</p>
<h3 id="Queue-amp-Deque"><a href="#Queue-amp-Deque" class="headerlink" title="Queue &amp; Deque"></a>Queue &amp; Deque</h3><h4 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h4><ul>
<li><code>offer</code> , <code>add</code>: 添加元素到队列尾部.<br>当队列满时, offer返回false, add抛出异常.</li>
<li><code>poll</code> , <code>remove</code>: 返回队列头部的元素, 并移除出这个元素.<br>当队列为空时, poll返回false, remove抛出异常.</li>
<li><code>peek</code> , <code>element</code>: 返回队列头部的元素但不移除它.<br>当队列空时, peek返回false, element抛出异常.</li>
</ul>
<h4 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h4><ul>
<li><code>offerFirst</code>, <code>offerLast</code> : 添加元素到队列, 失败返false</li>
<li><code>addFirst</code>, <code>addLast</code> :    添加元素到队列, 失败抛异常</li>
<li><code>pollFirst</code>, <code>poolLast</code> :  返回并移出元素, 失败返false</li>
<li><code>removeFirst</code>, <code>removeLast</code> : 返回并移出元素, 失败抛异常</li>
<li><code>peekFirst</code>, <code>peekLast</code> :     返回但不移出, 失败返false</li>
<li><code>elementFirst</code>, <code>elementLast</code> : 返回但不移出, 失败抛异常</li>
</ul>
<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><ul>
<li><code>LinkedList</code>: 双向链表, 同时实现了Deque和Queue接口, 它是唯一一个允许放入null的Queue；</li>
<li><code>ArrayDeque</code>: 以循环数组实现的双向Queue，默认初始大小是16，每次扩容double。<br>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有指向队头/队尾两个下标值.<br>从队列取出元素时，表示队头下标值++；<br>向队列插入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组0位置。<br>如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</li>
</ul>
<p><strong>带优先级的队列</strong> :</p>
<ul>
<li><p><code>PriorityQueue</code>: 用二叉堆实现的优先级队列。出队列的顺序不是按照FIFO的顺序, 而是按照插入元素来排序。插入的元素必须实现Comparable, 或者在PriorityQueue构造器传入Comparator,<br>优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。<br>优先级队列不允许 null 元素。</p>
<blockquote>
<p>二叉堆 @Ref: <a href="https://blog.csdn.net/lcore/article/details/9100073" target="_blank" rel="noopener">数据结构之优先队列–二叉堆(Java实现) - LCore的专栏 - CSDN博客</a></p>
</blockquote>
</li>
</ul>
<p><strong>线程安全的阻塞/非阻塞队列</strong>, 详见<a href="#线程安全的队列">线程安全的队列</a> :</p>
<ul>
<li>阻塞：<code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>LinkedBlockingDeque</code>；</li>
<li>非阻塞： <code>ConcurrentLinkedQueue</code> / <code>ConcurrentLinkedDeque</code>；</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是不能包含重复的元素的集合, Set接口常用方法:</p>
<ul>
<li><code>add(E e)</code></li>
<li><code>addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>contains(Object o)</code></li>
<li><code>containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>retainAll(Collection&lt;?&gt; c)</code></li>
<li><code>toArray()</code></li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet 是一个没有重复元素的集合. 元素并没有以某种特定顺序来存放,<br>HashSet内部实现是使用了HashMap的<code>transient HashMap&lt;E,Object&gt; map</code>, <code>add(E)</code>方法实际调用的是<code>hashMap.put(e,PRESENT)</code></p>
<blockquote>
<p>@Ref: <a href="http://wangkuiwu.github.io/2012/02/16/collection-16-hashset/" target="_blank" rel="noopener">Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet 可以按照插入顺序对元素进行遍历.<br>LinkedHashSet 继承了 HashSet, 内部是基于 LinkedHashMap 来实现的. 可以在LinkedHashSet构造器看出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是基于TreeMap实现的.<br>TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序. 这取决于使用的构造方法.<br>TreeSet的add、remove 和 contains方法的时间复杂度是O(logn).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Item t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        return 0; 相等</span></span><br><span class="line"><span class="comment">        return 1; this大</span></span><br><span class="line"><span class="comment">        return -1; 比较的更大</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val &gt; t.val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.val &lt; t.val) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Teacher&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;Item&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">3</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">1</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//遍历输出:</span></span><br><span class="line">        Iterator itTSet = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(itTSet.hasNext())</span><br><span class="line">            System.out.print(itTSet.next() + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Ref: <a href="http://wangkuiwu.github.io/2012/02/17/collection-17-treeset/" target="_blank" rel="noopener">Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator: 迭代器"></a>Iterator: 迭代器</h2><ul>
<li>Iterator接口的方法<ul>
<li><code>hasNext</code>: 返回true或false</li>
<li><code>next</code>: 迭代器后移一次之后, 回迭代器前面的元素</li>
<li><code>remove</code>: 删除上次next()返回的, 所以新创建迭代器之后, 必须先next一次才能remove. 一次remove之前必须有一次next, 不能连续调用remove;</li>
<li><code>add</code>: Iterator接口没有add, 但ArrayList和LinkedList的内部Itr都实现了add. 在当前迭代器之前插入. 如果创建了迭代器后立刻add, 则是插入到首位.</li>
</ul>
</li>
<li>ArrayList的Iterator:<ul>
<li>属性<code>int cursor</code>和<code>int lastRet</code>分别用来记录”下次next方法要返回的元素位置” 和”上次next方法返回的”, 初始值分别是0和-1;</li>
<li>创建迭代器:<ul>
<li>方法1: ArrayList.iterator()</li>
<li>方法2: ArrayList.listIterator(), 返回的迭代器有<code>add(Ele)</code>方法用于插入新元素;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="How-to-iterate-collection"><a href="#How-to-iterate-collection" class="headerlink" title="How to iterate collection:"></a>How to iterate collection:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; itr = collection.iterator(); i.hasNext();) &#123;</span><br><span class="line">    System.out.print(itr.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合泛型算法"><a href="#集合泛型算法" class="headerlink" title="集合泛型算法"></a>集合泛型算法</h2><p><strong>Collection &amp; Collections &amp; Arrays:</strong></p>
<ul>
<li><code>java.util.Collection&lt;E&gt;</code> 是一个泛型接口;</li>
<li><code>java.util.Collections</code> 是一个集合工具类, 提供一些操作集合的通用方法;</li>
<li><code>java.utils.Arrays</code> 是一个集合工具类, 提供操作数组的通用方法, 例如merge, sort等;</li>
<li><code>java.lang.reflect.Array</code> 类提供了数组的反射方法;</li>
</ul>
<p>图-Collection类 vs Collections类:<br>![Collection vs Collections](/images/Java Tutorials/java_collection_vs_collections.jpeg)</p>
<h3 id="排序操作（主要针对List接口相关）"><a href="#排序操作（主要针对List接口相关）" class="headerlink" title="排序操作（主要针对List接口相关）"></a>排序操作（主要针对List接口相关）</h3><ul>
<li><code>reverse(List list)</code>：反转指定List集合中元素的顺序</li>
<li><code>rotate(List list, int distance)</code>：将所有元素向右移位指定长度, 如果distance等于size那么结果不变</li>
<li><code>shuffle(List list)</code>：对List中的元素进行随机排序（洗牌）</li>
<li><code>sort(List list)</code>：对List里的元素根据自然升序排序</li>
<li><code>sort(List list, Comparator c)</code>：自定义比较器进行排序</li>
<li><code>swap(List list, int i, int j)</code>：将指定List集合中i处元素和j出元素进行交换</li>
</ul>
<blockquote>
<p>如果要使用Collections.sort, 则要求集合内存放的类型必须实现Comparable接口</p>
</blockquote>
<h3 id="查找和替换（主要针对Collection接口相关）"><a href="#查找和替换（主要针对Collection接口相关）" class="headerlink" title="查找和替换（主要针对Collection接口相关）"></a>查找和替换（主要针对Collection接口相关）</h3><ul>
<li><code>binarySearch(List list, Object key)</code>：使用二分搜索法, 以获得指定对象在List中的索引, 前提是集合已经排序</li>
<li><code>fill(List list, Object obj)</code>：使用指定对象填充</li>
<li><code>frequency(Collection Object o)</code>：返回指定集合中指定对象出现的次数</li>
<li><code>max(Collection coll)</code>：返回最大元素</li>
<li><code>max(Collection coll, Comparator comp)</code>：根据自定义比较器, 返回最大元素</li>
<li><code>min(Collection coll)</code>：返回最小元素</li>
<li><code>min(Collection coll, Comparator comp)</code>：根据自定义比较器, 返回最小元素</li>
<li><code>replaceAll(List list, Object old, Object new)</code>：替换</li>
</ul>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map不是继承Collection接口, 也没有继承Iterable接口, Map接口提供的方法:</p>
<ul>
<li><code>put(k,v)</code>, <code>get(k)</code>, <code>containsKey(k)</code>, <code>containsValue(v)</code></li>
<li><code>remove(k)</code>, <code>replace(k,v1,v2)</code></li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>HashMap 是一个散列表, 它存储的内容是键值对(key-value)映射.</li>
<li>HashMap 继承于AbstractMap, 实现了 Map、Cloneable、java.io.Serializable接口.</li>
<li>HashMap 的实现不是同步的, 这意味着它不是线程安全的. 它的 key、value都可以为null. 此外, HashMap中的映射不是有序的.</li>
</ul>
<p>HashMap 的实例有两个参数影响其性能: “初始容量” 和 “加载因子”. 容量 是哈希表中桶的数量, 初始容量 只是哈希表在创建时的容量.<br>加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度.<br>当哈希表中的条目数超出了加载因子与当前容量的乘积时, 则要对该哈希表进行 rehash 操作（即重建内部数据结构）, 从而哈希表将具有大约两倍的桶数.</p>
<p>通常, 默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷.<br>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子, 以便最大限度地减少 rehash 操作次数. 如果一个Map的初始容量大于”最大条目数”乘以加载因子, 则不会发生 rehash 操作.</p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>HashMap几个重要成员:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node[] table;     // 桶</span><br><span class="line">float loadFactor; // 负载因子</span><br><span class="line">int threshold;    // 等于table.length x loadFactor,  所能容纳的key-value对极限</span><br><span class="line">int modCount;     // 记录HashMap内部结构发生变化的次数</span><br><span class="line">int size;         // HashMap当前容纳键值对的数量</span><br></pre></td></tr></table></figure>

<p><code>put(Key, Val)</code>函数大致的实现为:</p>
<ul>
<li><p>计算<code>Key</code>的hashCode, 创建新的Node对象 <code>new Node(hash, key, value, null)</code> // node存储了hashCode, Key, Val</p>
</li>
<li><p>然后再计算<code>Key</code>在桶里的index （index等于<code>table.length-1 &amp; hash</code>）;</p>
</li>
<li><p>如果没碰撞(table[index] == null), 把node直接放到table数组里: <code>table[index]=node</code>；</p>
</li>
<li><p>如果碰撞了(table[index] != null), 则判断<code>table[i]</code>的首个元素的key是否hashCode相同 &amp;&amp; key equals 为真;</p>
<ul>
<li>是, 是则覆盖掉旧的value;</li>
<li>否, 插入到<code>table[i]</code>的链表里, 所以链表里保存是”Key的hashCode相同, 但Key不equal的元素”;</li>
</ul>
</li>
<li><p>如果碰撞导致链表过长(大于等于<code>TREEIFY_THRESHOLD</code>, 8), 就把这条链表转换成红黑树；</p>
</li>
<li><p>如果map内的元素总数超过<code>table.length x loadFactor</code>, 就要resize（扩容）</p>
<blockquote>
<p>上面提到了 <code>table[index]</code>在哈希冲突时候, 会把 table[index] 处理成链表, 当链表过长的时候, 链表的遍历性能是O(n), 很差, 所以<br>当链表长度&gt;=8时, 转成查找效率更高的红黑树;</p>
</blockquote>
</li>
</ul>
<p><code>get(k)</code>函数的实现: 这里省略了部分步骤, 只看当 <code>table[i]</code> 是链表 or 红黑树的情况:<br>遍历链表or树, 判断Key是否equal, 如果是, 返回该节点;</p>
<h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><p>table[]数组double, 把所有元素re-hash放到扩容后的table[]中.</p>
<blockquote>
<p>在HashMap中, 哈希桶数组table的长度length大小必须为2的n次方(一定是合数), 这是一种非常规的设计, 常规的设计是把桶的大小设计为素数. 相对来说素数导致冲突的概率要小于合数,<br>HashMap采用这种非常规设计, 主要是为了在取模和扩容时做优化, 同时为了减少冲突, HashMap定位哈希桶索引位置时, 也加入了高位参与运算的过程.</p>
</blockquote>
<p>@Ref: <a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap -</a></p>
<h4 id="为什么是0-75"><a href="#为什么是0-75" class="headerlink" title="为什么是0.75?"></a>为什么是0.75?</h4><p>从前面可知, 新添加进来的 Key-Value, 通过<code>key.hashCode</code>计算地址存放, 发现当前位置已经有元素, 则称为元素的碰撞, 需要重新计算或者其他方式放置该元素.<br>HashMap为了避免碰撞采取的优化策略, 简单的说, 原本可以放100个数据的空间, 当放到80个的时候, 根据经验, 接下去冲突的可能性会更加高. 因此就自动增加空间来减小冲突可能性.<br>数组大小与碰撞几率服从泊松分布, 根据经验在0.75处几率最小.</p>
<p>![HashMap_Load_Factor_Poisson_Distribution](/images/Java Tutorials/hashmap-load-factor-poisson-distribution.png)</p>
<ul>
<li>@Ref <a href="https://zhuanlan.zhihu.com/p/149687607" target="_blank" rel="noopener">面试官：为什么 HashMap 的加载因子是0.75？ - 知乎</a></li>
<li>@Ref <a href="https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">泊松分布和指数分布：10分钟教程 - 阮一峰的网络日志</a></li>
</ul>
<h4 id="Set视图"><a href="#Set视图" class="headerlink" title="Set视图"></a>Set视图</h4><p>获取HashMap的Set视图: <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>, 返回类型是<code>EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</code>, EntrySet的方法:</p>
<ul>
<li>size(), 直接返回HashMap的size</li>
<li>forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action)</li>
</ul>
<blockquote>
<p><a href="http://wangkuiwu.github.io/2012/02/10/collection-10-hashmap/" target="_blank" rel="noopener">Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul>
<li>LinkedHashMap 继承自 HashMap, 它能保证遍历元素时, 输出的顺序和输入时的顺序相同.</li>
<li>LinkedHashMap 不仅实现HashMap的开散列哈希表（数组+链表）, 还维护着一个运行于所有键值对的双向链接列表. 此列表定义了迭代的顺序, 该迭代顺序包括插入顺序和访问顺序两种, 默认是插入顺序；可以通过设置 accessOrder为 true, 把迭代顺序设置为访问顺序.</li>
<li>LinkedHashMap 重写了父类的 HashMap 的get方法: 在调用父类的 getEntry() 方法取得查找的元素之后, 再判断排序模式 accessOrder是否为true, 如果是, 那么就把最新访问的元素添加到双向链表的表头, 并从原来的位置删除（可以用来实现LRU）. 因为链表的插入和删除操作都是常量级的时间复杂度, 所以不会带来性能损失.</li>
<li>LinkedHashMap 在保留 HashMap 的查找效率的同时, 保持元素输出的顺序和输入时的顺序相同, 并提供了元素的LRU访问.</li>
</ul>
<blockquote>
<p>参考: <a href="https://blog.csdn.net/u014313009/article/details/24520851" target="_blank" rel="noopener">LinkedHashMap内部实现</a> @Ref</p>
</blockquote>
<h4 id="LinkedHashMap-amp-HashMap代码比较"><a href="#LinkedHashMap-amp-HashMap代码比较" class="headerlink" title="LinkedHashMap &amp; HashMap代码比较"></a>LinkedHashMap &amp; HashMap代码比较</h4><ul>
<li>LinkedHashMap 继承自 HashMap;</li>
<li>HashMap的桶数组 <code>HashMap.Node&lt;K,V&gt; table[]</code>, HashMap.Node&lt;K,V&gt;继承自Map.Entry&lt;K,V&gt;;</li>
<li>LinkedHashMap的<code>Entry</code>继承自<code>HashMap.Node&lt;K,V&gt;</code>, （与<code>HashMap.Node</code>相比）增加了before/after两个引用做双向链表</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 是一个有序的key-value集合, TreeMap 根据Key的自然顺序进行排序, 或者根据TreeMap构造器提供的 Comparator进行排序.<br>内部是基于红黑树（Red-Black tree）的 NavigableMap实现.<br>TreeMap的基本操作 <code>containsKey</code>、<code>get</code>、<code>put</code> 和 <code>remove</code> 的时间复杂度是 <strong>log(n)</strong>.</p>
<ul>
<li>TreeMap 是一个有序的key-value集合, 它是通过红黑树实现的.</li>
<li>TreeMap 继承于AbstractMap, 所以它是一个Map, 即一个key-value集合.</li>
<li>TreeMap 实现了NavigableMap接口, <code>descendingKeySet()</code>方法返回一个与原顺序相反的值的一个Set集合, 其实是指向同一块内存区域, 在该视图上的任何修改都会影响到原始的数据.</li>
<li>TreeMap 实现了Cloneable接口, 意味着它能被克隆.</li>
<li>TreeMap 实现了java.io.Serializable接口, 意味着它支持序列化.</li>
</ul>
<blockquote>
<p><a href="http://wangkuiwu.github.io/2012/02/12/collection-12-treemap/" target="_blank" rel="noopener">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>TreeMap的特点: 1 插入的元素可以按Key的自然顺序遍历, 2 像HashMap一样近似O(1)的查找复杂度;<br>二叉堆满足1, 但是不满足2,<br>红黑树的中序遍历可以满足1, 同时红黑树的查找复杂度(参考BST)是<code>O(logN)</code></p>
<ul>
<li><code>put</code>: 如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。</li>
<li><code>get</code>: log(n)</li>
<li>顺序遍历: 中序遍历</li>
</ul>
<h4 id="为什么采用红黑树"><a href="#为什么采用红黑树" class="headerlink" title="为什么采用红黑树"></a>为什么采用红黑树</h4><p>排序二叉树虽然可以快速检索, 但在最坏的情况下: 如果插入的节点集本身就是有序的（比如由小到大排列, 或是由大到小排列）,<br>那么最后得到的排序二叉树将变成链表: 所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）.<br>在这种情况下, 排序二叉树就变成了普通链表, 其检索效率就会很差.<br>为了改变排序二叉树存在的不足, Rudolf Bayer 与 1972 年发明了另一种改进后的排序二叉树: 红黑树, 他将这种排序二叉树称为”对称二叉 B 树”, 而红黑树这个名字则由 Leo J. Guibas 和 Robert Sedgewick 于 1978 年首次提出.</p>
<blockquote>
<p>参考: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">教你透彻了解红黑树</a> @Ref</p>
</blockquote>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ul>
<li>HashTable的方法都是采用了<code>synchronized</code>同步.</li>
<li>高并发场景下不推荐使用HashTable, 应该使用<code>java.util.concurrent.ConcurrentHashMap</code>替代.</li>
</ul>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>这种Map通常用在数据缓存中.它将键存储在WeakReference中, 就是说, 如果没有强引用指向键对象的话, 这些键就可以被垃圾回收线程回收</p>
<p>→ <a href="https://whatsrtos.github.io/Java/Advanced-Java-Tutorial/#WeakHashMap">Advanced Java Tutorial#WeakHashMap</a></p>
<h3 id="关于Map-Entry"><a href="#关于Map-Entry" class="headerlink" title="关于Map.Entry"></a>关于Map.Entry</h3><p>HashMap有一个该类型的属性: <code>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code>,<br>该属性在调用<code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>方法内被初始化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EntrySet</code>类是HashMap的一个static内部类, 定义了<code>forEach</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="How-to-iterate-map"><a href="#How-to-iterate-map" class="headerlink" title="How to iterate map"></a>How to iterate map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// entry.getKey()</span></span><br><span class="line">    <span class="comment">// entry.getValue()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">//map.get(key);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">Iterator it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)it.next();</span><br><span class="line">    <span class="comment">// entry.getKey(), entry.getValue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型类和泛型方法"><a href="#泛型类和泛型方法" class="headerlink" title="泛型类和泛型方法"></a>泛型类和泛型方法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T first;</span><br><span class="line">  <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setFirst</span><span class="params">(T)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setSecond</span><span class="params">(T)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ArrayAlg &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span> <span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t[t.length / <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用泛型方法</span></span><br><span class="line">ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 或者不用指定泛型方法的T, 编译期自行推断也是可以的:</span></span><br><span class="line">ArrayAlg.getMiddle(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="泛型的类型限定"><a href="#泛型的类型限定" class="headerlink" title="泛型的类型限定"></a>泛型的类型限定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">  T min = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt; min) min = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果T需要多个类型限定: <code>&lt;T extends Comparable &amp; Serializable&gt;</code></p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><ul>
<li>JVM没有”泛型类”这种类型, java代码被编译后生成的字节代码, 这个过程中所有的泛型类型要被替换, 原则:<ul>
<li>有类型限定的, 替换为第一个限定类型, <code>T extends Comparable &amp; Serializable</code>被替换为<code>Comparable</code></li>
<li>无类型限定, 替换为Object, <code>T</code>被替换为<code>Object</code></li>
</ul>
</li>
</ul>
<h3 id="对类型查询的影响"><a href="#对类型查询的影响" class="headerlink" title="对类型查询的影响"></a>对类型查询的影响</h3><h4 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. instanceof</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; s = <span class="keyword">new</span> Pair&lt;String&gt;(); <span class="comment">// 擦除后为 Pair&lt;Object&gt; s</span></span><br><span class="line"><span class="keyword">if</span>(s <span class="keyword">instanceof</span> Pair&lt;T&gt;) &#123; <span class="comment">// Pair&lt;T&gt;擦除后为Pair&lt;Object&gt;</span></span><br><span class="line"> <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s <span class="keyword">instanceof</span> Pair&lt;Double&gt;) &#123;</span><br><span class="line"> <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-getClass"><a href="#2-getClass" class="headerlink" title="2. getClass()"></a>2. getClass()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; s = <span class="keyword">new</span> Pair&lt;String&gt;();</span><br><span class="line">Pair&lt;Double&gt; d = <span class="keyword">new</span> Pair&lt;Double&gt;();</span><br><span class="line"><span class="keyword">if</span>(s.getClass() == d.getCLass()) &#123; <span class="comment">// getClass()总是返回Pair&lt;Object&gt;</span></span><br><span class="line">  <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不能创建泛型类数组"><a href="#不能创建泛型类数组" class="headerlink" title="不能创建泛型类数组"></a>不能创建泛型类数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 试图创建泛型类型的数组会在编译期报错:</span></span><br><span class="line">Pair&lt;String&gt;[] arr = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">1</span>]; <span class="comment">// error !</span></span><br><span class="line">Pair&lt;String&gt;[] arr = Array.newInstance(Pair&lt;String&gt;.getClass(),<span class="number">1</span>); <span class="comment">// error !</span></span><br></pre></td></tr></table></figure>

<p>原因是数组一旦创建会记住元素的类型, 当试图向数组中存储不同的类型时会报错, <code>Pair&lt;String&gt;[]</code>这样声明的泛型数组, 擦除后变为<code>Pair&lt;Object&gt;[]</code>.</p>
<h3 id="不能实例化泛型"><a href="#不能实例化泛型" class="headerlink" title="不能实例化泛型"></a>不能实例化泛型</h3><p>不能使用像<code>new T()</code>, <code>new T[N]</code>, <code>T.class</code>这样的表达式.</p>
<h2 id="通配符-lt-gt"><a href="#通配符-lt-gt" class="headerlink" title="通配符&lt;?&gt;"></a>通配符&lt;?&gt;</h2><h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Foo</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.get(<span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>List&lt;?&gt;</code>表示持有某种特定类型的List，但是不知道具体是哪种类型。那么我们可以向其中添加对象吗？当然不可以，因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。</p>
<h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p><code>? extends ClassType</code>表示ClassType的任何子类</p>
<p>先看一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile Error: can’t add any type of object:</span></span><br><span class="line"><span class="comment">// flist.add(new Apple());</span></span><br><span class="line"><span class="comment">// flist.add(new Fruit());</span></span><br><span class="line"><span class="comment">// flist.add(new Object());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能向list里添加null</span></span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get是可以编译通过的</span></span><br><span class="line">list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>做了泛型的向上转型 (<code>List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;()</code>)，那么我们也就失去了向这个<code>List</code>添加任何对象的能力，即使是<code>Object</code>也不行。<br>那么上界通配符有什么用呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;? extends Fruit&gt; list)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">        Fruit fruit = list.get(i);</span><br><span class="line">        System.out.println(fruit.getName());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list.add(<span class="keyword">new</span> Apple()); <span class="comment">// Compile Error!</span></span><br><span class="line">      list.add(<span class="keyword">new</span> Object()); <span class="comment">// Compile Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>List&lt;? extends Fruit&gt; list</code> 表示一个List, 里面存储的类型是<code>Fruit</code>的派生类, 从list里get出来的类型至少是<code>Fruit</code>, 或者<code>Fruit</code>的派生类, 可以调用<code>Fruit</code>类的方法.<br>传递给<code>GenericTest.func()</code>的参数可以是<code>List&lt;Apple&gt;</code>, 也可以是<code>List&lt;Lemon&gt;</code>,<br>上界通配符<code>&lt;? extends Base&gt;</code>, 可以调用基类<code>Base</code>里定义的方法, 也可以get, 但是不可以set</p>
<h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><code>? super Integer</code>表示Integer的超类, 只能用于<code>setter</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Integer&gt;)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="限定符和泛型的一些问题…"><a href="#限定符和泛型的一些问题…" class="headerlink" title="限定符和泛型的一些问题…"></a>限定符和泛型的一些问题…</h3><p><strong>泛型中无界通配符<code>&lt;?&gt;</code> 和<code>&lt;T&gt;</code>的区别?</strong></p>
<ul>
<li><code>&lt;T&gt;</code> 用在类或方法的定义里: <code>public class ArrayList&lt;T&gt;</code></li>
<li><code>&lt;?&gt;</code>通配符用在”调用”的地方, 通配符是拿来使用定义好的泛型的, 可以使用<code>?</code>的一般满足:<ol>
<li>方法定义里只使用Object的方法，跟<code>?</code>类型无关;</li>
<li>使用中不依赖于泛型, 最典型的是<code>Class&lt;?&gt; ...</code></li>
</ol>
</li>
<li>无限定通配符表示匹配任意类。<code>ArrayList&lt;?&gt;</code> 和<code>ArrayList&lt;Object&gt;</code> 看上去有点类似，但实际却不一样。<ol>
<li><code>ArrayList&lt;?&gt;</code>是任意 <code>ArrayList&lt;T&gt;</code> 的超类;</li>
<li><code>List&lt;Apple&gt;</code>是<code>List&lt;? extends Fruit&gt;</code>的子类(假设Apple继承自Fruit)</li>
<li><code>ArrayList&lt;Object&gt;</code> 并不是<code>ArrayList&lt;T&gt;</code> 的超类;</li>
</ol>
</li>
</ul>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>什么是代理模式:<br>用户代码不直接调用某些功能类的方法, 而是通过代调类作为”中间层”去调用”被代理类”. 所有调用都会被代理类拦截, 我们可以利用代理类的这个特性, 在代理类里增加额外的执行代码.<br>使用代理可以给我们带来如下好处: 用户代码(调用者)和功能类(被调用者)解耦, 第二个好处是通过代理层可以加入一些通用的代码.<br>Java代理模式的实现主要有: 静态代理, JDK动态代理, Cglib动态代理.</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>如何使用JDK的动态代理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">YourInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 实际类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourClass</span> <span class="keyword">implements</span> <span class="title">YourInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 被代理的实例</span></span><br><span class="line">  <span class="keyword">private</span> YourInterface target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">YourHandler</span><span class="params">(YourInterface target)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">// 通过Proxy调用方法都会调用到这里,</span></span><br><span class="line">      <span class="comment">// 在这里可以放一些类似AOP @Around的处理..</span></span><br><span class="line">      Object result = method.invoke(target, args);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YourInterface obj = <span class="keyword">new</span> YourClass();</span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> YourHandler(obj);</span><br><span class="line"><span class="comment">// 4 创建代理</span></span><br><span class="line">YourInterface proxy = (YourInterface)Proxy.newProxyInstance(</span><br><span class="line">  obj.getClass().getClassLoader(),</span><br><span class="line">  obj.getClass().getInterfaces(),</span><br><span class="line">  handler);</span><br><span class="line"></span><br><span class="line">proxy.doSomething();</span><br></pre></td></tr></table></figure>

<p>通过proxy调用<code>YourClass</code>实现自接口<code>YourInterface</code>的所有方法, 都会调用到<code>YourHandler</code>的invoke方法,<br>在invoke方法里可以很方便的做一些前置和后置处理（访问控制、远程通信、日志、缓存等）, 在invoke里再通过反射调用实际类<code>YourClass</code>的方法.</p>
<p>动态代理的优点是, 当<code>YourInterface</code>的实现类有很多的时候, 比如有YourClassA, YourClassB…<br>通过代理调用这些实现类的方法(必须是实现YourInterface里的方法), 都会由代理调用到<code>InvocationHandler.invoke()</code>,<br>如果用静态代理, 那么代理类(实现了YourInterface接口)必须为YourInterface的每一个方法都增加单独的代码.</p>
<p>参考: <a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">Java 动态代理作用是什么？ - 知乎</a> @Ref</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在调用<code>Proxy.newProxyInstance()</code>之后,<br>又调用了<code>ProxyGenerator.generateProxyClass()</code>方法生成最终代理类的字节码, 并通过ClassLoader把字节码转化成对象.<br>在最终代理类里实现了我们的Interface定义的所有方法, 在这些方法内部, 都通过反射调用了<code>InvocationHandler</code>接口实现类的<code>invoke()</code>方法</p>
<blockquote>
<p>包<code>sun.misc.ProxyGenerator</code>提供了一个功能, 可以生成YourInterface的实现类的字节码:<br><code>byte[] data = ProxyGenerator.generateProxyClass(name,new Class[]{YourInterface.class});</code></p>
</blockquote>
<h2 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h2><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。<br>与JDK动态代理不同的是, 使用CGLIB即使被代理类没有实现任何接口也可以实现动态代理功能。但是不能对final修饰的类进行代理。<br>JDK动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求委托类必须实现一个接口，只能对该类接口中定义的方法实现代理，这在实际编程中有一定的局限性。</p>
<p>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>ASM是一个Java字节码操控框架。通过分析被代理类的class文件, 在内存中创建被代理类的增强子类, 它能被用来动态生成类或者增强既有类的功能。<br>ASM可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。<br>脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>下面通过一个例子看看使用CGLib如何实现动态代理:</p>
<p>定义业务逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"This is add service"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现MethodInterceptor接口，定义方法的拦截器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] arg, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Before:"</span> + method);</span><br><span class="line">      Object object = proxy.invokeSuper(obj, arg);</span><br><span class="line">      System.out.println(<span class="string">"After:"</span> + method);</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>Enhancer</code>类生成<code>UserServiceImpl</code>的代理类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">enhancer.setCallback(new YourMethodInterceptor());</span><br><span class="line">UserServiceImpl userService = (UserServiceImpl)enhancer.create();</span><br></pre></td></tr></table></figure>

<p><code>Enhancer</code>是CGLib的字节码增强类, 可以生成类的字节码(<code>UserServiceImpl</code>的子类),<br>其作用类似<code>sun.misc.ProxyGenerator</code>, 区别是<code>Enhancer</code>不需要被代理类实现接口, 而<code>ProxyGenerator</code>要求被代理类必须实现接口</p>
<p>以上参考:<br>@Ref <a href="http://blog.jobbole.com/105423/" target="_blank" rel="noopener">说说 cglib 动态代理</a></p>
<h2 id="Spring-AOP与代理"><a href="#Spring-AOP与代理" class="headerlink" title="Spring AOP与代理"></a>Spring AOP与代理</h2><blockquote>
<p>Spring AOP中的一些注解 &amp; 概念:</p>
<blockquote>
<p>@Aspect: PointCut + Advice<br>@PointCut: 切点, 在哪里切入<br>@Advice: 切入的行为(在切点之前还是之后, 或者环绕切点), 以及做什么</p>
</blockquote>
</blockquote>
<p>Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。<br>Spring AOP中的动态代理主要有两种方式，<strong>JDK动态代理</strong> 和 <strong>CGLIB动态代理</strong>。</p>
<ul>
<li>如果目标类(被切的类)有统一的实现接口，Spring AOP使用JDK动态代理，</li>
<li>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</li>
</ul>
<p>因此如果某个类被标记为final，并且没有实现接口，那么它是无法被动态代理的，也就无法当做切点（CutPoint）</p>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p>
<ul>
<li>基于字节操作的 I/O 流接口：<code>InputStream</code> 和 <code>OutputStream</code></li>
<li>基于字符操作的 I/O 流接口： <code>Writer</code> 和 <code>Reader</code></li>
<li>基于磁盘操作的 I/O 文件接口： <code>File</code></li>
</ul>
<p>参考: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">深入分析 Java I/O 的工作机制</a> @Ref</p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>按照流操作对象的类型是字节还是字符, 分为字节流和字符流</p>
<ol>
<li>字节流的父类是 <code>InputStream</code>/<code>OutputStream</code>, 读写单个字节/字节数组,</li>
<li>字符流的父类是 <code>Reader</code>/<code>Writer</code> 用于读写被编码(GBK/UTF8)的字符串, 读写Char/Char数组;</li>
</ol>
<p>按照功能分为节点流(node stream)和过滤流(filter stream, 或者叫装饰流)</p>
<ol>
<li>节点流用来处理从基本位置获取字节(文件, 内存, 管道), <code>FileInputStream</code>, <code>ByteArrayInputStream</code>, <code>PipedInputStream</code>, 这些类提供基本的读写方法;</li>
<li>过滤流用于包装节点流, 提供了新的方法, 可以更方便的读写高级类型的数据(类序列化, 压缩文件, Java基本类型) <code>ObjectInputStream</code>, <code>ZipInputStream</code>,  <code>DataInputStream</code>.</li>
</ol>
<h3 id="节点流-amp-过滤流"><a href="#节点流-amp-过滤流" class="headerlink" title="节点流 &amp; 过滤流"></a>节点流 &amp; 过滤流</h3><p>图-外层的DataInputStream（过滤流）提供了额外的方法：<br>![Node Stream &amp; Filter Stream](/images/Java Tutorials/Node_Stream_Filter_Stream.gif)</p>
<h3 id="字节流-amp-字符流"><a href="#字节流-amp-字符流" class="headerlink" title="字节流 &amp; 字符流"></a>字节流 &amp; 字符流</h3><p><strong>字符流</strong>相关类以及继承关系:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符流</span><br><span class="line">  |-InputStream</span><br><span class="line">  |   |-FileInputStream [node流] 文件流</span><br><span class="line">  |   |-ByteArrayInputStream [node流] 内存字符流</span><br><span class="line">  |   |-PipedInputStream [node流] 管道流</span><br><span class="line">  |   |-ObjectInputStream</span><br><span class="line">  |   |-SequenceInputStream</span><br><span class="line">  |   |-FilterInputStream</span><br><span class="line">  |       |-DataInputStream</span><br><span class="line">  |       |-BufferedInputStream</span><br><span class="line">  |</span><br><span class="line">  |-OutputStream</span><br></pre></td></tr></table></figure>

<p><strong>字节流</strong>相关类以及继承关系:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字节流</span><br><span class="line">  |-Reader</span><br><span class="line">  |   |-InputStreamReader</span><br><span class="line">  |       |-FileReader</span><br><span class="line">  |   |-PipedReader</span><br><span class="line">  |   |-BufferedReader</span><br><span class="line">  |   |-CharArrayReader</span><br><span class="line">  |   |-StringReader</span><br><span class="line">  |</span><br><span class="line">  |-Writer</span><br><span class="line">      |-PrintWriter 没有对应的Reader, 可以使用java.io.Scaner</span><br></pre></td></tr></table></figure>

<h4 id="字节流-常用类和方法"><a href="#字节流-常用类和方法" class="headerlink" title="字节流 常用类和方法"></a>字节流 常用类和方法</h4><ul>
<li><code>InputStream</code>/<code>OutputStream</code> 提供基本的字符/字符数组读写<ul>
<li><code>InputStream.available()</code> : 返回可读的字节数</li>
<li><code>read()</code>, <code>read(byte[])</code>: 阻塞的, read返回读取的一个字节(int)</li>
<li><code>write(int b)</code>, <code>write(byte[])</code>: 阻塞的</li>
<li><code>close()</code></li>
</ul>
</li>
<li><code>FileInputStream</code>/<code>FileOutputStream</code></li>
<li><code>ByteArrayInputStream</code>/<code>ByteArrayOutputStream</code>: 包含一个内部缓冲区(字节数组), 该缓冲区包含从流中读取的字节</li>
<li><code>PipedInputStream</code>/<code>PipedOutputStream</code> 同上</li>
<li><code>BufferedInputStream</code>/<code>BufferedOutputStream</code>: 为另一个流提供缓冲</li>
<li><code>ObjectInputStream</code>/<code>ObjectOutputStream</code><ul>
<li><code>Object readObject()</code></li>
<li><code>void writeObject(Object)</code></li>
</ul>
</li>
</ul>
<h4 id="字符流-常用类和方法"><a href="#字符流-常用类和方法" class="headerlink" title="字符流 常用类和方法"></a>字符流 常用类和方法</h4><ul>
<li><strong>Reader</strong>: 提供对char,char[],String类型数据的基本操作<ul>
<li><code>read()</code>: 返回字符的Unicode编码(0-65535,双字节范围), 到达流末尾返回-1;</li>
<li><code>read(char[])</code>: 读取字符到数组并返回已读取的字符个数;</li>
<li><code>skip(long n)</code>: 跳过n个char</li>
<li><code>mark(int limit)</code>: 为流的当前位置增加标记, 下次调用reset可以返回这个标记, 如果调用mark()后读取字符数超过limit, 下次调用reset会失败.</li>
<li><code>reset()</code>:</li>
<li><code>close()</code>:</li>
</ul>
</li>
<li><strong>InputStreamReader</strong><ul>
<li><code>getEncoding()</code>: 获取输入流的编码</li>
<li><code>ready()</code>: 如果有数据可读, 返回true</li>
</ul>
</li>
<li><strong>FileReader</strong>: 继承自 InputStreamReader<ul>
<li>构造器: <code>FileReader(String)</code>, <code>FileReader(java.io.File)</code></li>
</ul>
</li>
<li><strong>BufferedReader</strong>:<ul>
<li><code>readLine()</code> : 读取一行并返回字符串(不包括换行符), 如果流已经读尽则返回null</li>
</ul>
</li>
<li><strong>Scanner</strong>: 不是继承自Reader</li>
<li><strong>Writer</strong> : 提供对char,char[],String类型数据的基本操作<ul>
<li><code>write(char c)</code>, <code>write(char[])</code>, <code>write(String)</code></li>
<li><code>append(char)</code>, <code>append(CharSequence)</code></li>
<li><code>flush()</code>: 让缓冲区的内容立刻写入</li>
<li><code>close()</code> :</li>
</ul>
</li>
<li><strong>PrintWriter</strong>:</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>本章主要介绍文件操作类: <code>java.io.File</code> 和 <code>java.io.RandomAccessFile</code></p>
<h3 id="java-io-File"><a href="#java-io-File" class="headerlink" title="java.io.File"></a>java.io.File</h3><p>File 是“文件”和“目录路径名”的抽象表示形式。File 直接继承于Object，实现了Serializable接口和Comparable接口。<br>实现Serializable接口，意味着File对象支持序列化操作。<br>实现Comparable接口，意味着File对象之间可以比较大小；File能直接被存储在有序集合(如TreeSet、TreeMap中)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFileDirAPIS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"dir"</span>);</span><br><span class="line">    dir.mkdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建文件</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(dir, <span class="string">"file1.txt"</span>);</span><br><span class="line">    file1.createNewFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出目录下的文件</span></span><br><span class="line">    File[] fs = dir.listFiles();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-io-RandomAccessFile"><a href="#java-io-RandomAccessFile" class="headerlink" title="java.io.RandomAccessFile"></a>java.io.RandomAccessFile</h3><p><code>java.io.RandomAccessFile</code>是随机访问文件(包括读/写)的类。它支持对文件随机访问的读取和写入，即我们可以从指定的位置读取/写入文件数据。<br>需要注意的是，RandomAccessFile 虽然属于java.io包，但它不是InputStream或者OutputStream的子类；<br>它也不同于FileInputStream和FileOutputStream。 FileInputStream 只能对文件进行读操作，而FileOutputStream 只能对文件进行写操作；<br>RandomAccessFile 同时支持文件的读和写，并且它支持随机访问。</p>
<blockquote>
<p><code>RandomAccessFile</code> 大部分功能被JDK1.4中NIO的内存映射文件替代了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(args[<span class="number">0</span>], <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">long</span> position = raf.length();</span><br><span class="line"><span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  position -= <span class="number">1</span>;</span><br><span class="line">  raf.seek(position);</span><br><span class="line">  <span class="keyword">byte</span> b = raf.readByte();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>旧风格的I/O操作的异常捕获:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read(); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read(); <span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close(); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中可能会抛出异常. try语句块中有3个地方能抛出异常, finally语句块中有一个地方会能出异常.<br>不论try语句块中是否有异常抛出, finally语句块始终会被执行.这意味着, 不论try语句块中发生什么, InputStream 都会被关闭, 或者说都会试图被关闭.如果关闭失败, InputStream’s close()方法也可能会抛出异常.<br>Q: 假设try语句块抛出一个异常, 然后finally语句块被执行.同样假设finally语句块也抛出了一个异常.那么哪个异常会根据调用栈往外传播？<br>A: 即使try语句块中抛出的异常与异常传播更相关, 最终还是finally语句块中抛出的异常会根据调用栈向外传播.</p>
</blockquote>
<p>在JDK7中, <strong>try-with-resources</strong> 风格的IO异常捕获:<br>try-with-resources语句会确保在try语句结束时关闭所有资源. 实现了<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code>的对象都可以做为在<code>try()</code>代码块内打开的资源, 并且可以在退出<code>try()</code>语句块时被自动关闭.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try()代码块内打开多个资源:</span></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">  java.util.zip.ZipFile zf = <span class="keyword">new</span> java.util.zip.ZipFile(zipFileName);</span><br><span class="line">  InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/a.txt"</span>);</span><br><span class="line">  java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)</span><br><span class="line">  <span class="comment">// 这里没有分号</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Enumerate each entry</span></span><br><span class="line">  <span class="keyword">for</span> (java.util.Enumeration entries = zf.entries(); entries.hasMoreElements();) &#123;</span><br><span class="line">      <span class="comment">// Get the entry name and write it to the output file</span></span><br><span class="line">      String newLine = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">      String zipEntryName =</span><br><span class="line">           ((java.util.zip.ZipEntry) entries.nextElement()).getName() + newLine;</span><br><span class="line">      writer.write(zipEntryName, <span class="number">0</span>, zipEntryName.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception1 | Exception2 e) &#123; <span class="comment">// 新风格的catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当try-with-resources结构中抛出一个异常, 同时资源调用close方法时也抛出一个异常, try-with-resources结构中抛出的异常会向外传播, 而资源被关闭时抛出的异常被抑制了. 这与旧风格代码的例子相反.</p>
</blockquote>
<h2 id="API-Example"><a href="#API-Example" class="headerlink" title="API Example"></a>API Example</h2><h3 id="字节流-API-Example"><a href="#字节流-API-Example" class="headerlink" title="字节流 API Example"></a>字节流 API Example</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基本字节流 InputStream/OutputStream 接口测试: */</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;;</span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"~/testFile"</span>);</span><br><span class="line">os.write(bytes); <span class="comment">// 1</span></span><br><span class="line">os.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size; <span class="keyword">byte</span>[] readbuf;</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"~/testFile"</span>);</span><br><span class="line"><span class="keyword">if</span>((size= is.available()) &gt; <span class="number">0</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">  is.read(readbuf= <span class="keyword">new</span> <span class="keyword">byte</span>[size]); <span class="comment">// 3</span></span><br><span class="line">  System.out.println(<span class="keyword">new</span> String(readbuf));</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Filter Streams Layered onto Node Stream */</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"A.txt"</span>); <span class="comment">// Node Stream</span></span><br><span class="line">BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream); <span class="comment">// Filter Stream</span></span><br><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(bufferedOutputStream);</span><br><span class="line">out.writeInt(<span class="number">3</span>);</span><br><span class="line">out.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">  <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(<span class="string">"A.txt"</span>)));</span><br><span class="line"><span class="comment">// DataInputStream Methods:</span></span><br><span class="line">in.readInt();</span><br><span class="line">in.readBoolean();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h3 id="字符流-API-Example"><a href="#字符流-API-Example" class="headerlink" title="字符流 API Example"></a>字符流 API Example</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PrintWriter and Scanner */</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"A.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">out.println(<span class="string">"Hello"</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"A.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">  String line = scanner.nextLine();</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FileReader -&gt; BufferedReader */</span></span><br><span class="line">FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">"~/testout.txt"</span>);</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>((i=br.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">  System.out.print((<span class="keyword">char</span>)i);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">fr.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BufferedReader 逐行读取 */</span></span><br><span class="line">String line;</span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(ReadFile);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件字节流 -&gt; 文件字符流 */</span></span><br><span class="line">FileOutputStream os = <span class="keyword">new</span> FileOutputStream(WriteFile);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(os,<span class="string">"UTF-8"</span>);</span><br><span class="line">writer.append(<span class="string">"Hello\r\n"</span>);</span><br><span class="line">writer.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符流处理Socket */</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">Writer writer = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">write.write(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// close writer and socket</span></span><br></pre></td></tr></table></figure>

<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>@Q 序列化机制是怎样的?</p>
<blockquote>
<p>①如何定义一个可序列化的类?<br>②serialVersionUID属性的作用和生成方式?<br>③哪些字段不会被序列化?<br>④ArrayList类的序列化是如何实现的?<br>⑤如何自定义序列化?<br>⑥反序列化的调用过程?</p>
</blockquote>
<ol>
<li>实现 <code>Serializable</code>接口的类可以被序列化, 通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>对象进行序列化及反序列化</li>
<li>通过<code>ObjectOutputStream</code>反序列化的时候, 会比较 serialVersionUID是否相同, 如果不同会抛异常<code>InvalidClassException</code>, 建议: 在创建可序列化的类的时候指定一个serialVersionUID, 并且在可兼容升级的时候不要修改serialVersionUID, 除非是不兼容的版本. 如果没有定义serialVersionUID, 在反序列化的时候, ObjectOutputStream会自动生成一个(根据类名,接口名,属性名, 以及描述符等生成一个64位的哈希数字)</li>
<li>static 和 transient关键字修饰的属性不会被序列化</li>
<li>ArrayList的实现里, 把<code>elementData[]</code>声明为 transient, 同时也实现了<code>writeObject(ObjectOutputStream)</code>和<code>readObject(ObjectInputStream)</code>, 在这两个方法里实现自定义序列化, 目的是为了避免<code>elementData[]</code>中大量空元素被序列化, 减少序列化字节占用.</li>
<li>如何自定义序列化实现: 类实现自己的<code>writeObject(ObjectOutputStream)</code>和<code>readObject(ObjectInputStream)</code></li>
<li>反序列化调用过程(伪码): <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject(Object)</span><br><span class="line">    ObjectStreamClass.initNonProxy // 检查是否实现 Serializable接口, serialVersionUID是相等</span><br><span class="line">        调用类的readObject()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>@Ref <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650120882&idx=1&sn=8e355b5ee3cce0a2d0108edbdf88e606" target="_blank" rel="noopener">你真的以为你了解Java的序列化了吗？</a><br>@Ref <a href="https://juejin.im/entry/5c2192de6fb9a049e2320859" target="_blank" rel="noopener">为什么阿里巴巴要求程序员谨慎修改serialVersionUID 字段的值 - 后端 - 掘金</a></p>
</blockquote>
<p>序列化/反序列化API示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4964541705925508858L</span>;</span><br><span class="line"><span class="keyword">transient</span> Logger logger = LoggerFactory.getLogger(Config.class);</span><br><span class="line"><span class="keyword">long</span> uid;</span><br><span class="line">String nick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filePath));</span><br><span class="line">os.writeObject(user);</span><br><span class="line">os.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(filePath));</span><br><span class="line">User newUser = (User)is.readObject();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程6种状态"><a href="#线程6种状态" class="headerlink" title="线程6种状态"></a>线程6种状态</h2><ol>
<li>New, 创建Thread实例之后;</li>
<li>Runnable, 执行<code>thread.start()</code>之后;</li>
<li>Blocked, 线程试图获取ReentrantLock失败, 或进入synchronize代码块, 或调用Block IO;</li>
<li>Waiting, 调用<code>object.wait()</code>或<code>thread.join()</code>之后;<ul>
<li>调用<code>object.wait()</code>, <code>condition.await()</code>方法都会产生WAITING状态;</li>
<li>调用<code>thread.join()</code>后, 调用者会Waiting一直到thread线程退出;</li>
</ul>
</li>
<li>Time-Waitting, 调用<code>Object.wait(long)</code>或<code>thread.join(long)</code>, <code>lock.tryLock(long)</code>时;</li>
<li>Terminated: 线程的<code>run()</code>方法正常退出或者<code>run()</code>方法抛出未捕获异常时;</li>
</ol>
<blockquote>
<p>上面的状态来自Oracle JDK 8 <code>java.lang.Thread.State</code>, 并不等同于unix下的原生线程状态,<br><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Thread.State.html" target="_blank" rel="noopener">Thread.State (Java Platform SE 8 )</a></p>
</blockquote>
<p>图-线程6种状态的转换:<br>![Thread States](/images/Java Tutorials/java_thread_states_all.png)</p>
<h2 id="线程控制API"><a href="#线程控制API" class="headerlink" title="线程控制API"></a>线程控制API</h2><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种Runnable接口</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// new之后线程处于"New"状态</span></span><br><span class="line">t.start(); <span class="comment">// start之后线程处于"Runnable"状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">Class MyThread extends Thread &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Mythread().start();</span><br></pre></td></tr></table></figure>

<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><ul>
<li>调用<code>t.interrupt()</code>方法时, 线程<code>t</code>会收到中断信号, Java并没有要求线程一定响应中断. 线程应该根据情况决定是否响应中断, 循环调用<code>t.isInterrupted()</code>可以检测线程的中断标志位.</li>
<li>如果线程内调用了<code>sleep()</code>或者<code>wait()</code>方法让线程进入等待状态, 当调用<code>t.interrupt()</code>, 线程会抛出<code>InterruptException</code>, 如果你的线程里调用了可能抛出该异常的阻塞方法, 那么就不必每次调用<code>isInterrupt()</code>检测中断状态了, 在catch里捕获该异常即可.</li>
<li>如果线程已经被中断的情况下再调用<code>sleep()</code>, <code>sleep()</code>方法会清除中断状态并且抛出上述异常, 并不会进入sleep状态, 所以线程循环中有<code>sleep()</code> 的也不必用<code>isInterrupt</code>检查中断状态</li>
<li>可抛出中断异常的: 线程内调用<code>wait()</code>, 或者调用<code>thread.join()</code>和<code>thread.sleep()</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() <span class="comment">/* &amp;&amp; */</span>) &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>); <span class="comment">// 如果有sleep, 上面的isInterrupted不必要</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.start(); <span class="comment">// sub-thread now is "runnnable"</span></span><br><span class="line"></span><br><span class="line">t.interrupt(); <span class="comment">// main thread interrupt sub-thread</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>执行<code>thread.join()</code>的线程会进入waiting状态, 直到<code>thread</code>线程终止或自然退出, 继续执行后面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyThread thread = new MyThread();</span><br><span class="line">thread.start();</span><br><span class="line">thread.join(); // 在这里waiting</span><br><span class="line"></span><br><span class="line">// 上面的thread退出后, 才会进行到这里</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>执行<code>thread.sleep(m)</code>的线程会进入timed_waitting状态m毫秒(注意, 并没有sleep这种状态),<br><code>Thread.sleep()</code>与线程调度器交互，它将当前线程设置为等待一段时间的状态。一旦等待时间结束，线程状态就会被改为可运行（runnable），并开始等待CPU来执行后续的任务。因此，当前线程的实际休眠时间取决于线程调度器，而线程调度器则是由操作系统来进行管理的。</p>
<p>比较<code>thread.sleep(long millis)</code>和<code>object.wait()</code>:</p>
<ul>
<li>对于<code>sleep()</code>方法，我们首先要知道该方法是属于Thread类中的。而<code>wait()</code>方法，则是属于Object类中的。</li>
<li><code>sleep()</code>方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是cpu对线程的监控状态依然保持者，当指定的时间到了又会自动恢复runnable。</li>
<li>在调用<code>sleep()</code>方法后, 线程进入timed_waiting状态, 并且线程不会释放对象锁。</li>
<li>当调用线程里调用<code>obj.wait()</code>方法的时候，线程进入等待此对象的等待队列，放弃对象锁并进入waiting状态，只有针对此对象调用<code>notify()</code>方法后, 线程才会从对象锁的等待队列中被取出。</li>
</ul>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别?"></a>sleep和wait的区别?</h3><ul>
<li><code>Thread.sleep()</code>方法是一个静态方法，作用在当前线程上；</li>
<li><code>obj.wait()</code>方法是一个实例方法，并且只能在其他线程调用本实例的<code>obj.notify()</code>方法时被唤醒。</li>
<li>调用<code>wait()</code>方法时，线程在等待的时候会释放掉它所获得的monitor，但是调用<code>Thread.sleep()</code>方法时，线程在等待的时候仍然会持有monitor或者锁。</li>
<li>Java中的<code>wait()</code>方法应在同步代码块中调用(已经获得了对象锁的情况下, 调用对象.wait()会放弃锁)</li>
<li>使用<code>sleep()</code>方法时，被暂停的线程(是处于timed_wait状态?) 在被唤醒之后会立即进入就绪态（Runnable state)</li>
<li>从<code>wait()</code>方法被唤醒的时候(通常是其他线程调用了<code>obj.notify()</code>)，被暂停的线程要首先获得锁，然后再进入Runnable。</li>
<li>如果你需要暂定线程一段特定的时间就使用<code>sleep()</code>方法，如果你想要实现线程间通信就使用<code>wait()</code>方法。</li>
</ul>
<h3 id="如何终止线程"><a href="#如何终止线程" class="headerlink" title="如何终止线程?"></a>如何终止线程?</h3><p>几个问题:</p>
<ol>
<li>被调用了<code>sleep()</code>的线程(timed_waiting状态)可以被<code>interrupt()</code>抛出异常吗?</li>
<li>调用了<code>thread.join()</code>的线程(waiting状态)可以被<code>interrupt()</code>抛出异常吗?</li>
<li>调用了<code>object.wait()</code>的线程(waiting状态)可以被<code>interrupt()</code>抛出异常吗?</li>
<li>调用阻塞IO方法被阻塞住的线程可以被<code>interrupt()</code>抛出异常吗?</li>
<li>试图抢占锁(synchronized或ReentrantLock)但失败的线程(blocked状态)可以被<code>interrupt()</code>抛出异常吗?</li>
</ol>
<p>答案: 可以, 可以, 可以, 否, 否</p>
<p><strong>所以</strong> 只有处于waiting或timed_waiting状态的线程才可以抛出<code>InterruptException</code>异常被中断, block状态的线程不可以;</p>
<p>如何终止waiting或timed_waiting状态的线程呢? 有两种方式:</p>
<ul>
<li>用Volatile的标志位控制线程的循环逻辑;</li>
<li>使用interrupt()方法中断当前线程, 线程的循环里应该try-catch <code>InterruptException</code></li>
</ul>
<p>但是对于进入blocked状态的线程, 是无法被<code>interrupt()</code>中断的, 所以可能的做法是: 关闭阻塞的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOBlocked</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        in = is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptException e1) &#123;</span><br><span class="line">            <span class="comment">// 事实永远无法到达这, 因为read不抛InterruptException</span></span><br><span class="line">            <span class="comment">// InterruptException是受检异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HowToInterruptIOBlockedThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开网络流</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InputStream stream = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>).getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行会导致IO Blocked的线程</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> IOBlocked(stream));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程sleep</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试停止所有正在执行的任务, shutdownNow会尝试调用所有线程的interrupt</span></span><br><span class="line">        service.shutdownNow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过关闭线程操作的资源来释放阻塞的线程</span></span><br><span class="line">        stream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h3><p>如何唤醒sleep或者wait的线程?</p>
<ul>
<li>对于因为IO阻塞而进入的blocked状态的线程, 没有办法唤醒;</li>
<li>对于因为调用<code>waiting()</code>, <code>t.sleep()</code>, <code>t.join()</code>而进入waiting或timed_waiting状态的线程, 调用<code>t.interrupt()</code>可以让上面的”阻塞操作”抛出<code>InterruptedException</code>来打到”唤醒”的效果;</li>
</ul>
<h3 id="被弃用的方法"><a href="#被弃用的方法" class="headerlink" title="被弃用的方法"></a>被弃用的方法</h3><p>Thread类不再推荐被使用的方法: <del>yield,stop,suspend,resume</del></p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>yield方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。<br>如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。<br>执行了yield方法的线程什么时候会继续运行由线程调度器来决定。<br>yield方法不保证当前的线程会暂停或者停止，但是可以保证当前线程在调用yield方法时会放弃CPU。</p>
<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。<br>因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。<br>但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><blockquote>
<p>该方法天生是不安全的。使用thread.stop()停止一个线程，导致释放（解锁）所有该线程已经锁定的监视器（因沿堆栈向上传播的未检查ERROR <code>ThreadDeath</code>而解锁）。 // → 非受检异常<br>如果之前受这些监视器保护的任何对象处于不一致状态，则不一致状态的对象（受损对象）将对其他线程可见，这可能导致任意的行为。<br>ThreadDeath是java.lang.Error，不是java.lang.Exception。不受检异常意味着我们不会有意识在代码里写Try-Catch去处理异常, 比如在finally里释放锁</p>
</blockquote>
<p>上面的意思是:<br>线程当前可能持有一个监视器(或锁)，执行 <code>thread.stop()</code> 将会产生一个 ThreadDeath 错误(不受检ERROR)，线程向上抛出错误，导致监视器被解锁。<br>可能导致的问题: 以银行转账的例子,如果在”减扣A余额, 增加B余额”的过程中, 线程被stop, 将产生业务数据的不一致.</p>
<p><strong>建议</strong> 用interrupt替代stop, 在线程中循环检测<code>thread.isInterrupted()</code> 或者 捕获<code>InterruptException</code> 然后由业务代码进行收尾处理.</p>
<p>ThreadDeath 和 InterruptException 的区别是:<br>  前者不受检, 意味着业务代码没有机会捕获并处理, 会向上层堆栈抛出错误, 线程状态变为 “Terminated”;<br>  后者是受检异常, 可以被捕获并由业务代码处理;</p>
<h4 id="suspend-amp-resume"><a href="#suspend-amp-resume" class="headerlink" title="suspend &amp; resume"></a>suspend &amp; resume</h4><ul>
<li>当某个线程的suspend()方法被调用时，该线程会被挂起。如果该线程占有了锁，则它不会释放锁。线程在挂起的状态下还持有锁，这导致其他线程将不能访问该资源直到目标线程恢复工作。</li>
<li>线程的<code>resume()方法</code>会恢复 因<code>suspend()</code>方法挂起的线程，使之重新能够获得CPU执行。</li>
</ul>
<p>建议使用 <code>object.wait</code> 和 <code>object.notify</code>方法代替 <code>suspend</code> &amp; <code>resume</code></p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul>
<li>java中线程优先级范围 <code>MIN_PRIORITY</code><del><code>MAX_PRIORITY</code> (其值1</del>10), <code>NORMAL_PRIORITY</code>(其值=5);</li>
<li>线程默认情况下继承父线程的优先级;</li>
</ul>
<h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>当JVM还存在一个非守护线程, JVM就不会退出, 当存活的线程仅剩下守护线程时, JVM才会退出.<br>守护线程最典型的应用就是GC</p>
<h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h2 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h2><blockquote>
<p>参考:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#package.description" target="_blank" rel="noopener">java.util.concurrent (Java Platform SE 8 ) Description</a></li>
<li><a href="https://segmentfault.com/a/1190000015558984" target="_blank" rel="noopener">透彻理解Java并发编程系列 - 透彻理解Java并发编程 - SegmentFault 思否</a></li>
</ul>
</blockquote>
<p>J.U.C: Java并发包，即java.util.concurrent包，是JDK的核心工具包，是JDK1.5之后，由 Doug Lea实现并引入。<br>整个java.util.concurrent包，按照功能可以大致划分如下:</p>
<ul>
<li>locks 锁框架: ReentrantLock, ReentrantReadWriteLock, LockSupport, StampedLock, Condition</li>
<li>atomic 原子类框架: AtomicInteger, AtomicLong, AtomicXXXFieldUpdater, LongAdder</li>
<li>sync 同步器框架: CountDownLatch, CyclicBarrier, Semaphore, Exchanger, Phaser</li>
<li>collections 集合框架:</li>
<li>executors 执行器框架: ThreadPoolExecutor, Fork/Join</li>
</ul>
<h2 id="ReentrantLock和条件对象"><a href="#ReentrantLock和条件对象" class="headerlink" title="ReentrantLock和条件对象"></a>ReentrantLock和条件对象</h2><h3 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁: ReentrantLock"></a>可重入锁: ReentrantLock</h3><p>ReentrantLock是”可重入锁”: 一个线程已经持有锁的情况下, 重复对该锁进行<code>lock()</code>操作,  能立刻获得锁且不会被阻塞.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123; ... &#125; <span class="keyword">catch</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">  reentrantLock.unlock(); <span class="comment">// 在finally里释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的构造函数<code>ReentrantLock(boolean fair)</code>可以返回公平锁(true)和非公平锁(false).</p>
<blockquote>
<p>公平锁（Fair）：加锁前检查是否有排队等待的线程，如果队列非空先进入队列，获取锁的顺序同调用lock的顺序一致;<br>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待;</p>
</blockquote>
<p>因为队列的存在和线程调度的机制, 公平锁的吞吐量更低, 所以 ReentrantLock()默认构造是 <strong>非公平锁</strong></p>
<h4 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h4><p>图-ReentrantLock-AQS UML:<br>![ReentrantLock AQS](/images/Java Tutorials/java_reentrantLock_uml.png)</p>
<p><code>ReentrantLock</code>中有一个 Sync 类型的成员,  根据调用不同的构造方法, sync 被初始化为<code>NonFairSync</code>(非公平锁, 默认) 或者<code>FairSync</code>(公平锁)，这两种Sync都继承自<code>AbstractQueuedSynchronizer</code>, 简称AQS，是java.util.concurrent的核心，<code>CountDownLatch</code>、<code>FutureTask</code>、<code>Semaphore</code>、<code>ReentrantLock</code>等都有一个内部类是这个抽象类的子类。<code>ReentrantLock中</code>所有涉及对AQS的访问都要经过Sync。</p>
<p><code>AbstractQueuedSynchronizer</code>有几个重要的成员变量:<br>  1 int类型的计数器<code>state</code> ;<br>  2 等待线程的队列(由head和tail指针表示的双向队列);<br>  3 从<code>AbstractOwnableSynchronizer</code>继承来的<code>exclusiveOwnerThread</code> (Thread类型);</p>
<p>计数器是volatile修饰的, 作用是记录锁被重入的次数, 初值是0, 重入一次+1, 释放一次-1, 计数器为0表示没有线程持有该锁, 是free的;<br>尝试CAS修改计数器失败的线程, 会被放入队列尾部;<br><code>exclusiveOwnerThread</code>用来记录当前该锁被哪个线程占用(但不是volatile的, 此处有疑问)</p>
<p>AbstractQueuedSynchronizer抽象类提供的主要的属性和方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">// 双向队列头</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 双向队列尾</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  <span class="comment">// 重入计数器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock.lock() 调用了 sync.acquire(1) 方法,</span></span><br><span class="line">  <span class="comment">// 最终调用到 AQS.acquire(1):</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 由NonfairSync 和 FairSync分别实现</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 队列操作</span></span><br><span class="line">            selfInterrupt(); <span class="comment">// interrupt当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock.unlock() 调用了 sync.release(1) 方法,</span></span><br><span class="line">  <span class="comment">// 最终调用到 AQS.acquire(1):</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 由Sync实现</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><p>ReentrantLock.lock()调用栈如下(以 NonFairSync为例):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock.lock()</span><br><span class="line">    NonFairSync.acquire(1)</span><br><span class="line">        AbstractQueuedSynchronizer.acquire(1)</span><br><span class="line">            NonFairSync.tryAcquire(1)</span><br></pre></td></tr></table></figure>

<p>过程大致如下:</p>
<ul>
<li>对计数器<code>CAS(0,1)</code>操作, （<code>CAS(0,1)</code>意即为如果计数器等于期望值0则设置为1）</li>
<li>CAS成功, 成功获取到该锁, 并把exclusiveOwnerThread置为当前线程引用地址, <code>lock()</code>成功返回;</li>
<li>CAS不成功, 表明已经有线程持有该锁, 且exclusiveOwnerThread不等于当前线程, 创建当前线程的<code>AQS.Node</code>对象, 并插入AQS的队尾, 并调用<code>LockSupport.park()</code>使当前Thread进入Blocked</li>
</ul>
<blockquote>
<p>state表示重入成功获取到锁的计数, 每次成功重入+1,<br>如果尝试获取锁的线程不等于已持有锁的线程, 计数不用+1, 把这个线程加入AQS队列, 并且使这个线程进入Blocked状态</p>
</blockquote>
<h5 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h5><p>ReentrantLock.unlock()调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock.unlock()</span><br><span class="line">    NonFairSync.release(1)</span><br><span class="line">        AbstractQueuedSynchronizer.release(1)</span><br><span class="line">            Sync.tryRelease(1)</span><br></pre></td></tr></table></figure>

<ul>
<li>只允许已经持有锁的线程调用<code>unlock()</code>, 否则<code>unlock()</code>会抛出 IllegalMonitorStateException异常</li>
<li>已经持有锁的线程, 每次调用<code>unlock()</code>计数器都会-1, 直到计数器等于0, 这时候表示锁全部被解开了, 再从AQS的队列取出第一个节点, 把这个节点对应的线程设置为Runnable</li>
</ul>
<h4 id="测锁与超时"><a href="#测锁与超时" class="headerlink" title="测锁与超时"></a>测锁与超时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECOND)) &#123; <span class="comment">// 超时时间内尝试获取锁失败立刻返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123; <span class="comment">// 尝试获取锁失败立刻返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul>
<li>如果一个数据结构只有很少线程修改其值, 但是有很多线程读取, 这种数据结构非常适合用读写锁<code>ReentrantReadWriteLock</code></li>
<li>writeLock一旦被持有, 排除其他的写锁和读锁;</li>
<li>readLock一旦被持有, 排斥写锁, 但不排斥其他的读锁;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">Lock wl = rwl.writeLock(); <span class="comment">// 抽取写锁</span></span><br><span class="line">Lock rl = rwl.readLock(); <span class="comment">// 抽取读锁</span></span><br><span class="line"></span><br><span class="line">wl.lock();</span><br><span class="line"><span class="comment">// 写操作, 这里排斥其他的读写锁</span></span><br><span class="line">wl.unlock();</span><br><span class="line"></span><br><span class="line">rl.lock();</span><br><span class="line"><span class="comment">// 读操作, 其他读锁仍可以进入, 写锁则不能</span></span><br><span class="line">rl.unlock();</span><br></pre></td></tr></table></figure>

<h3 id="条件对象-Condition"><a href="#条件对象-Condition" class="headerlink" title="条件对象: Condition"></a>条件对象: Condition</h3><p>实例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(!resource_is_available) &#123;</span><br><span class="line">    condition.await(); <span class="comment">//1 失去锁 &amp; waiting状态 &amp; 进入condition的等待集</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// here acquired lock, doSomething...</span></span><br><span class="line">  condition.signalAll(); <span class="comment">//2 把condition等待集里的所有线程移除</span></span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  reentrantLock.unlock(); <span class="comment">//3 永远在finally里释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件对象的实现"><a href="#条件对象的实现" class="headerlink" title="条件对象的实现"></a>条件对象的实现</h4><p><code>ReentrantLock.newCondition()</code>返回一个<code>ConditionObject</code>对象, 是AbstractQueuedSynchronizer的一个内部类;<br>一个锁可以创建多个<code>ConditionObject</code>对象;<br><code>ConditionObject</code>的实现也是一个队列, firstWaiter和lastWaiter记录了队列的头和尾</p>
<ol>
<li>一个线程调用<code>condition.await()</code>之后进入waiting状态并进入该condition的队列中, 处于waiting的线程无法改变自身状态, 只能等待其他线程调用<code>condition.signalAll()</code>;</li>
<li>一个线程调用<code>condition.signalAll()</code>之后, 所有在此condition等待队列中的其他线程被移出, 这些线程重新设置runnable状态, 这些线程从<code>await()</code>阻塞调用里返回;</li>
</ol>
<h2 id="Synchronized和对象锁"><a href="#Synchronized和对象锁" class="headerlink" title="Synchronized和对象锁"></a>Synchronized和对象锁</h2><p>本节主要介绍对同步关键字(Synchronized), 以及对象锁.</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>(1) synchronized方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!resource_is_available) <span class="comment">// 持有对象锁</span></span><br><span class="line">      wait(); <span class="comment">// Object.wait(),</span></span><br><span class="line">      <span class="comment">// 重新获得锁, doSomething...</span></span><br><span class="line">      notifyAll(); <span class="comment">// 通知其他等待该对象锁的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) synchronized块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">long</span> userID, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">      <span class="comment">// doSomething ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个类对象都有从Object继承的”对象锁”, synchronized方法利用这个对象锁保护方法内的代码片段.</li>
<li>对于同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前对象的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>
<blockquote>
<p><strong>同步方法</strong> 和 <strong>同步代码块</strong> 都是用了进入/退出Monitor对象来实现的, 但两者的实现细节不一样</p>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><ul>
<li>在synchronized代码块前后增加的<code>monitorenter</code>和<code>monitorexist</code>两个JVM字节码指令,指令的参数是this引用。</li>
<li>synchronized关键字起到的作用是设置一个独占访问临界区，在进入这个临界区前要先获取对应的监视器锁，任何Java对象都可以成为监视器锁，声明在静态方法上时监视器锁是当前类的Class对象，实例方法上是当前实例。</li>
<li>synchronized提供了原子性、可见性和防止重排序的保证。</li>
<li>JMM中定义监视器锁的释放操作happen-before与后续的同一个监视器锁获取操作。再结合程序顺序规则就可以形成内存传递可见性保证。</li>
</ul>
<p>下面以一段Java代码为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestSynchronize().inc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap查看<code>inc()</code>方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void inc();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PRIVATE</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=3, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: dup</span><br><span class="line">        2: astore_1</span><br><span class="line">        3: monitorenter                     // monitor 1</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: dup</span><br><span class="line">        6: getfield      #2                  // Field count:I</span><br><span class="line">        9: iconst_1</span><br><span class="line">       10: iadd</span><br><span class="line">       11: putfield      #2                  // Field count:I</span><br><span class="line">       14: aload_1</span><br><span class="line">       15: monitorexit                      // monitor 2</span><br><span class="line">       16: goto          24</span><br><span class="line">       19: astore_2</span><br><span class="line">       20: aload_1</span><br><span class="line">       21: monitorexit                     // monitor 3</span><br><span class="line">       22: aload_2</span><br><span class="line">       23: athrow</span><br><span class="line">       24: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            4    16    19   any</span><br><span class="line">           19    22    19   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 14: 0</span><br><span class="line">       line 15: 4</span><br></pre></td></tr></table></figure>

<p>在synchronized代码块前后增加的<code>monitorenter</code>和<code>monitorexist</code>两个JVM字节码指令,指令的参数是this引用。</p>
<p>hotspot中对于 <code>monitor_enter</code>和 <code>monitor_exit</code>的C++代码是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info) &#123;</span><br><span class="line">  if (!GenerateSynchronizationCode) return;</span><br><span class="line">  // for slow path, use debug info for state after successful locking</span><br><span class="line">  CodeStub* slow_path = new MonitorEnterStub(object, lock, info);</span><br><span class="line">  __ load_stack_address_monitor(monitor_no, lock);</span><br><span class="line">  // for handling NullPointerException, use debug info representing just the lock stack before this monitorenter</span><br><span class="line">  __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception);</span><br><span class="line">&#125;</span><br><span class="line">void LIRGenerator::monitor_exit(LIR_Opr object, LIR_Opr lock, LIR_Opr new_hdr, LIR_Opr scratch, int monitor_no) &#123;</span><br><span class="line">  if (!GenerateSynchronizationCode) return;</span><br><span class="line">  // setup registers</span><br><span class="line">  LIR_Opr hdr = lock;</span><br><span class="line">  lock = new_hdr;</span><br><span class="line">  CodeStub* slow_path = new MonitorExitStub(lock, UseFastLocking, monitor_no);</span><br><span class="line">  __ load_stack_address_monitor(monitor_no, lock);</span><br><span class="line">  __ unlock_object(hdr, object, lock, scratch, slow_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h5><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，<br>所以在Java SE1.6里<code>对象锁</code>一共有四种状态，<strong>无锁状态</strong>，<strong>偏向锁状态</strong>，<strong>轻量级锁状态</strong> 和 <strong>重量级锁状态</strong>，<br>它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p>
<blockquote>
<p>轻量级锁适合追求响应时间，同步块执行速度非常快的情况<br>重量级锁追求吞吐量，适合同步块执行速度较长的代码。</p>
</blockquote>
<p>随着锁的升级， Java对象头里的<code>Mark Word</code>存储的内容也会变化。</p>
<blockquote>
<p>回顾 Java对象的内存结构: 对象有32+32个字节的”对象头”, 其中第一个32字节是”Mark Word”, 存储了hashCode, 锁信息, 以及分代信息等, 结构如下:</p>
</blockquote>
<p>![](/images/Java Tutorials/jmm-object-mark-word.png)</p>
<h5 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h5><p>无锁状态下, 对象Mark Word 锁标志也是01(同偏向锁一样)</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁。<br>偏向锁只是比较，没有使用CAS操作，也没有自旋，所以在没有多线程竞争的情况下，加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。<br>偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p>
<h5 id="轻量级锁-自旋"><a href="#轻量级锁-自旋" class="headerlink" title="轻量级锁(自旋)"></a>轻量级锁(自旋)</h5><p>轻量级锁是指 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），<br>JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<br>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。<br>  如果成功，当前线程获得锁，<br>  如果失败，表示其他线程竞争锁，当前线程便尝试使用 <strong>自旋</strong>来获取锁。<br>因为轻量锁用到了CAS，第一次CAS失败会进入自旋，自旋虽然会消耗CPU，但不会切换线程状态，自旋较适用于锁使用者保持锁时间比较短的情况</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁通过对象内部的监视器(<strong>monitor对象</strong>)实现的，其中monitor对象的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。<br>重量级锁不使用自旋，不会消耗CPU。但会让线程进入阻塞状态让出CPU，增加了线程切换的代价。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考自 https://blog.csdn.net/javazejian/article/details/72828483</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferRemoveSync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用</span></span><br><span class="line">        <span class="comment">//因此sb属于不可能共享的资源,JVM会自动消除内部的锁</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBufferRemoveSync rmsync = <span class="keyword">new</span> StringBufferRemoveSync();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            rmsync.add(<span class="string">"abc"</span>, <span class="string">"123"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h5><p>上面提到重量锁的实现是利用了Monitor对象,<br>编译器在把java文件编译为字节码的后, 会在<code>synchronized</code>代码块前后插入<code>monitorenter</code>和<code>monitorexit</code>指令,<br><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处， JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。<br>“任何Java对象都有一个 monitor对象 与之关联，当且一个 monitor对象 被持有后，它将处于锁定状态。”<br>这两个指令是通过monitor对象实现的（有关<code>monitorenter</code>和<code>monitorexit</code>指令的实现在JVM的InterpreterRuntime.cpp文件），<br>monitor对象可以看成是JVM进程里的C++对象。每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>Monitor模型中, 有三个重要的属性, 可以想象成三个不同的房间：Special Room, Entry Set, Wait Set</p>
<p>如果一个顾客想要进入这个特殊的房间（Special Room），他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。<br>如果，因为某些原因，该客户客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间的可以可以在稍后再次进入那件特殊的房间。</p>
<p>图-Monitor模型:<br>![Monitor模型](/images/Java Tutorials/java_monitor.gif)</p>
<h3 id="Object-wait-和notify"><a href="#Object-wait-和notify" class="headerlink" title="Object.wait()和notify()"></a>Object.wait()和notify()</h3><ul>
<li>The Owner: 指向持有Monitor对象的线程, 同一时刻只允许一个线程持有;</li>
<li>Entry Set: 尝试持有Monitor的线程都会先进入这个队列, 如果线程获取到了Monitor对象, 线程会从Entry Set队列删除, Owner同时会指向这个线程, 这个对列里的线程再次获取锁从而进入The Owner区;</li>
<li>Wait Set: 调用了<code>object.wait()</code>的线程从Owner区进入Wait Set, 等待被唤醒,  如上图中的③,  注意必须拥有锁的线程才能调<code>object.wait()</code>;<ul>
<li><blockquote>
<p>如果调用<code>object.notify()</code>和<code>object.notifyAll()</code>, 线程会进入Entry Set队列或者自旋获取Owner ?</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="比较ReentrantLock和synchronized"><a href="#比较ReentrantLock和synchronized" class="headerlink" title="比较ReentrantLock和synchronized"></a>比较ReentrantLock和synchronized</h2><ol>
<li>ReentrantLock可以”可中断的”获取锁 <code>void lockInterruptibly() throws InterruptedException</code></li>
<li>ReentrantLock可以尝试非阻塞地获取锁 <code>boolean tryLock()</code></li>
<li>ReentrantLock可以超时获取锁，通过<code>tryLock(timeout, unit)</code></li>
<li>ReentrantLock可以实现公平锁，通过<code>new ReentrantLock(true)</code>实现</li>
<li>ReentrantLock对象可以同时绑定多个Condition对象，只需要多次调用<code>newCondition()</code>方法即可。而在synchronized中只能使用一个对象的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li>
<li>Condition对应的方法是<code>await()</code>, <code>signal()</code>, <code>signalAll()</code>, Object对应的方法<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li>
<li>ReentrantLock的实现是 AQS, synchronized实现模型是 Monitor</li>
</ol>
<h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>volatile关键字特性:</p>
<ul>
<li>多CPU环境的可见性: 多CPU的环境下, CPU有可能从寄存器或Cache里直接取值, 这种情况下运行在不同CPU上的线程获取的值可能不同, volitile变量可以保证每次更新都改变到主存, 每次读取都从主存中读取.</li>
<li>volatile可以作为一种开销较低的免锁机制(某些情况下).</li>
<li>volatile变量的”复合操作”(对变量的写操作依赖当前值)不具备原子性.</li>
<li>volatile 的<code>long</code>, <code>double</code>的读写不保证有原子性.</li>
</ul>
<h3 id="volatile不适用的情况"><a href="#volatile不适用的情况" class="headerlink" title="volatile不适用的情况"></a>volatile不适用的情况</h3><ol>
<li>用于计数器(请使用<code>AomicInteger</code>)， 虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。</li>
<li>“依赖当前值”的写操作, 比如<code>i=i+1</code></li>
<li>非原子操作, <code>i++</code>, <code>i=!i</code>都不是原子操作</li>
</ol>
<p>比如以下代码是有问题的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function">protect <span class="keyword">void</span> <span class="title">filp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  i = !i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile适用的情况"><a href="#volatile适用的情况" class="headerlink" title="volatile适用的情况"></a>volatile适用的情况</h3><ol>
<li>作为简单的状态标志, <code>vol_variable = 1</code> 和<code>vol_variable = 0</code> 这种操作是原子的, 对volatile变量的赋值也对其他线程立刻可见;</li>
<li>保证只有一个线程写, 其他线程只能读;</li>
</ol>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>一些概念:</p>
<p>▷原子操作:</p>
<blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/27026846" target="_blank" rel="noopener">对int变量赋值的操作是原子的吗？ - 知乎</a></li>
</ul>
</blockquote>
<p>▷乐观锁 &amp; 悲观锁:</p>
<blockquote>
<ul>
<li>悲观锁: 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，拿到锁之后才可以修改临界区数据；</li>
<li>乐观锁(Optimistic Locking): 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：数据更新和冲突检测。其实现方式有一种比较典型的就是 Compare and Swap(CAS)。</li>
</ul>
</blockquote>
<p>▷CAS:</p>
<blockquote>
<p>CAS(Compare And Swap)：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。<br>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B并返回True，否则就什么都不做并返回False。比较+替换是一个原子操作。</p>
</blockquote>
<h3 id="Unsafe提供的CAS"><a href="#Unsafe提供的CAS" class="headerlink" title="Unsafe提供的CAS"></a>Unsafe提供的CAS</h3><p>上面提到<code>ReentrantLock.lock()</code>的实现是通过AQS, AQS的 CAS方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                        (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">            <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS 使用 unsafe包提供的CAS (Native方法), 然后通过JNI 调用到了Hotspot的 Unsafe.cpp中,<br>C++代码最终调用的是<code>Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value)</code>,<br>cmpxchg()调用了汇编 <code>CMPXCHG</code>指令，具体汇编指令可以查看Intel手册 <a href="http://faydoc.tripod.com/cpu/cmpxchg.htm" target="_blank" rel="noopener">CMPXCHG</a></p>
<h3 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a>CAS的ABA问题</h3><p>ABA问题: 线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。以上就是由于ABA问题带来的隐患，各种乐观锁的实现中通常都会用版本戳version来避免，详见 [AtomicStampedReference]</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><blockquote>
<p>原子变量是一种更好的”Volatile”. – 《Java并发编程实战》</p>
</blockquote>
<p>java提供了几个类用于原子操作:</p>
<ol>
<li>原子更新基本类型：AtomicBoolean，AtomicInteger, AtomicLong.</li>
<li>原子更新数组：AtomicIntegerArray，AtomicLongArray, AtomicReferenceArray.</li>
<li>原子更新引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference.</li>
<li>原子更新字段类型：AtomicReferenceFieldUpdater, AtomicIntegerFieldUpdater, AtomicLongFieldUpdater.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// incrementAndGet提供了几个方法实现原子操作:</span></span><br><span class="line"><span class="keyword">int</span> i = atomicInteger.get();</span><br><span class="line">atomicInteger.getAndSet(<span class="number">0</span>); <span class="comment">// 当前值设置为0, 并返回之前的值</span></span><br><span class="line">atomicInteger.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// 如果当前值等于1, 则更新为3</span></span><br><span class="line">atomicInteger.decrementAndGet(<span class="number">1</span>); <span class="comment">// 自减</span></span><br><span class="line">atomicInteger.incrementAndGet(<span class="number">1</span>); <span class="comment">// 自增</span></span><br></pre></td></tr></table></figure>

<p>大多数方法都是调用<code>sun.misc.Unsafe</code>里的方法实现的, <code>sun.misc.Unsafe</code>只提供三种CAS方法： <code>compareAndSwapObject</code>, <code>compareAndSwapInt</code>和<code>compareAndSwapLong</code></p>
<h3 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h3><p>Java中的 AtomicStampedReference<e>也实现了ABA，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题</e></p>
<blockquote>
<p>参考 <a href="http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html" target="_blank" rel="noopener">用AtomicStampedReference解决ABA问题</a> @Ref</p>
</blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是一个为线程提供线程局部变量的工具类。为线程提供一个线程私有的变量副本，这样多个线程都可以随意更改自己线程局部的变量，不会影响到其他线程。<br><del>不过需要注意的是，ThreadLocal提供的只是一个浅拷贝，如果变量是一个引用类型，那么就要考虑它内部的状态是否会被改变，想要解决这个问题可以通过重写ThreadLocal的<code>initialValue()</code>函数来自己实现深拷贝，建议在使用ThreadLocal时一开始就重写该函数。</del><br>首次调用<code>threadLocal.get()</code>方法时会调用<code>initialValue()</code>赋一个初始值。</p>
<p>例子: 1.8之前提供的<code>SimpleDateFormat</code>不是线程安全的, 下面的代码用ThreadLocal 解决这个问题:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Session <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前线程的ThreadLocal 为新的对象</span></span><br><span class="line">threadLocal.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yy-MM-dd"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取当前线程的ThreadLocal 内保存的对象</span></span><br><span class="line">DateFormat localFormatter = (DateFormat)threadLocal.get();</span><br></pre></td></tr></table></figure>

<p>注： JDK1.8的 DateTimeFormatter是线程安全的.</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>我们需要知道Thread类中有一个threadLocals变量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>中含有一个叫做<code>ThreadLocalMap</code>的内部类，该类为一个采用线性探测法实现的<code>HashMap</code>。<br>这个 HashMap 的 Entry继承了WeakReference:  <code>Entry(ThreadLocal,Object)</code>,它的 key为<code>ThreadLocal</code>对象, value是缓存的本地对象,<br>从 ThreadLocal中 get值的时候，首先通过 <code>Thread.currentThread</code>得到当前线程，然后拿到这个线程的 ThreadLocalMap，取得Entry中的value值。</p>
<p>下面是<code>ThreadLocalMap</code>代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">    * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">    * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">    * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">    * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">    * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       Object value;</span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>中只有三个成员变量，这三个变量都是与<code>ThreadLocalMap</code>的hash策略相关的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">* to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">* inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">* searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">* (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">* in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">* are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">* less common cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">* zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">* implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">* multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the next hash code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的实例变量<code>threadLocalHashCode</code>是用来进行寻址的hashcode，它由函数 <code>nextHashCode()</code>生成，该函数简单地通过一个增量HASH_INCREMENT来生成hashcode。至于为什么这个增量为0x61c88647，主要是因为ThreadLocalMap的初始大小为16，每次扩容都会为原来的2倍，这样它的容量永远为2的n次方，该增量选为0x61c88647也是为了尽可能均匀地分布，减少碰撞冲突。</p>
<p><code>ThreadLocal</code>部分参考自: <a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">聊一聊Spring中的线程安全性 | SylvanasSun’s Blog</a> @Ref</p>
<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>如果在父线程中创建 ThreadLocal，会发现父线程设置的值在子线程中无法获取，JDK中有InheritableThreadLocal解决此问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThreadUsage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新启一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadLocal.get() -&gt; "</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>InheritableThreadLocal 继承了 ThreadLocal<t>，并且数据存放在Thread的 类变量的 inheritableThreadLocals中，变量类型是 ThreadLocal.ThreadLocalMap;<br>在 Thread 构造方法调用的 init() 中，可看见如果 parent.inheritableThreadLocals不为空，则 ThreadLocal.createInheritedMap()拷贝 ThreadLocalMap，注意这里的拷贝是浅拷贝。子线程如果修改了继承自父线程的ThreadLocal，其他的子线程也可能会看到这个改变。</t></p>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1162226" target="_blank" rel="noopener">alibaba/TransmittableThreadLocal</a></p>
</blockquote>
<h2 id="Executor线程池"><a href="#Executor线程池" class="headerlink" title="Executor线程池"></a>Executor线程池</h2><p>线程池相关类和方法:</p>
<ul>
<li>ExecutorService: Java线程池的接口, 提供了如下方法:<ul>
<li><code>void execute(Runnable command)</code> 执行Ruannable类型的任务</li>
<li><code>Future&lt;?&gt; submit(Runnable task)</code> 可用来提交Callable或Runnable任务，并返回代表此任务的Future对象</li>
<li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>: 同上</li>
<li><code>void shutdown()</code> : 关闭线程池，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。最终调用了每个线程的<code>interrupt()</code></li>
<li><code>void shutdownNow()</code> : 关闭线程池, 中断正在处理任务的线程，也不处理阻塞队列中已保存的任务。最终调用了每个线程的<code>interrupt()</code></li>
<li><code>boolean isShutdown()</code></li>
</ul>
</li>
<li>ThreadPoolExecutor: 实现了ExecutorService接口, 通用线程池</li>
<li>ScheduledExecutorService: ExecutorService的实现类, 用执行定时任务<ul>
<li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit)</code>: 执行定时任务</li>
</ul>
</li>
<li>Executors: 线程池的工厂类, 用于创建线程池<ul>
<li><code>ExecutorService newCachedThreadPool()</code>: 创建一个可缓存线程池，队列容量固定是1（可以认为没有队列），线程数会一直增长（如果没有空闲线程），如果线程空闲超过60s会被回收；</li>
<li><code>ExecutorService newFixedThreadPool(int nThreads)</code>: 创建一个定长线程池，超出的线程会进入等待队列，队列是无限大的；</li>
<li><code>ExecutorService newSingleThreadExecutor()</code>: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
<li><code>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code>: 创建一个定长线程池，支持定时及周期性任务执行。</li>
</ul>
</li>
</ul>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tpoolTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ExecutorService cachedPool = Executors.newCachedThreadPool();</span><br><span class="line">  ExecutorService fixedPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">  ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// execute()无返回值</span></span><br><span class="line">  cachedPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/*doSomething*/</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  cachedPool.shutdown();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// submit()有返回值</span></span><br><span class="line">  <span class="comment">// labmda写法</span></span><br><span class="line">  Futrue&lt;String&gt; futrue = fixedPool.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  String ret = futrue.get();</span><br><span class="line">  fixedPool.shutdownNow();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// schedule()增加定时任务</span></span><br><span class="line">  schedulePool.schedule(() -&gt; &#123;</span><br><span class="line">			System.out.print(<span class="string">"scheduled task"</span>);</span><br><span class="line">		&#125;, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">  );</span><br><span class="line">  schedulePool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池的<code>shutdown</code>或者<code>shutdownNow</code>方法来关闭线程池。原理是遍历线程池的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法停止。<br>两者的区别：<br><code>shutdown</code> 方法将执行平缓的关闭过程：不在接收新的任务，同时等待已提交的任务执行完成，包括哪些还未开始执行的任务。<br><code>shutdownNow</code> 方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<h3 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>工厂类<code>Executors</code>包装了对<code>ThreadPoolExecutor</code>构造方法的调用, 隐藏了很多创建线程池的细节, 所以在并发严格的情况下, 最好的方式还是直接调用<code>ThreadPoolExecutor</code>构造方法创建线程池.</p>
<p>ThreadPoolExecutor的构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造器中各个参数的含义:</strong></p>
<ul>
<li><strong>corePoolSize</strong>: （线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到线程数大于 corePoolSize 时就不再创建。如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有基本线程。</li>
<li><strong>workQueue</strong>: 一个阻塞队列，用来存储等待执行的任务。当线程数已经大于corePoolSize时, 再向线程池添加任务，会把任务放入该队列中。阻塞队列有以下几种选择：<ul>
<li><code>LinkedBlockingQueue</code>：一个基于链表结构的 <em>无界阻塞队列</em>，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 <code>ArrayBlockingQueue</code>。<br>静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li>
<li><code>SynchronousQueue</code>：一个不存储元素的 <em>有界阻塞队列</em>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态（可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。），吞吐量通常要高于<code>LinkedBlockingQueue</code>，<br>静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li>
<li><code>ArrayBlockingQueue</code>：基于数组结构的 <em>有界阻塞队列</em>，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li><code>PriorityBlockingQueue</code>：一个具有优先级的 <em>无限阻塞队列</em>。</li>
</ul>
</li>
<li><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数（池+队列里的线程数）。线程池新增任务时判断顺序<code>corePoolSize?</code> -&gt; <code>workQueue?</code> -&gt; <code>maximumPoolSize</code><ul>
<li>如果是<code>LinkedBlockingQueue</code>这种 <em>近似无界的队列</em>，<code>maximumPoolSize</code>没有效果；</li>
<li>如果是<code>ArrayBlockingQueue</code>这种 <em>有界阻塞队列</em>，如果队列满了，并且已创建的线程数小于<code>maximumPoolSize</code>，则线程池会再创建新的线程执行任务，直到总线程数超过<code>maximumPoolSize</code>。</li>
</ul>
</li>
<li><strong>keepAliveTime</strong>: 工作线程空闲后，保持存活的时间。线程池会一直终止空闲超过keepAliveTime的线程，直到线程池中的线程数不超过<code>corePoolSize</code>。</li>
<li><strong>unit</strong>: keepAliveTime的单位</li>
<li><strong>handler</strong>: 当队列和线程池都满了（<code>maximumPoolSize</code>），说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ul>
</li>
</ul>
<p>再回过来看Executors提供的几种工厂方法:</p>
<blockquote>
<ul>
<li><code>newCachedThreadPool()</code>: corePoolSize为0, maximumPoolSize为INT.Max, 队列使用SynchronousQueue不存储线程, 所以有新任务提交时, 如果没有空闲的线程, 则继续创建新的线程, 直到线程数达到<code>INT.Max</code>. 空闲时间超过60s的线程会被回收；</li>
<li><code>newFixedThreadPool(int nThreads)</code>: corePoolSize和maximumPoolSize都是nThreads, 意味着线程池大小从0会增长到coreSize, 队列是近似无界队列LinkedBlockingQueue, 可以一直接收新任务, keepAliveTime=0意味着不会回收空闲线程</li>
<li><code>newSingleThreadExecutor()</code>: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
</blockquote>
<p>所以,<br>使用<code>newCachedThreadPool()</code>的问题在于, 如果没有控制好任务大小(所有线程一直在忙) 线程数会一直增长（<code>maxPoolSize</code> 是<code>Integer.MAX_VALUE</code>). 只有线程空闲的时候才有机会减少线程数.<br>使用<code>newFixedThreadPool()</code>的问题在于, 虽然工作线程数是固定的, 但是等待队列大小是<code>Integer.MAX_VALUE</code>,<br>这两种线程池都有可能因为创建大量线程导致OOM.</p>
<h4 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h4><p>线程池创建线程时，会将工作线程封装成Worker类，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。<br>我们可以从Worker的run方法里看到这点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行当前task或从队列里取出新的task</span></span><br><span class="line">      <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        task.run(); <span class="comment">// 执行Runnable.run()</span></span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化线程池"><a href="#优化线程池" class="headerlink" title="优化线程池"></a>优化线程池</h3><p>线程池参数的解析和使用建议:</p>
<ul>
<li>线程池大小:<ul>
<li>如果是计算密集任务，一般设置为cpu核心数，</li>
<li>如果是IO密集任务一般设置为核心数2~3倍；// 理论值, 实际工程中远比这个大</li>
</ul>
</li>
<li>默认情况下，核心工作线程值在初始的时候被创建，当新任务来到的时候被启动，但是我们可以通过重写<code>prestartCoreThread</code>或<code>prestartCoreThreads</code>方法来改变这种行为。<br>通常场景我们可以在应用启动的时候来WarmUp核心线程，从而达到任务过来能够立马执行的结果，使得初始任务处理的时间得到一定优化。</li>
<li>合理的拒绝策略: @TODO</li>
<li>队列的选择：<ul>
<li>无界队列：<ul>
<li>使用无界队列如<code>LinkedBlockingQueue</code>没有指定最大容量的时候，将会引起当核心线程都在忙的时候，新的任务被放在队列上。<br>因此，永远不会有大于<code>corePoolSize</code>的线程被创建，因此<code>maximumPoolSize</code>参数将失效。<br>这种策略比较适合所有的任务都不相互依赖，独立执行。如Web服务器中，每个线程独立处理请求。<br>但是当任务处理速度小于任务进入速度的时候会引起队列的无限膨胀。</li>
<li>先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先得到执行，<br>需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</li>
</ul>
</li>
<li>有界队列：有界队列如<code>ArrayBlockingQueue</code>帮助限制资源的消耗，但是不容易控制。<br>队列长度和<code>maximumPoolSize</code>这两个值会相互影响，<br>使用 <em>大的队列</em> 和 小<code>maximumPoolSize</code>会降低CPU占用、操作系统资源、上下文切换的消耗，但是会降低吞吐量，如果任务被频繁的阻塞如IO线程，系统其实可以调度更多的线程。<br>使用 <em>小的队列</em> 通常需要大<code>maximumPoolSize</code>，从而使得CPU更忙一些，但是又会增加降低吞吐量的线程调度的消耗。<br>总结一下：是IO密集型可以考虑 <em>多些线程+小的队列</em> 来平衡CPU的使用，CPU密集型可以考虑 <em>少些线程+大的队列</em> 减少线程调度的消耗。</li>
</ul>
</li>
</ul>
<p><strong>线程池的监控:</strong><br>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。<br>通过扩展线程池进行监控。通过继承线程池并重写线程池的b<code>eforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</li>
</ul>
<p>参考:</p>
<ul>
<li>@Ref <a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">聊聊并发（三）——JAVA线程池的分析和使用</a></li>
<li>@Ref <a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">如何合理地估算线程池大小？ | 并发编程网 – ifeve.com</a></li>
<li>@Ref <a href="https://www.zhihu.com/question/38128980" target="_blank" rel="noopener">java线程池大小为何会大多被设置成CPU核心数+1？ - 知乎</a></li>
</ul>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Callable</code>接口类似于Runnable，但是Runnable不会返回结果，并且无法抛出返回结果的异常，<code>Callable</code>功能更强大一些，被线程执行后，可以返回值，这个返回值可以被<code>Future</code>拿到。<br>如果主线程发起IO操作并轮询等待返回结果，这种很适合用Callable/Future。</p>
<ul>
<li><code>Callable</code>有些类似<code>Runnable</code>, 它们都是接口, 前者需要实现<code>V call()</code>, 后者需要实现<code>void run()</code>;</li>
<li>需要用<code>FutureTask</code>包装一下<code>Callable</code>, <code>FutureTask</code>提供了<code>get()</code>方法, 可以获取执行结果;</li>
<li>创建<code>Thread</code>实例, 通过构造器<code>Thread(FutureTask)</code>, 这里实际还是调用的<code>Thread(Runnable)</code>, <code>FutureTask</code>接口继承自<code>Runnable</code>;</li>
<li>Future是 <code>ExecutorService.submit(Callable)</code>返回的类型;</li>
<li>实际上<code>FutureTask</code>实现了<code>Future</code>接口, 通过<code>FutureTask</code> 和 <code>Future</code>类型引用都可以调用 <code>get()</code> , <code>cancel()</code> , <code>isDone()</code> , <code>isCancelled()</code>等方法;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAndFutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FutureTask 示例1:</span></span><br><span class="line"><span class="comment">        由FutureTask直接创建线程,并执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureTaskExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Callable实现类</span></span><br><span class="line">        Callable callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建FutureTask</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread 并开始执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞在此, 直到任务完成:</span></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Future 示例2:</span></span><br><span class="line"><span class="comment">        Callable 提交到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lambda创建Callable实现类</span></span><br><span class="line">        Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125; ;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(callable);</span><br><span class="line"></span><br><span class="line">        Integer result = future.get();</span><br><span class="line">        <span class="comment">// 或取消线程</span></span><br><span class="line">        future.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题: <code>FutureTask.cancel()</code> 和 <code>Thread.interrupt()</code>有什么区别?<br>通过查看<code>cancel()</code>的源码发现, 实际<code>cancel()</code>最终还是调用了<code>Thread.interrupt()</code>, 所以, <code>FutureTask.cancel()</code>也无法真正停止异步任务,<br>如果真的需要任务可以被终止/取消, 那么就需要在<code>Runnable</code>或<code>Callable</code>的主循环里捕捉InterruptException异常.</p>
<h2 id="ListenableFuture-Guava"><a href="#ListenableFuture-Guava" class="headerlink" title="ListenableFuture(Guava)"></a>ListenableFuture(Guava)</h2><p>Guava的 Listenable Future对 Future做了改进，支持注册一个任务执行结束后回调函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ListenableFuture</span></span><br><span class="line">ListenableFuture&lt;String&gt; listenableFuture =</span><br><span class="line">listeningExecutor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addCallback() 给 ListenableFuture增加回调</span></span><br><span class="line">Futures.addCallback(ListenableFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something on success</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable thrown)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="CompletableFuture-Java8"><a href="#CompletableFuture-Java8" class="headerlink" title="CompletableFuture(Java8)"></a>CompletableFuture(Java8)</h2><p>本节参考:</p>
<blockquote>
<ul>
<li><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">Java CompletableFuture 详解 | 鸟窝</a></li>
<li><a href="https://colobu.com/2018/03/12/20-Examples-of-Using-Java%E2%80%99s-CompletableFuture/" target="_blank" rel="noopener">[译]20个使用 Java CompletableFuture的例子 | 鸟窝</a></li>
</ul>
</blockquote>
<p>Java8的CompletableFuture参考了Guava的ListenableFuture的思路，CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。</p>
<p>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p>
<p>与Guava ListenableFuture相比，CompletableFuture不仅可以在任务完成时注册回调通知，而且可以指定任意线程，实现了真正的异步非阻塞。</p>
<p><strong>▶ 创建一个CompletableFuture:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>runAsync方法不支持返回值/supplyAsync可以支持返回值<br>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。</p>
</blockquote>
<p><strong>▶ 使用 thenApply 串行任务:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<br>T：上一个任务返回结果的类型<br>U：当前任务的返回值类型</p>
</blockquote>
<p><strong>▶使用 thenAccept 消费处理结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);</span><br><span class="line">public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);</span><br><span class="line">public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor);</span><br></pre></td></tr></table></figure>

<p><strong>▶ 使用 thenCombine 合并任务:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn);</span><br><span class="line">public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn);</span><br><span class="line">public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn,Executor executor);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p>
</blockquote>
<p><strong>▶ 使用 thenCompose 流水化处理任务:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) ;</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor) ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>thenCompose 方法允许你对两个 CompletionStage 进行流水线操作，第一个操作完成时，将其结果作为参数传递给第二个操作。</p>
</blockquote>
<p><strong>▶ 代码示例1: thenApply/whenComplete/exceptionally</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).thenApply(<span class="keyword">new</span> Function&lt;Long, Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Long t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = t*<span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">"result2="</span>+result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Void, Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Void t, Throwable action)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行完成！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    future.exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行失败！"</span>+t.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>▶ anyOf / allOf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs);</span><br><span class="line">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>anyOf: 当任意一个CompletableFuture完成后， 创建一个完成的CompletableFuture<br>allOf: 当所有的阶段完成后, 创建一个完成的CompletableFuture</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;List&gt; <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future1 = rpcService1.invoke();</span><br><span class="line">    CompletableFuture&lt;Double&gt; future2 = rpcService2.invoke();</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture</span><br><span class="line">        .allOf(future1, future2)</span><br><span class="line">        .thenApply(v -&gt; &#123;</span><br><span class="line">            Double d1 = future1.get();</span><br><span class="line">            Double d2 = future2.get();</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(d1, d2);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>Java在JDK 7之后加入了并行计算的框架Fork/Join，可以解决我们系统中大数据计算的性能问题。Fork/Join采用的是分治法，Fork是将一个大任务拆分成若干个子任务，子任务分别去计算，而Join是获取到子任务的计算结果，然后合并，这个是递归的过程。子任务被分配到不同的核上执行时，效率最高。</p>
<p>Fork/Join框架的核心是<code>ForkJoinPool</code>(类似<code>ExecuteService</code>会给线程池中的线程分发任务，不同之处在于它使用了工作窃取算法，所谓工作窃取，是采用分治法的思想，将一个大任务拆分为若干互不依赖的子任务，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务。同时，为了最大限度地提高并行处理能力，采用了工作窃取算法来运行任务，也就是说当某个线程处理完自己工作队列中的任务后，尝试当其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。</p>
<p><code>ForkJoinTask</code>是一个抽象类，有两个实现子类，<code>RecursiveTask</code>（有返回值）和<code>RecursiveAction</code>（无返回结果），我们自己定义任务时，只需选择这两个类继承即可。<br>继承<code>RecursiveTask</code>和<code>RecursiveAction</code>类必须实现<code>compute()</code>方法，在这个方法里要实现递归控制条件。</p>
<p><code>compute()</code>的实现通常为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (任务足够小)&#123;</span><br><span class="line">  直接执行该任务;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  将任务一分为二;</span><br><span class="line">  Fork执行这两个任务;</span><br><span class="line">  Join等待结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个计算数组之和的Fork/Join例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJForkJoinTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 要计算和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> low;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (high - low &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 小于阈值则直接计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一个大任务分割成两个子任务</span></span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            CJForkJoinTask left = <span class="keyword">new</span> CJForkJoinTask(array, low, mid);</span><br><span class="line">            CJForkJoinTask right = <span class="keyword">new</span> CJForkJoinTask(array, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line"></span><br><span class="line">            sum = left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成大数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = genArray(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Fork/Join任务:</span></span><br><span class="line">        CJForkJoinTask CJForkJoinTask = <span class="keyword">new</span> CJForkJoinTask(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建Fork/Join线程池:</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 提交任务到线程池:</span></span><br><span class="line">        forkJoinPool.submit(CJForkJoinTask);</span><br><span class="line">        <span class="comment">// 获取结果:</span></span><br><span class="line">        Integer result = CJForkJoinTask.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>旧的线程安全的集合: 任何集合类都可以通过使用同步包装器变成线程安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt; synchMap = Collections.synchronizedList(<span class="keyword">new</span> HasMap&lt;K,V&gt;());</span><br></pre></td></tr></table></figure>

<p>java.util.concurrent包提供了线程安全的集合, 继承关系如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阻塞队列</span><br><span class="line">  |- BlockingQueue（单向队列）</span><br><span class="line">       |- ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</span><br><span class="line">       |- LinkedBlockingQueue: 一个由链表结构组成的有界阻塞队列</span><br><span class="line">       |- PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列</span><br><span class="line">       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列</span><br><span class="line">  |- BlockingDeque（双向队列）</span><br><span class="line">       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列</span><br><span class="line"></span><br><span class="line">非阻塞队列</span><br><span class="line">  |- ConcurrentLinkedQueue</span><br><span class="line">  |- ConcurrentLinkedDeque</span><br><span class="line"></span><br><span class="line">Map</span><br><span class="line">  |- ConcurrentHashMap</span><br><span class="line">  |- ConcurrentSkipListMap</span><br><span class="line"></span><br><span class="line">Set</span><br><span class="line">  |- ConcurrentSkipListSet</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="center">是否阻塞</th>
<th align="center">是否有界</th>
<th align="center">队列长度</th>
<th align="center">内部实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArrayBlockingQueue</td>
<td align="center">阻塞</td>
<td align="center">有界</td>
<td align="center">构造器指定</td>
<td align="center">循环数组,FIFO</td>
</tr>
<tr>
<td align="left">LinkedBlockingQueue</td>
<td align="center">阻塞</td>
<td align="center">有界</td>
<td align="center">构造器指定, 默认Int.Max</td>
<td align="center">链表,FIFO</td>
</tr>
<tr>
<td align="left">LinkedBlockingDeque</td>
<td align="center">阻塞</td>
<td align="center">有界</td>
<td align="center">构造器指定, 默认Int.Max</td>
<td align="center">双向链表,FIFO</td>
</tr>
<tr>
<td align="left">SynchronousQueue</td>
<td align="center">阻塞</td>
<td align="center">有界</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">PriorityBlockingQueue</td>
<td align="center">阻塞</td>
<td align="center">无界</td>
<td align="center">构造器指定, 默认11, 无限扩容</td>
<td align="center">二叉堆</td>
</tr>
<tr>
<td align="left">DelayQueue</td>
<td align="center">阻塞</td>
<td align="center">无界</td>
<td align="center">初始empty, 无限扩容</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">ConcurrentLinkedQueue</td>
<td align="center">非阻塞</td>
<td align="center">无界</td>
<td align="center">初始empty, 无限扩容</td>
<td align="center">单向链表</td>
</tr>
<tr>
<td align="left">ConcurrentLinkedDeque</td>
<td align="center">非阻塞</td>
<td align="center">无界</td>
<td align="center">初始empty, 无限扩容</td>
<td align="center">双向链表</td>
</tr>
</tbody></table>
<p>线程安全的队列可以分为 <strong>阻塞队列</strong> , <strong>非阻塞队列</strong>, 按照是否可无限扩容分为 <strong>有界队列</strong> , <strong>无界队列</strong> :</p>
<ul>
<li>阻塞队列是指: 当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。<br>阻塞队列一般是用锁(例如<code>BlockingQueue</code>)来实现,<br>阻塞队列继承自接口<code>BlockingQueue</code>, 常用的有: <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>LinkedBlockingDeque</code>;</li>
<li>非阻塞队列是指:<br>非阻塞队列一般是用<code>CAS</code>实现的”Lock-Free”方法,<br>非阻塞队列主要有: <code>ConcurrentLinkedQueue</code>, <code>ConcurrentLinkedDeque</code>;</li>
<li>有界/无界: 无界队列可以无限扩容</li>
</ul>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>阻塞队列一般使用condition实现消费者和生产者的”通讯”。<br>比如当生产者往满的队列里添加元素时会阻塞住，当消费者消费了队列中的元素后，会通过condition通知生产者当前队列可用。</p>
<p>BlockingQueue接口方法有put/take：</p>
<p><strong>阻塞方法：</strong></p>
<ul>
<li>put(E o)：将元素添加到此队列尾，如果队列满将一直阻塞，可以响应中断。</li>
<li>take()：检索并移除此队列的头部，如果队列为空则一直阻塞，可以响应中断。</li>
</ul>
<p><strong>不阻塞且抛异常的方法：</strong></p>
<ul>
<li>add(E o)：将元素添加到此队列中，如果队列已满不会阻塞，直接抛出 IllegalStateException</li>
<li>remove()： 移除队列头部的元素，如果队列为空不会阻塞，直接抛出 IllegalStateException</li>
</ul>
<p><strong>不阻塞且带返回值的方法：</strong></p>
<ul>
<li>offer(E o)： 将元素添加到队列，不阻塞，成功返回true，失败返回false；</li>
<li>offer(E o, long timeout, TimeUnit unit)： 带等待时间的offer方法，如果队列已满，将等待指定的时间；</li>
<li>poll(long timeout, TimeUnit unit)： 返回队列的头部并移除，如果队列为空，则等待指定等待的时间。如果取不到返回null；</li>
</ul>
<p>其他方法：</p>
<ul>
<li>drainTo(Collection&lt;? super E&gt; c)： 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</li>
<li>drainTo(Collection&lt;? super E&gt; c,int maxElements)： 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</li>
<li>remainingCapacity()： 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的元素数量；如果没有内部限制，则返回 Integer.MAX_VALUE。</li>
</ul>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><ul>
<li>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序</li>
<li>ArrayBlockingQueue内部由 一个公共的读写锁，两个Condition(notFull、notEmpty) 管理队列满或空时的阻塞状态。<br>因为在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue。</li>
<li>构造器<code>ArrayBlockingQueue(int)</code>都要指定数组初始大小，并且大小不再扩展。</li>
<li>默认情况下ArrayBlockingQueue不保证访问者公平的访问队列，所谓“公平访问队列”是指：当队列可用时，可以按照阻塞的先后顺序访问队列。即：<br>先阻塞的生产者线程，可以先往队列里插入元素；<br>先阻塞的消费者线程，可以先从队列里获取元素。<br>我们可以使用以下代码创建一个“公平的”阻塞队列：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = new  ArrayBlockingQueue(1000,true);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><ul>
<li>LinkedBlockingQueue是链表实现的“有界”的阻塞队列。构造函数可以指定最大长度，队列的默认和最大长度为<code>Integer.MAX_VALUE</code></li>
<li>内部基于链表实现，由两个锁（takeLock与putLock），以及 两个Condition(notFull、notEmpty) 管理队列满或空时的阻塞状态。<br>由于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li>
</ul>
<h5 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h5><ul>
<li>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。构造函数可以指定最大长度，队列的默认和最大长度为<code>Integer.MAX_VALUE</code></li>
<li>相比其他的阻塞单向队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法</li>
</ul>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>SynchronousQueue是无界的，是一种无缓冲的等待队列，<br>但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加，可以认为SynchronousQueue是一个缓存值为1的阻塞队列，<br>但是 isEmpty()方法永远返回是true，remainingCapacity() 方法永远返回是0，remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null。</p>
<p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别：如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><ul>
<li>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。<br>队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：<ul>
<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</li>
</ul>
</li>
<li>队列中的Delayed必须实现compareTo来指定元素的顺序。</li>
</ul>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><ul>
<li>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</li>
<li>内部基于二叉堆。使用一把公共的读写锁。虽然实现了BlockingQueue接口，其实没有任何阻塞队列的特征，空间不够时会自动扩容。</li>
<li>构造器：<ul>
<li><code>PriorityBlockingQueue()</code>：默认数组初始大小11，不指定Comparator，存入的对象需要实现<code>Comparable</code>接口；</li>
<li><code>PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code>；</li>
</ul>
</li>
</ul>
<h4 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h4><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><ul>
<li>ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，它采用FIFO原则对元素进行排序。采用“wait-free”算法（即CAS）来实现的。</li>
<li>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法，见：<br><a href="https：//www.ibm.com/developerworks/cn/java/j-jtp04186/">Java 理论与实践： 非阻塞算法简介</a></li>
</ul>
<h5 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h5><ul>
<li>ConcurrentLinkedDeque是一种基于双向链表的无界链表。</li>
<li>与大多数集合类型不同，其size方法不是一个常量操作。因为链表的异步性质，确定当前元素的数量需要遍历所有的元素，所以如果在遍历期间有其他线程修改了这个集合，size方法就可能会报告不准确的结果。</li>
<li>批量的操作：包括添加、删除或检查多个元素，比如addAll()、removeIf()或者removeIf() 或forEach()方法，这个类型并不保证以原子方式执行。由此可见如果想保证原子访问，不得使用批量操作的方法。</li>
</ul>
<h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><h4 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h4><p>ConcurrentSkipListSet的实现非常简单，其内部引用了一个ConcurrentSkipListMap对象，所有API方法都是调用了ConcurrentSkipListMap。<br>ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集。但是：<br>第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的；<br>第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的；</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul>
<li>数据分段存储，每个段有一个写锁，当一个线程占用某个段的锁时，其他段也可以正常访问，有效分散了阻塞的概率，而且没有读锁；</li>
<li>没有读锁是因为put/remove动作是个原子动作(比如put是一个对数组元素/Entry 指针的赋值操作)，读操作不会看到一个更新动作的中间状态；</li>
<li>每次扩容为原来容量的2倍，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容；</li>
<li>在获取size操作的时候，不是直接把所有segment的count相加就可以可到整个ConcurrentHashMap大小，也不是在统计size的时候把所有的segment的put、remove、clean方法全部锁住，这种方法太低效。<br>在累加count操作过程中，之前累加过的count发生变化的几率非常小，所有ConcurrentHashMap的做法是先尝试2（RETRIES_BEFORE_LOCK）次通过不锁住Segment的方式统计各个Segment大小，如果统计的过程中，容器的count发生了变化，再采用加锁的方式来统计所有的Segment的大小。</li>
<li>putIfAbsent(k,v)：当k已经存在时返回已存在的v。</li>
</ul>
<h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><ul>
<li>JDK6新增的并发优化的SortedMap，以SkipList实现。SkipList是红黑树的一种简化替代方案，是个流行的有序集合算法。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。</li>
<li>ConcurrentSkipListMap 的key是有序的；</li>
<li>与ConcurrentHashMap相比，ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log(n)，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出优势。</li>
<li>它的size()比较特殊，需要遍历所有元素；</li>
</ul>
<h3 id="Deprecated-Vector-amp-HashTable"><a href="#Deprecated-Vector-amp-HashTable" class="headerlink" title="Deprecated: Vector &amp; HashTable"></a>Deprecated: Vector &amp; HashTable</h3><p>Vector和HashTable已经被弃用，取而代之的是ArrayList和HashMap，如果要使用线程安全的容器，可以用Collections转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; syncList = Collections.synchronzedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt; syncMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K,V&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="计数器CountDownLatch"><a href="#计数器CountDownLatch" class="headerlink" title="计数器CountDownLatch"></a>计数器CountDownLatch</h2><blockquote>
<p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。<br>CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>
</blockquote>
<p>CountDownLatch提供了类似计数器的同步手段, 构造器和主要方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;  &#125;;  //参数count为计数值</span><br><span class="line"></span><br><span class="line">//将count值减1</span><br><span class="line">public void countDown() &#123; &#125;;</span><br><span class="line"></span><br><span class="line">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public void await() throws InterruptedException &#123; &#125;;</span><br><span class="line"></span><br><span class="line">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>Example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 在这里阻塞直到latch执行过两次countDown()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他参考: <a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">什么时候使用CountDownLatch - ImportNew</a> @Ref</p>
</blockquote>
<h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>Semaphore翻译成字面意思为 “信号量”，Semaphore可以控同时访问的任务个数，通过 acquire() 获取一个许可，如果没有就等待； release() 释放一个许可。<br>构造器和主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了一个fair表示是否是公平的，即等待时间越久的越先获取许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></span><br></pre></td></tr></table></figure>

<h2 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h2><p>@TODO</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>Server/Client的Socket API介绍.</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">Socket client = server.accept(); <span class="comment">// 阻塞</span></span><br><span class="line">InputStream  input  = client.getInputStream();</span><br><span class="line">OutputStream output = client.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> value = input.readDouble();</span><br><span class="line">output.writeDouble(value);</span><br><span class="line"></span><br><span class="line">inpput.close();</span><br><span class="line">output.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure>

<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(host, port); <span class="comment">// 阻塞</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">...</span><br><span class="line">out.close();</span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">socket.connect(<span class="keyword">new</span> InetSocketAddress(host, port), timeout); <span class="comment">// 阻塞</span></span><br></pre></td></tr></table></figure>

<h2 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h2><ul>
<li>Socket.shutdownOutput():</li>
<li>Socket.shutdownInput():</li>
<li>boolean isOutputShutdown():</li>
<li>boolean isInputShutdown():</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="comment">// 向out写入一些数据, 写入完毕, 半关闭socket的输出</span></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"><span class="comment">// 此时socket仍可以从InputStream读取...</span></span><br><span class="line">socket.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="可中断套接字"><a href="#可中断套接字" class="headerlink" title="可中断套接字"></a>可中断套接字</h2><p>当连接到一个套接字时，当前线程将会被阻塞直到建立连接或产生超时为止。java.nio包提供的一个特性——SocketChannel类，与上面的Socket不同，SocketChannel是可以中断的<br>如果发生中断, 下面的操作不会阻塞, 而是抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.socket().connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(channel);</span><br><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (in.hasNextLine())</span><br><span class="line">     String line = in.nextLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="从BIO到NIO"><a href="#从BIO到NIO" class="headerlink" title="从BIO到NIO"></a>从BIO到NIO</h2><p>BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。<br>一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。<br>虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。</p>
<p>Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。<br>NIO（Non-blocking I/O）是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p>
<h2 id="NIO包介绍"><a href="#NIO包介绍" class="headerlink" title="NIO包介绍"></a>NIO包介绍</h2><p>Java Non-blocking I/O主要有三大核心部分：<code>Channel</code>(通道)，<code>Buffer</code>(缓冲区), <code>Selector</code>；<br>除此之外，Java NIO还包括了新的文件/目录的操作: <code>Path</code>和<code>Files</code>。</p>
<ol>
<li>java.nio.channels 包：<ul>
<li><code>java.nio.channels.ServerSocketChannel</code></li>
<li><code>java.nio.channels.SocketChannel</code></li>
<li><code>java.nio.channels.FileChannel</code></li>
</ul>
</li>
<li><code>java.nio.channels.SocketChannel.Selector</code> 类</li>
<li>java.nio.Buff 接口：<ul>
<li><code>java.nio.ByteBuffer</code>: 最基本的字符buff, 从<code>Channel</code>(ServerSocketChannel, FileChannel等)读取出的内容放在<code>ByteBuffer</code>里, 或者通过<code>Channel.write</code>把ByteBuffer内容写入Channel;</li>
<li><code>java.nio.MappedByteBuffer</code>: FileChannel通道打开的文件映射到内存, 通过<code>MappedByteBuffer</code>来操作;</li>
</ul>
</li>
<li>java.nio.file 包：<ul>
<li><code>java.nio.file.Path</code>: Path的实例指代一个目录或文件</li>
<li><code>java.nio.file.Paths</code>: Path的工厂类, 用于获取Path实例</li>
<li><code>java.nio.file.Files</code>: 提供对<code>Path</code>的操作</li>
</ul>
</li>
</ol>
<p>▶ BIO和NIO的对比变化如下:</p>
<ul>
<li>(1) BIO流 vs NIO管道:<ul>
<li>Java BIO的各种流的读写都是阻塞操作。这意味着一个线程一旦调用了read(),write()方法但系统缓冲区没数据可读，那么该线程会进入阻塞状态（Blocked）。</li>
<li>NIO读写都是非阻塞的, NIO基于Channel(管道)和Buffer(缓冲区)进行操作：数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Channel可以是文件也可以是Socket；</li>
</ul>
</li>
<li>(2) NIO里新增了Selector，用于监听多个Channel的事件，当Channel产生可读写事件后, 用ByteBuffer读取数据。<br>Selector允许一个单一线程监听多个Channel输入。我们可以注册多个Channel到Selector上，然后然后用一个线程来挑出一个处于可读或者可写状态的Channel。Selector机制使得单线程管理过个Channel变得容易。</li>
<li>(3) NIO的提供了<code>Path</code>和<code>Files</code>来取代io包中的<code>File</code>, <code>Path</code>的实例指代一个目录或文件，<code>Files</code>则提供了对目录或文件的基本操作（exists, copy, move, delete）</li>
</ul>
<h3 id="NIO-ByteBuffer"><a href="#NIO-ByteBuffer" class="headerlink" title="NIO ByteBuffer"></a>NIO ByteBuffer</h3><p>ByteBuffer的属性、方法:</p>
<ul>
<li>属性 capacity &gt;= limit &gt;= position &gt;= mark<ul>
<li><code>capacity</code>: 指定数组大小, Buffer创建后就不可改变;</li>
<li><code>limit</code>: 最大可以读的到位置, 初始值等于capacity, 调用flip()方法后limit=position</li>
<li><code>position</code>: 当前的读写位置, 初始值0, 每次写入一个字节position+1, 每次读都是从position++位置读一个字节</li>
<li><code>mark</code>: 初始值-1, 备忘位置, 参加mark()/reset()方法</li>
</ul>
</li>
<li><code>ByteBuffer.allocate(int)</code>: 创建buff并初始化大小</li>
<li><code>put(byte)</code>, <code>put(byte[])</code>: 向buff存储数据</li>
<li><code>get()</code>, 返回position位置的一个byte</li>
<li><code>flip()</code>, 向Buffer写完数据开始读数据前要调用一次, 把position的值赋给limit, 然后position=0, 然后可以调用get()从position读出字节;</li>
<li><code>rewind()</code>, position=0, mark=-1, 不改变limit的值, 可以再读一遍[0~limit]的字节</li>
<li><code>mark()</code>: mark=position, 调用mark()来记录当前position</li>
<li><code>reset()</code>: position=mark, 调用reset()让position置为mark的值, 一次reset()对应一次mark()</li>
<li><code>clear()</code>: limit,position,mark置为初始值;</li>
<li><code>compact()</code>: 清除未读的数据, 将所有未读的数据拷贝到buffer起始处</li>
<li><code>equals()</code>: 比较两个buff剩余未读的字节数, 比较剩余的每一个字节</li>
<li><code>compareTo()</code>: ..</li>
</ul>
<blockquote>
<p>ByteBuffer内部是由一个数组实现的, 所以capacity理论最大值受<code>MAX_Integer</code>和<code>-Xmx</code>限制</p>
</blockquote>
<h3 id="NIO-Channel"><a href="#NIO-Channel" class="headerlink" title="NIO Channel"></a>NIO Channel</h3><p>@TODO</p>
<h3 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h3><p>@TODO</p>
<h3 id="Files-amp-Path"><a href="#Files-amp-Path" class="headerlink" title="Files &amp; Path"></a>Files &amp; Path</h3><p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioPathAndFiles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    Path path = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> pathExists =</span><br><span class="line">        Files.exists(path,</span><br><span class="line">            <span class="keyword">new</span> LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    Path path2 = Paths.get(<span class="string">"data/subdir"</span>);</span><br><span class="line">    Files.createDirectory(path2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"~/text.txt"</span>);</span><br><span class="line">    <span class="comment">//通过bufferedReader读取</span></span><br><span class="line">    BufferedReader bufferedReader = Files.newBufferedReader(path, StandardCharsets.UTF_8);<span class="comment">//文件编码</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String tempString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((tempString = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sb = sb.append(tempString);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    <span class="comment">//通过Files方法readAllLines</span></span><br><span class="line">    List&lt;String&gt; strings = Files.readAllLines(path);</span><br><span class="line">    strings.forEach(s -&gt; System.out.print(s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"/text"</span>);</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    Files.write(path, <span class="string">"Hello JDK7!"</span>.getBytes(), StandardOpenOption.APPEND);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO网络读写"><a href="#NIO网络读写" class="headerlink" title="NIO网络读写"></a>NIO网络读写</h2><p>API说明:</p>
<ul>
<li>服务端:<ul>
<li><code>ServerSocketChannel.open()</code> : 创建一个server socket channel实例, 相当于传统Socket的<code>ServerSocket</code></li>
<li><code>ServerSocketChannel.socket().bind(SocketAddress local)</code> : 绑定端口</li>
<li><code>ServerSocketChannel.configureBlocking(false)</code>: 把server socket channel设置为 <strong>非阻塞</strong> 的情况下, <code>accept()/read()/write()</code>会立刻返回;</li>
<li><code>ServerSocketChannel.accept()</code>: 阻塞, 并在有客户端成功连接时返回一个<code>SocketChannel</code>实例</li>
<li><code>ServerSocketChannel.register(Selector, EVENT)</code>: 为server channel注册监听的事件</li>
</ul>
</li>
<li>Selector:<ul>
<li><code>Selector.open()</code>: 创建一个selector实例</li>
<li><code>Selector.select()</code>: 开始监听并阻塞</li>
</ul>
</li>
<li>客户端:<ul>
<li><code>SocketChannel.configureBlocking(false)</code>: 把socket channel设置为非阻塞, 读写会立刻返回</li>
<li><code>SocketChannel.write(ByteBuffer)</code>: 写方法</li>
<li><code>SocketChannel.read(ByteBuffer)</code>: 读方法, 返回值是读取的字节数</li>
</ul>
</li>
</ul>
<p>用NIO API实现简单的Socket Server（用<code>Selector</code>实现多路复用, 用<code>Channel.configureBlocking(false)</code>设置为非阻塞I/O）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer echoBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ServerSocketChannel实例, 并绑定端口</span></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel 绑定 Selector, 并注册 Read</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">SelectionKey regKey = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">  <span class="comment">// 在这里阻塞</span></span><br><span class="line">  <span class="keyword">int</span> num = selector.select();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行到这里表示有事件产生</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">      SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">          <span class="comment">// 取出服务端SocketChannel</span></span><br><span class="line">          ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">          <span class="comment">// 接受请求, 返回客户端SocketChannel</span></span><br><span class="line">          SocketChannel sc = serverSocketChannel.accept();</span><br><span class="line">          <span class="comment">// 客户端SocketChannel设置NoneBlock</span></span><br><span class="line">          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 客户端SocketChannel也添加进</span></span><br><span class="line">          SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          <span class="comment">// 不要忘记删除</span></span><br><span class="line">          it.remove();</span><br><span class="line">          System.out.println(<span class="string">"Got connection from "</span> + sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class="line">          <span class="comment">// 取出可读的channel</span></span><br><span class="line">          SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理数据</span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              echoBuffer.clear();</span><br><span class="line">              <span class="keyword">int</span> r = sc.read(echoBuffer);</span><br><span class="line">              <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">              echoBuffer.flip();</span><br><span class="line">              sc.write(echoBuffer);</span><br><span class="line">              bytesEchoed += r;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">"Echoed "</span> + bytesEchoed + <span class="string">" from "</span> + sc);</span><br><span class="line">          it.remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结: NIO 的Socket 多路复用如下:</p>
<ul>
<li>创建服务端 socketChannel</li>
<li>创建 Selector</li>
<li>服务端 socketChannel 在 Selector上注册 ACCEPT事件</li>
<li>While循环<ul>
<li>selector.select() 阻塞, 如果 Selector上有事件发生, 退出阻塞</li>
<li>selector取出所有事件集合, 并遍历</li>
<li>如果有 ACCEPT 事件, 服务端 socketChannel去accept这个请求, 创建 客户端 socketChannel, 并在Selector上注册该 channel的 READ事件</li>
<li>如果有 READ 事件, 读对应的 客户端 socketChannel</li>
</ul>
</li>
</ul>
<h3 id="与传统Socket比较"><a href="#与传统Socket比较" class="headerlink" title="与传统Socket比较"></a>与传统Socket比较</h3><p>从上面的代码可以看到,</p>
<ul>
<li>传统的Java Socket(BIO, 阻塞IO), 等同于<code>java.net + java.io</code>, 使用的”Socket句柄”是<code>java.net.ServerSocket</code>(服务端socket)和<code>java.net.Socket</code>(客户端socket), 通过<code>Socket</code>获取InputStream/OutpubtStream进行读/写.</li>
<li>NIO Socket使用的”socket句柄”是<code>java.nio.channels</code>包下面的<code>ServerSocketChannel</code>和<code>SocketChannel</code>, SocketChannel的读写是通过<code>java.nio.ByteBuffer</code></li>
<li>前者IO方法是阻塞的, 后者IO方法是非阻塞 // ?</li>
</ul>
<h4 id="多线程-BIO缺陷"><a href="#多线程-BIO缺陷" class="headerlink" title="多线程-BIO缺陷"></a>多线程-BIO缺陷</h4><ul>
<li>线程的创建和销毁成本很高</li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千…</li>
<li>线程的切换成本是很高</li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，高并发下会使系统负载压力过大</li>
</ul>
<blockquote>
<p>BIO(阻塞IO)模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能阻塞等待。<br>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。<br>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。<br>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。</p>
</blockquote>
<p>以上参考: <a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a> @Ref</p>
<h2 id="NIO大文件读写"><a href="#NIO大文件读写" class="headerlink" title="NIO大文件读写"></a>NIO大文件读写</h2><p>大文件读写几种方案:</p>
<ul>
<li>传统IO读取方式:<ul>
<li>字节方式读取: FileInputStream VS BufferedInputStream</li>
<li>字符方式读取: BufferedReader</li>
</ul>
</li>
<li>NIO读取:<ul>
<li>FileChannel + ByteBuffer</li>
<li>MappedByteBuffer(内存映射)</li>
</ul>
</li>
</ul>
<p>测试结论参考:  <a href="https://blog.csdn.net/yiifaa/article/details/78141622" target="_blank" rel="noopener">JAVA NIO(六)：读取10G的文件其实很容易 - CSDN博客</a> @Ref</p>
<h3 id="传统NIO读取"><a href="#传统NIO读取" class="headerlink" title="传统NIO读取:"></a>传统NIO读取:</h3><p><code>java.io.RandomAccessFile</code>提供了文件随机读写,<br>下面的代码是使用nio中的<code>FileChannel</code>和<code>ByteBuffer</code> 从<code>RandomAccessFile</code>中读取:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel(); <span class="comment">// 1 获取channel</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((read = fileChannel.read(buffer)) &gt; <span class="number">0</span>) &#123; <span class="comment">// 2 读channel到ByteBuffer</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 3 开始读之前flip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲器读入数组, 省略处理过程...</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[read];</span><br><span class="line">    buffer.get(bytes); <span class="comment">// 4</span></span><br><span class="line">    buffer.clear();  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">fileChannel.close();</span><br><span class="line">randomAccessFile.close();</span><br></pre></td></tr></table></figure>

<h3 id="使用内存映射"><a href="#使用内存映射" class="headerlink" title="使用内存映射:"></a>使用内存映射:</h3><p>nio.FileChannel还提供了内存映射的方式读取文件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> length = randomAccessFile.length();</span><br><span class="line"><span class="comment">// 整个文件映射到内存:</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mappedByteBuffer.hasRemaining()) &#123;</span><br><span class="line">    mappedByteBuffer.get(); <span class="comment">//读取1字节</span></span><br><span class="line">    sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Close file &amp; channel</span></span><br></pre></td></tr></table></figure>

<h3 id="内存映射读取的优劣"><a href="#内存映射读取的优劣" class="headerlink" title="内存映射读取的优劣"></a>内存映射读取的优劣</h3><ul>
<li>内存映射方式的读取速度更快<ul>
<li>read()是系统调用, 首先将文件从硬盘拷贝到内核空间的一个缓冲区, 再将这些数据拷贝到用户空间, 实际上进行了两次数据拷贝.</li>
<li>map()也是系统调用, 但没有进行数据拷贝, 当缺页中断发生时, 直接将文件从硬盘拷贝到用户空间, 只进行了一次数据拷贝.</li>
</ul>
</li>
<li>MappedByteBuffer使用虚拟内存, 因此分配(map)的内存大小不受JVM的-Xmx参数限制, 但是也是有大小限制的;</li>
<li>如果当文件超出1.5G限制时, 可以通过position参数重新<code>map(mode, position, size)</code>文件后面的内容;</li>
<li>MappedByteBuffer在处理大文件时的确性能很高, 但也存在一些问题, 如内存占用/文件关闭不确定, 被其打开的文件只有在垃圾回收的才会被关闭, 而且这个时间点是不确定的。javadoc中也提到：”A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected.”</li>
</ul>
<p>参考: <a href="http://blog.jobbole.com/104880/" target="_blank" rel="noopener">深入浅出 MappedByteBuffer</a> v</p>
<h2 id="可以响应线程中断的Channel"><a href="#可以响应线程中断的Channel" class="headerlink" title="可以响应线程中断的Channel"></a>可以响应线程中断的Channel</h2><h2 id="本章参考"><a href="#本章参考" class="headerlink" title="本章参考"></a>本章参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a></li>
<li><a href="https://yq.aliyun.com/articles/2371" target="_blank" rel="noopener">理解Java NIO-博客-云栖社区-阿里云</a></li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>本章包括: 注解的定义和使用, JavaSE的标准注解和元注解.</p>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class annotation</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"topicControllerV2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Medhod annotation:</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/load"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TopicLoadResponse <span class="title">topicLoad</span><span class="params">(@RequestParam(value = <span class="string">"client_id"</span>)</span> String appId,</span></span><br><span class="line"><span class="function">    @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"topic_url"</span>)</span> String topicUrl,</span></span><br><span class="line"><span class="function">    @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"topic_source_id"</span>, required = <span class="keyword">false</span>)</span> String topicSourceId) </span>&#123;</span><br><span class="line">      <span class="comment">// ...method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个注解"><a href="#定义一个注解" class="headerlink" title="定义一个注解"></a>定义一个注解</h2><p>所有注解都隐式的继承自java.lang.annotation.Annotation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Controller:</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 使用元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;  <span class="comment">// 注解的定义: modifier @interface Annotation</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>; <span class="comment">// 注解的方法都是这种格式: Type elementName() default defaultVal;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestMapping</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>; <span class="comment">//</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// RequestMethod是枚举类型GET/POST..</span></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取带有特定注解(这里用@YourAnnotation注解为例)的类, 使用了org.reflections.Reflections工具类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reflections reflections = <span class="keyword">new</span> Reflections(<span class="string">"org.test"</span>);</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(YourAnnotation.class);</span><br></pre></td></tr></table></figure>

<h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><p>JavaSE在java.lang.annotation和javax.annotation包定义了大量注解, 其中4个是元注解, 用于定义一般注解 &amp;描述注解的行为属性.</p>
<ul>
<li>@Deprecated: 所有场合,包 &amp; 类 &amp; 方法 &amp; 属性</li>
<li>@SuppressWarnings: 类 &amp; 方法 &amp; 属性, 阻止某种警告信息, <code>@SuppressWarnings(value={&quot;unchecked&quot;,&quot;deprecation&quot;})</code></li>
<li>@Override: 只有方法</li>
<li>@Resources: ?</li>
<li>@Resource: 可以写在属性上, 和setter方法上, 默认按照名称进行装配</li>
<li>@PostConstruct 方法, 指明该方法在构造器之后立刻被调用</li>
<li>@PreDestory 方法, 指明该方法在类被销毁前调用</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ol>
<li>@Target:<ul>
<li><code>@Target(ElementType.TYPE)</code>     // 类, 接口, 枚举, 注解</li>
<li><code>@Target(ElementType.METHOD)</code>    //方法</li>
<li><code>@Target(ElementType.PARAMETER)</code> //方法参数</li>
<li><code>@Target(ElementType.FIELD)</code>     //字段</li>
</ul>
</li>
<li>@Retention:<ul>
<li><code>@Retention(RetentionPolicy.SOURCE)</code>   //注解仅存在于源码中, 在class字节码文件中不包含</li>
<li><code>@Retention(RetentionPolicy.CLASS)</code>    // 默认的保留策略, 注解会在class字节码文件中存在, 但运行时无法获得,</li>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>  // 注解会在class字节码文件中存在, 在运行时可以通过反射获取到</li>
</ul>
</li>
<li>@Document: 说明该注解将被包含在javadoc中</li>
<li>@Inherited: 一般在定义注解时使用, 说明这个子类可以继承父类中的这个注解</li>
</ol>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>java.security 包提供了消息摘要/消息签名等算法.</p>
<p>将长度不固定的消息（message)作为输入参数，运行特定的Hash函数，生成固定长度的输出，这个输出就是Hash，也称为这个消息的消息摘要（Message Digest）<br>消息签名可以看成是在密钥加密的基础上的消息摘要, 消息摘要和消息签名的作用:</p>
<ol>
<li>数据完整性检查</li>
<li>数据校验, 是否在传递过程中被篡改</li>
</ol>
<p>施工中…</p>
<h2 id="消息摘要-Message-Digest"><a href="#消息摘要-Message-Digest" class="headerlink" title="消息摘要(Message Digest)"></a>消息摘要(Message Digest)</h2><p>有如下几种消息摘要:</p>
<ul>
<li>MD5, 任何消息都压缩为16字节(128位)的摘要(指纹), 不推荐使用MD5的原因是?</li>
<li>SHA1(属于SHA一代), 任何消息都压缩为20字节(160位)的摘要, 所以SHA-1共有最多2^120个摘要;</li>
<li>SHA256(属于SHA二代), 32字节(256位);</li>
<li>SHA512</li>
<li>MAC(或者HMAC算法), 在散列基础上增加了密钥;</li>
<li>BCrypt: 根据Blowfish加密算法所设计的密码散列函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MD5 &amp; SHA</span></span><br><span class="line">MessageDigest alg = MessageDigest.getInstance(<span class="string">"SHA-1"</span>); <span class="comment">// 也可以是MD5</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>]; <span class="comment">// bytes存入要计算摘要的信息</span></span><br><span class="line"><span class="keyword">byte</span>[] hash = alg.digest(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HMAC</span></span><br><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"HmacMD5"</span>); <span class="comment">//初始化密钥生成器</span></span><br><span class="line">SecretKey secretKey = keyGenerator.generateKey(); <span class="comment">//产生密钥</span></span><br><span class="line"><span class="keyword">byte</span>[] encoded = secretKey.getEncoded(); <span class="comment">//获取密钥</span></span><br><span class="line">SecretKey restoreSecretKey = <span class="keyword">new</span> SecretKeySpec(encoded, <span class="string">"HmacMD5"</span>); <span class="comment">//还原密钥</span></span><br><span class="line">Mac mac = Mac.getInstance(restoreSecretKey.getAlgorithm()); <span class="comment">//实例化MAC</span></span><br><span class="line">mac.init(restoreSecretKey); <span class="comment">//初始化MAC</span></span><br><span class="line"><span class="keyword">byte</span>[] hmacmd5Bytes = mac.doFinal(src.getBytes()); <span class="comment">//执行摘要计算</span></span><br></pre></td></tr></table></figure>

<h2 id="消息签名-Message-Signature"><a href="#消息签名-Message-Signature" class="headerlink" title="消息签名(Message Signature)"></a>消息签名(Message Signature)</h2><ul>
<li>DSA(数字签名)/RSA(公钥/私钥), 例如DSA是利用了对数值巨大的数字进行因数分解的困难性.</li>
</ul>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul>
<li>DES</li>
<li>AES取代DES</li>
<li>Blowfish: 对称密钥区块加密算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***** DES *****/</span></span><br><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">keyGenerator.init(<span class="number">56</span>);<span class="comment">//设置长度</span></span><br><span class="line">SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = secretKey.getEncoded();</span><br><span class="line"></span><br><span class="line"><span class="comment">//key转换</span></span><br><span class="line">DESKeySpec desKeySpec = <span class="keyword">new</span> DESKeySpec(keyBytes);</span><br><span class="line">SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">SecretKey generateSecret = secretKeyFactory.generateSecret(desKeySpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DES/ECB/PKCS5Padding"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, generateSecret);</span><br><span class="line"><span class="keyword">byte</span>[] result = cipher.doFinal(src.getBytes());</span><br><span class="line">System.out.println(Hex.encodeHexString(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE,generateSecret);<span class="comment">//使用同一个key</span></span><br><span class="line">result = cipher.doFinal(result);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(result));</span><br></pre></td></tr></table></figure>

<h3 id="blowfish-amp-bcrypt"><a href="#blowfish-amp-bcrypt" class="headerlink" title="blowfish &amp; bcrypt"></a>blowfish &amp; bcrypt</h3><p><a href="https://stackoverflow.com/questions/5244950/encryption-with-blowfish-in-java" target="_blank" rel="noopener">Encryption with BlowFish in Java - Stack Overflow</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blowfish</span></span><br><span class="line">String Key = <span class="string">"Something"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] KeyData = Key.getBytes();</span><br><span class="line">SecretKeySpec KS = <span class="keyword">new</span> SecretKeySpec(KeyData, <span class="string">"Blowfish"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"Blowfish"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, KS);</span><br><span class="line"><span class="keyword">byte</span>[] encryptedData = cipher.doFinal(toEncryptString.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">Cipher cipher2 = Cipher.getInstance(<span class="string">"Blowfish"</span>);</span><br><span class="line">cipher2.init(Cipher.DECRYPT_MODE, KS);</span><br><span class="line"><span class="keyword">byte</span>[] decryptedData = cipher2.doFinal(encryptedData.getBytes());</span><br></pre></td></tr></table></figure>

<p>BCrypt是基于Blowfish加密算法所设计的密码散列函数, 代码<a href="http://www.mindrot.org/projects/jBCrypt/" target="_blank" rel="noopener">jBCrypt - strong password hashing for Java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bcrypt</span></span><br><span class="line">String password = <span class="string">"testpassword"</span>;</span><br><span class="line">String hashed = BCrypt.hashpw(password, BCrypt.gensalt(<span class="number">12</span>)); <span class="comment">// 2的12次方</span></span><br><span class="line"><span class="comment">// 返回的hashed 字符串包括盐</span></span><br><span class="line"><span class="comment">// $2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa</span></span><br><span class="line"><span class="comment">// 2a identifies the bcrypt algorithm version that was used.</span></span><br><span class="line"><span class="comment">// 10 is the cost factor; 2^10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">if</span> (BCrypt.checkpw(candidate, hashed)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul>
<li>RSA: @TODO</li>
</ul>
<h1 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h1><h2 id="实现一个Native方法"><a href="#实现一个Native方法" class="headerlink" title="实现一个Native方法:"></a>实现一个Native方法:</h2><ol>
<li><p>声明java native method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJNativeInterfaceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">input</span><span class="params">(String prompt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"./libJniTest.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CJNativeInterfaceDemo jniDemo = <span class="keyword">new</span> CJNativeInterfaceDemo();</span><br><span class="line">        jniDemo.input(<span class="string">"JNI Test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成c++头文件</p>
<ul>
<li><code>javac CJNativeInterfaceDemo.java</code> 生成.class文件</li>
<li><code>javah -jni CJNativeInterfaceDemo</code> 生成.h文件</li>
</ul>
</li>
<li><p>实现C++函数并编译成动态库<code>gcc  -I/usr/lib/jvm/java-7-openjdk-i386/include/ CJNativeInterfaceDemo.c -shared -o libJniTest.so</code></p>
</li>
</ol>
<h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><blockquote>
<p>“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。<br>闭包的概念: 可以把闭包简单理解成”定义在一个函数内部的函数体”，并且在内部函数体中能访问在外部函数中定义的变量</p>
</blockquote>
<p>lambda的语法为: <code>expression</code> = <code>(variable) -&gt; action</code>, 例如</p>
<ul>
<li><code>Runnable r = ()  -&gt; { log.info&quot;HelloWorld&quot;;}</code></li>
<li><code>int sum = (x,y) -&gt; x+y;</code></li>
<li>等号的右边即是一个lambda表达式</li>
</ul>
<h3 id="Lambda表达式要点总结"><a href="#Lambda表达式要点总结" class="headerlink" title="Lambda表达式要点总结"></a>Lambda表达式要点总结</h3><ul>
<li>lambda表达式可以用于以下几个情况:<ul>
<li>有单个抽象方法的类, 比如一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式;</li>
<li>使用了 @FunctionalInterface 注释的函数式接口，比如<code>java.util.function</code>包下面的Predicate、Function、Consumer 或 Supplier, BinaryOperator<ul>
<li>例如ArrayList的<code>forEach(Consumer&lt;E&gt; action)</code>方法的形参是Consumer类型, 可以接受一个lambda表达式做实参;</li>
<li>例如Collection的stream()返回一个Stream, Stream类的<code>filter()</code>, <code>map()</code> 的形参分别是Predicate和Function;</li>
</ul>
</li>
</ul>
</li>
<li>lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。例如<code>list.forEach(System.out::println)</code></li>
<li>Lambda表达式在Java中又称为闭包或匿名函数</li>
<li>Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样： <code>private static java.lang.Object lambda$0(java.lang.String);</code></li>
<li>lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</li>
<li>lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量，读取是可以的但不能修改。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int factor = 2;</span><br><span class="line">primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="创建匿名类"><a href="#创建匿名类" class="headerlink" title="创建匿名类"></a>创建匿名类</h3><p>例1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda写法:</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">  () -&gt; System.out.println(<span class="string">"Lambda thread"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>例2: 你们最讨厌的Comparator接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Score&gt; byName = <span class="keyword">new</span> Comparator&lt;Score&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Score o1, Score o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Collections.sort(list, byName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda写法:</span></span><br><span class="line">Comparator&lt;Score&gt; byName =</span><br><span class="line">  (Score o1, Score o2) -&gt; o1.getName().compareTo(o2.getName());</span><br></pre></td></tr></table></figure>

<h3 id="表达式迭代-forEach"><a href="#表达式迭代-forEach" class="headerlink" title="表达式迭代 forEach"></a>表达式迭代 forEach</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Default Method"</span>, <span class="string">"Stream API"</span>, <span class="string">"Date and Time API"</span>);</span><br><span class="line"></span><br><span class="line">list.forEach((e) -&gt; System.out.println(e));</span><br><span class="line"><span class="comment">// 或者使用Java 8的方法引用:</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="map-amp-reduce"><a href="#map-amp-reduce" class="headerlink" title="map() &amp; reduce()"></a>map() &amp; reduce()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为每个订单的价格加上12$的税, 并求和</span></span><br><span class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">double</span> bill = costBeforeTax.stream().map((cost) -&gt; cost + <span class="number">0.12</span>*cost).reduce((sum, cost) -&gt; sum + cost).get();</span><br><span class="line">System.out.println(<span class="string">"Total : "</span> + bill);</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>什么是函数式接口？ 简单说就是只拥有一个抽象方法的接口，如Runnable</p>
<h3 id="Function功能型函数式接口"><a href="#Function功能型函数式接口" class="headerlink" title="Function功能型函数式接口"></a>Function功能型函数式接口</h3><p>类 <code>java.util.function.Function&lt;T,R&gt;</code> 相当于仅含有一个方法的接口类, 这个方法接收一个参数T, 返回类型R.<br>在Java8中, 这种接口类可以用一个lambda表达式来表示.<br>Function只有一个方法apply, 该方法接收一个参数并返回一个值:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; func = x -&gt; x*2;</span><br><span class="line">Integer ii = func.apply(100);</span><br></pre></td></tr></table></figure></code></pre><p>除了👆上面这种形式, 在Java8中还增加了<code>::</code>, 称为”方法引用操作符”, <code>对象::方法</code>将返回一个函数接口（function interface），<br>我们可以使用它来引用类的方法. 例如:</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(num , <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyMath myMath = <span class="keyword">new</span> MyMath();</span><br><span class="line">Function&lt;Double, Double&gt; square = myMath::square; <span class="comment">// 声明一个函数式接口实例, 相当于把square方法抽取出来, 增加给这个实例</span></span><br><span class="line"><span class="keyword">double</span> ans = square.apply(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure></code></pre><blockquote>
<p>注意被<code>::</code>引用的方法需要符合“函数式接口” （一个输入参数一个返回值）</p>
</blockquote>
<h3 id="Predicate断言型函数式接口"><a href="#Predicate断言型函数式接口" class="headerlink" title="Predicate断言型函数式接口"></a>Predicate断言型函数式接口</h3><p>类 <code>java.util.function.Predicate&lt;T&gt;</code> 相当于一个”接收一个输入参数T, 返回boolean的lambda表达式”类型 :</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; pred = x -&gt; x&gt;5;</span><br><span class="line">boolean ret = pred.test();</span><br></pre></td></tr></table></figure></code></pre><p>使用<code>::</code>方法引用操作符:</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.addAll(Arrays.asList(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>));</span><br><span class="line">Predicate&lt;String&gt; pred = set::contains;</span><br><span class="line"><span class="keyword">boolean</span> exists = pred.test(<span class="string">"one"</span>);</span><br></pre></td></tr></table></figure></code></pre><p>Predicate.test()的更多例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List languages = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">filter(languages, (str)-&gt;str.startsWith(<span class="string">"J"</span>));</span><br><span class="line">filter(languages, (str)-&gt;str.endsWith(<span class="string">"a"</span>));</span><br><span class="line">filter(languages, (str)-&gt;<span class="keyword">true</span>);</span><br><span class="line">filter(languages, (str)-&gt;<span class="keyword">false</span>);</span><br><span class="line">filter(languages, (str)-&gt;str.length() &gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate predicate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String name: names)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(name)) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Predicate.and(), or(), xor()的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List languages = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(<span class="string">"J"</span>);</span><br><span class="line">Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == <span class="number">4</span>;</span><br><span class="line">languages.stream()</span><br><span class="line">    .filter(startsWithJ.and(fourLetterLong))</span><br><span class="line">    .forEach((n) -&gt; System.out.print(<span class="string">"nName, which starts with 'J' and four letter long is : "</span> + n));</span><br></pre></td></tr></table></figure>

<h3 id="Consumer消费型函数式接口"><a href="#Consumer消费型函数式接口" class="headerlink" title="Consumer消费型函数式接口"></a>Consumer消费型函数式接口</h3><p>@TODO</p>
<h3 id="Supplier供给型函数式接口"><a href="#Supplier供给型函数式接口" class="headerlink" title="Supplier供给型函数式接口"></a>Supplier供给型函数式接口</h3><p>@TODO</p>
<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：</p>
<ul>
<li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li>
<li>调用<code>Arrays.stream(T[] array)</code>方法</li>
<li>Map类容器无法直接用<code>stream()</code>, 但可以使用<code>map.entrySet().stream()</code>获得流</li>
</ul>
<p>常见的stream接口继承关系如图： ![](/images/Java Tutorials/java-stream-hierarchy.png)</p>
<h3 id="流-Stream-的特性"><a href="#流-Stream-的特性" class="headerlink" title="流(Stream)的特性"></a>流(Stream)的特性</h3><p>大部分情况下Stream是容器调用<code>Collection.stream()</code>方法得到的，但Stream和Collections有以下不同：</p>
<ul>
<li>无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li>为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>
<li>惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li>可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<h3 id="中间操作-amp-结束操作"><a href="#中间操作-amp-结束操作" class="headerlink" title="中间操作 &amp; 结束操作"></a>中间操作 &amp; 结束操作</h3><p>对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)，二者特点是：</p>
<ul>
<li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>
<li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>
</ul>
<p>下表汇总了Stream接口的部分常见方法:</p>
<table>
<thead>
<tr>
<th>operator</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>中间操作</td>
<td>concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td>结束操作</td>
<td>allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody></table>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter(): 函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足predicate条件元素的Stream。</p>
<blockquote>
<p>predicate 可以看成是返回boolean的lambda表达式</p>
</blockquote>
<p>下面例子中, filter方法接收一个<code>predicate</code>类型的参数:</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></code></pre><p>下面例子中, filter接收的参数是<code>list2::contains</code>， 被引用的方法（这里的contain方法）需符合“predicate”原型：</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求list1和list2的交集</span></span><br><span class="line">List&lt;T&gt; intersect = list1.stream()</span><br><span class="line">                     .filter(list2::contains)</span><br><span class="line">                     .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></code></pre><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p>distinct(): 函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的Stream。</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.distinct()</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></code></pre><h5 id="limit-amp-skip"><a href="#limit-amp-skip" class="headerlink" title="limit &amp; skip"></a>limit &amp; skip</h5><p>limit(n)/skip(n): limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素</p>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sorted(): 排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()</code>和<code>Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code>。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream().sorted((x, y) -&gt; x-y ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Map::Entry.comparingByValue和Comparator提供的方法:</span></span><br><span class="line">unsortedMap.entrySet().stream()</span><br><span class="line">.sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))</span><br></pre></td></tr></table></figure>

<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map(): 对当前Stream所有元素执行mapper操作, 返回新的Stream</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></code></pre><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p>flatMap(): “摊平”</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把List&lt;Int&gt; 摊平成 Int</span></span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">stream.flatMap(list -&gt; list.stream())</span><br><span class="line">    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure></code></pre><h4 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h4><p>结束操作包括collect, reduce, forEach等, 分别用于聚合和遍历.</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach是结束操作, 会立刻执行, 执行结束后Stream失效.<br>方法定义为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历。<br><em>通常我们在使用forEach时, 也会用来做合并操作</em>。</p>
<ul>
<li><p>使用Stream.forEach()迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在forEach中进行合并:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Combine map1 and map2</span></span><br><span class="line"><span class="comment">// Map.merge()用于相同k的合并</span></span><br><span class="line">Map&lt;String,Integer&gt; mergedMap = <span class="keyword">new</span> HashMap(map1);</span><br><span class="line">map2.forEach((k,v) -&gt; mergedMap.merge(k,v, Integer::Sum));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<br>Stream类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。<br>其原型为：<br><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></p>
<p><code>reduce()</code>最常用的场景就是从一组值中生成一个值，<code>reduce()</code>的方法定义有三种重写形式：</p>
<ol>
<li><p><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code>: 返回的类型<code>Optional</code>表示（一个）值的容器，使用它可以避免null值的麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">23</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">97</span>,<span class="number">32</span>&#125;;</span><br><span class="line"><span class="comment">// 求所有元素的和:</span></span><br><span class="line">Integer sum = Arrays.stream(array).reduce(<span class="number">0</span>, (a, b) -&gt; a+b);</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line">Integer sum = Arrays.stream(array).reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code>:<br>它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求单词长度之和</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">Integer lengthSum = stream.reduce(<span class="number">0</span>,　<span class="comment">// 初始值</span></span><br><span class="line">        (sum, str) -&gt; sum+str.length(), <span class="comment">// 累加器</span></span><br><span class="line">        (a, b) -&gt; a+b);　<span class="comment">// 部分和拼接器，并行执行时才会用到</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更多<code>reduce()</code>的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最小值， 有起始值</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接，有起始值, concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接，有起始值, 有filter操作, concat = "ace"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line">filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line">reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h5><p><code>Stream.collect()</code>方法和类<code>Collectors</code>一起使用, 常用于把一个Stream的结果收集进容器里,<br>考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p>
<ol>
<li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li>
<li>新元素如何添加到容器中？是List.add()还是Map.put()。</li>
<li>如果并行的进行规约，还需要告诉collect() 多个部分结果如何合并成一个。</li>
</ol>
<p>结合以上分析，collect()方法定义为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">                  BiConsumer&lt;R, R&gt; combiner);</span><br></pre></td></tr></table></figure>

<p>三个参数依次对应上述三条分析。不过每次调用collect()都要传入这三个参数太麻烦，收集器Collectors就是对这三个参数的简单封装,所以collect()的另一定义为<code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code>。</p>
<p><strong>一些例子:</strong></p>
<ul>
<li><p>将Stream规约成List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());<span class="comment">// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将Stream转换成List 或Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>
</li>
<li><p>Stream转换成map &amp; map排序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream转换成map:</span></span><br><span class="line"><span class="comment">// Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</span></span><br><span class="line">Map&lt;Integer, String&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// map排序 &amp; 取TopN:</span></span><br><span class="line"><span class="comment">// 对Entry的流进行排序, 然后生成有序的LinkedHashMap:</span></span><br><span class="line">Map&lt;String ,Long&gt; sortedMap = unsortedMap.entrySet().stream()</span><br><span class="line">    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))</span><br><span class="line">    .limit(topN)</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,</span><br><span class="line">                        (oldValue, newValue) -&gt; oldValue,</span><br><span class="line">                        LinkedHashMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并Map1, Map2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; mx = Stream.of(m1, m2)</span><br><span class="line">        .map(Map::entrySet)          <span class="comment">// converts each map into an entry set</span></span><br><span class="line">        .flatMap(Collection::stream) <span class="comment">// converts each set into an entry stream, then</span></span><br><span class="line">                                    <span class="comment">// "concatenates" it in place of the original set</span></span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.toMap(        <span class="comment">// collects into a map</span></span><br><span class="line">                Map.Entry::getKey,   <span class="comment">// where each entry is based</span></span><br><span class="line">                Map.Entry::getValue, <span class="comment">// on the entries in the stream</span></span><br><span class="line">                Integer::max         <span class="comment">// such that if a value already exist for</span></span><br><span class="line">                                    <span class="comment">// a given key, the max of the old</span></span><br><span class="line">                                    <span class="comment">// and new value is taken</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
</li>
<li><p>拼接字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">String mergedString = stream.filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">// (3)</span></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));<span class="comment">// (4)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Stream的底层实现"><a href="#Stream的底层实现" class="headerlink" title="Stream的底层实现"></a>Stream的底层实现</h3><ul>
<li>stream():  Stream只是一个接口，并没有操作的缺省实现。最主要的实现是ReferencePipeline,而它的一些具体实现又是由AbstractPipeline完成的</li>
<li>parrallelStream(): 底层使用的是ForkJoinPool, 比较适合使用计算密集型并且没有I/O的任务</li>
</ul>
<h2 id="新的Data-amp-Time"><a href="#新的Data-amp-Time" class="headerlink" title="新的Data &amp; Time"></a>新的Data &amp; Time</h2><p>@TODO</p>
<p>参考: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html" target="_blank" rel="noopener">Java 8 新特性概述</a> @Ref</p>
<h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><p>参考: <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html" target="_blank" rel="noopener">Java 9 新特性概述</a> @Ref</p>
<h1 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h1><p>参考: <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">Java 10 新特性介绍</a> @Ref</p>
<hr>
<h1 id="附录-JDK常用类"><a href="#附录-JDK常用类" class="headerlink" title="附录:JDK常用类"></a>附录:JDK常用类</h1><h2 id="java-lang📦继承关系图"><a href="#java-lang📦继承关系图" class="headerlink" title="java.lang📦继承关系图"></a>java.lang📦继承关系图</h2><p>![java.lang](/images/Java Tutorials/java_lang_package.gif)</p>
<h2 id="java-util📦继承关系图"><a href="#java-util📦继承关系图" class="headerlink" title="java.util📦继承关系图"></a>java.util📦继承关系图</h2><p>![java.util](/images/Java Tutorials/java_util_package.gif)</p>
<h1 id="附录-补码-反码"><a href="#附录-补码-反码" class="headerlink" title="附录:补码,反码"></a>附录:补码,反码</h1><blockquote>
<p>反码: 正数的反码是本身, 负数的反码=符号位不变, 其他位取反<br>补码: 正数的补码是本身, 负数的补码=符号位不变, 其他位取反, 再加1<br>看几组补码-真值: “1111 1111”=-1,  “1000 0010”=-126,  “1000 001”=-127, “1000 0000”=-128<br>不要用计算补码的方式去”算”-128的补码, 1000 0000 是定义的.</p>
</blockquote>
<p>参考:</p>
<ul>
<li>@Ref <a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></li>
<li>@Ref <a href="https://www.douban.com/note/223507364/" target="_blank" rel="noopener">原码、反码和补码</a></li>
</ul>
<h1 id="附录-运算符"><a href="#附录-运算符" class="headerlink" title="附录:运算符"></a>附录:运算符</h1><ul>
<li><code>/</code> 整数除法 15/2 = 7</li>
<li><code>%</code> 取余, 或者叫取模</li>
</ul>
<h2 id="C-里的函数"><a href="#C-里的函数" class="headerlink" title="C++里的函数"></a>C++里的函数</h2><ul>
<li><code>mod(a, b)</code>: 等同于<code>a%b</code>, 取余</li>
<li><code>floor(a)</code>: 返回小于等于a的整数, <code>floor(2.5)=2</code>, <code>floor(-3.5)=-3</code></li>
<li><code>ceil(a)</code>: 返回大于等于a的整数, <code>ceil(2.5)=3</code></li>
</ul>
<h2 id="位运算符-java"><a href="#位运算符-java" class="headerlink" title="位运算符(java)"></a>位运算符(java)</h2><ul>
<li><code>&amp;</code> 符号位</li>
<li><code>|</code> 符号位</li>
<li><code>~</code> 符号位</li>
<li><code>^</code> 符号位</li>
<li><code>&lt;&lt;</code> 左移: 丢弃最高位(符号位同样丢弃), 0补最低位. 当byte和short左移时, 自动升级为int型.<ul>
<li>数学意义: 左移n位相等于乘以2^n</li>
</ul>
</li>
<li><code>&gt;&gt;</code> 右移: 高位补充符号位, 正数右移补充0, 负数右移补充1, 当byte和short右移时, 自动升级为int型.<ul>
<li>数学意义:  右移n位相当于除以2^n</li>
</ul>
</li>
<li><code>&gt;&gt;&gt;</code> 无符号右移: 无论正负, 高位补充0<ul>
<li>无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义</li>
</ul>
</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java核心技术 卷 I 第九版》</a> @Ref</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程语言快速入门/" rel="tag"># 编程语言快速入门</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/NIO/" rel="tag"># NIO</a>
          
            <a href="/tags/Java基础/" rel="tag"># Java基础</a>
          
            <a href="/tags/异常/" rel="tag"># 异常</a>
          
            <a href="/tags/泛型/" rel="tag"># 泛型</a>
          
            <a href="/tags/反射/" rel="tag"># 反射</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/数据结构与算法/Algorithm-算法设计/" rel="next" title="笔记：算法设计">
                <i class="fa fa-chevron-left"></i> 笔记：算法设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/未分类技术笔记/正则表达式-RegExp/" rel="prev" title="正则表达式">
                正则表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/hexo_avatar.png"
                alt="whatsrtos" />
            
              <p class="site-author-name" itemprop="name">whatsrtos</p>
              <p class="site-description motion-element" itemprop="description"><s>代码朋克</s></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">252</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点数的比较"><span class="nav-text">浮点数的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BitSet"><span class="nav-text">BitSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装器"><span class="nav-text">包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包装器API"><span class="nav-text">包装器API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装箱拆箱的实现"><span class="nav-text">装箱拆箱的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慎用Long-equals"><span class="nav-text">慎用Long.equals()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigInteger-BigDecimal"><span class="nav-text">BigInteger, BigDecimal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays"><span class="nav-text">Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-Arrays"><span class="nav-text">java.util.Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-lang-reflect-Array"><span class="nav-text">Java.lang.reflect.Array</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#左右结合"><span class="nav-text">左右结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位移运算"><span class="nav-text">位移运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-Math"><span class="nav-text">java.lang.Math</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制流程和语句"><span class="nav-text">控制流程和语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法"><span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Swap"><span class="nav-text">Swap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变参函数"><span class="nav-text">变参函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object的一些默认方法"><span class="nav-text">Object的一些默认方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equals方法"><span class="nav-text">equals方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode方法"><span class="nav-text">hashCode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较equals和hashCode"><span class="nav-text">比较equals和hashCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clone"><span class="nav-text">clone</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cloneable接口"><span class="nav-text">Cloneable接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造和销毁"><span class="nav-text">构造和销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承和构造顺序"><span class="nav-text">继承和构造顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认构造方法"><span class="nav-text">默认构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销毁"><span class="nav-text">销毁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this关键字"><span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制权限"><span class="nav-text">访问控制权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类和接口"><span class="nav-text">抽象类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java和C-实现多态的对比"><span class="nav-text">Java和C++实现多态的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态-polymorphism"><span class="nav-text">多态(polymorphism)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-static-关键字"><span class="nav-text">final, static 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾C-的const"><span class="nav-text">回顾C++的const</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一般内部类"><span class="nav-text">一般内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部类如何访问内部类"><span class="nav-text">外部类如何访问内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他类如何访问内部类"><span class="nav-text">其他类如何访问内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类的必要性"><span class="nav-text">内部类的必要性?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部内部类-amp-匿名类"><span class="nav-text">局部内部类 &amp; 匿名类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套内部类"><span class="nav-text">嵌套内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String一些方法和实现"><span class="nav-text">String一些方法和实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-不可被继承"><span class="nav-text">String 不可被继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较StringBuffer"><span class="nav-text">比较StringBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-char-byte的互转"><span class="nav-text">String,char,byte的互转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用类"><span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String-amp-StringBuffer"><span class="nav-text">String &amp; StringBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装类"><span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math类"><span class="nav-text">Math类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期类"><span class="nav-text">日期类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#反射和RTTI"><span class="nav-text">反射和RTTI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class类和Class对象"><span class="nav-text">Class类和Class对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用反射创建类"><span class="nav-text">用反射创建类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用反射API分析类"><span class="nav-text">使用反射API分析类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class类的方法列表"><span class="nav-text">Class类的方法列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和反射"><span class="nav-text">数组和反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用反射创建数组"><span class="nav-text">用反射创建数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用反射分析数组"><span class="nav-text">用反射分析数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-Array类的方法列表"><span class="nav-text">reflect.Array类的方法列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全的类型转换"><span class="nav-text">安全的类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常处理"><span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-amp-Exception"><span class="nav-text">Error &amp; Exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承关系"><span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch"><span class="nav-text">try-catch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try语句中的return"><span class="nav-text">try语句中的return</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getMessage-vs-toString"><span class="nav-text">getMessage vs toString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见异常及解释"><span class="nav-text">常见异常及解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断言"><span class="nav-text">断言</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合类继承关系"><span class="nav-text">集合类继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection接口"><span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList"><span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#扩容"><span class="nav-text">扩容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList"><span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector"><span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stack"><span class="nav-text">Stack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-amp-Deque"><span class="nav-text">Queue &amp; Deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue接口"><span class="nav-text">Queue接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque接口"><span class="nav-text">Deque接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现类"><span class="nav-text">实现类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet"><span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashSet"><span class="nav-text">LinkedHashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet"><span class="nav-text">TreeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator-迭代器"><span class="nav-text">Iterator: 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-iterate-collection"><span class="nav-text">How to iterate collection:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合泛型算法"><span class="nav-text">集合泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序操作（主要针对List接口相关）"><span class="nav-text">排序操作（主要针对List接口相关）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找和替换（主要针对Collection接口相关）"><span class="nav-text">查找和替换（主要针对Collection接口相关）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map接口"><span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现"><span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容-1"><span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么是0-75"><span class="nav-text">为什么是0.75?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set视图"><span class="nav-text">Set视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashMap-amp-HashMap代码比较"><span class="nav-text">LinkedHashMap &amp; HashMap代码比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么采用红黑树"><span class="nav-text">为什么采用红黑树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable"><span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap"><span class="nav-text">WeakHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于Map-Entry"><span class="nav-text">关于Map.Entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-iterate-map"><span class="nav-text">How to iterate map</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型类和泛型方法"><span class="nav-text">泛型类和泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型类"><span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型方法"><span class="nav-text">泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型的类型限定"><span class="nav-text">泛型的类型限定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型擦除"><span class="nav-text">类型擦除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对类型查询的影响"><span class="nav-text">对类型查询的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-instanceof"><span class="nav-text">1. instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-getClass"><span class="nav-text">2. getClass()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不能创建泛型类数组"><span class="nav-text">不能创建泛型类数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不能实例化泛型"><span class="nav-text">不能实例化泛型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通配符-lt-gt"><span class="nav-text">通配符&lt;?&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无限定通配符"><span class="nav-text">无限定通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上界通配符"><span class="nav-text">上界通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下界通配符"><span class="nav-text">下界通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限定符和泛型的一些问题…"><span class="nav-text">限定符和泛型的一些问题…</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代理"><span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK动态代理"><span class="nav-text">JDK动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CGLIB代理"><span class="nav-text">CGLIB代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP与代理"><span class="nav-text">Spring AOP与代理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O"><span class="nav-text">I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流"><span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节点流-amp-过滤流"><span class="nav-text">节点流 &amp; 过滤流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流-amp-字符流"><span class="nav-text">字节流 &amp; 字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字节流-常用类和方法"><span class="nav-text">字节流 常用类和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符流-常用类和方法"><span class="nav-text">字符流 常用类和方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件"><span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-io-File"><span class="nav-text">java.io.File</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-io-RandomAccessFile"><span class="nav-text">java.io.RandomAccessFile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-with-resources"><span class="nav-text">try-with-resources</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API-Example"><span class="nav-text">API Example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流-API-Example"><span class="nav-text">字节流 API Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符流-API-Example"><span class="nav-text">字符流 API Example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化"><span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程6种状态"><span class="nav-text">线程6种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制API"><span class="nav-text">线程控制API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#start"><span class="nav-text">start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupt"><span class="nav-text">interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-text">join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep和wait的区别"><span class="nav-text">sleep和wait的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何终止线程"><span class="nav-text">如何终止线程?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唤醒线程"><span class="nav-text">唤醒线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#被弃用的方法"><span class="nav-text">被弃用的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yield"><span class="nav-text">yield</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop"><span class="nav-text">stop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#suspend-amp-resume"><span class="nav-text">suspend &amp; resume</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程属性"><span class="nav-text">线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级"><span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon"><span class="nav-text">daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理器"><span class="nav-text">异常处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#J-U-C"><span class="nav-text">J.U.C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock和条件对象"><span class="nav-text">ReentrantLock和条件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入锁-ReentrantLock"><span class="nav-text">可重入锁: ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#锁的实现"><span class="nav-text">锁的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lock"><span class="nav-text">lock()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unlock"><span class="nav-text">unlock()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测锁与超时"><span class="nav-text">测锁与超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写锁"><span class="nav-text">读写锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件对象-Condition"><span class="nav-text">条件对象: Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#条件对象的实现"><span class="nav-text">条件对象的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized和对象锁"><span class="nav-text">Synchronized和对象锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized"><span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁的升级"><span class="nav-text">锁的升级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无锁"><span class="nav-text">无锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#偏向锁"><span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#轻量级锁-自旋"><span class="nav-text">轻量级锁(自旋)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重量级锁"><span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁消除"><span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Monitor对象"><span class="nav-text">Monitor对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-wait-和notify"><span class="nav-text">Object.wait()和notify()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较ReentrantLock和synchronized"><span class="nav-text">比较ReentrantLock和synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile关键字"><span class="nav-text">Volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile不适用的情况"><span class="nav-text">volatile不适用的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile适用的情况"><span class="nav-text">volatile适用的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe提供的CAS"><span class="nav-text">Unsafe提供的CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS的ABA问题"><span class="nav-text">CAS的ABA问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Atomic"><span class="nav-text">Atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决ABA问题"><span class="nav-text">解决ABA问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-2"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InheritableThreadLocal"><span class="nav-text">InheritableThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-3"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor线程池"><span class="nav-text">Executor线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的实现"><span class="nav-text">线程池的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作线程"><span class="nav-text">工作线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化线程池"><span class="nav-text">优化线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future"><span class="nav-text">Future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ListenableFuture-Guava"><span class="nav-text">ListenableFuture(Guava)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletableFuture-Java8"><span class="nav-text">CompletableFuture(Java8)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fork-Join框架"><span class="nav-text">Fork/Join框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全的集合"><span class="nav-text">线程安全的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的队列"><span class="nav-text">线程安全的队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞队列"><span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedBlockingDeque"><span class="nav-text">LinkedBlockingDeque</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SynchronousQueue"><span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DelayQueue"><span class="nav-text">DelayQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-text">PriorityBlockingQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞队列"><span class="nav-text">非阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-text">ConcurrentLinkedQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentLinkedDeque"><span class="nav-text">ConcurrentLinkedDeque</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-1"><span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentSkipListSet"><span class="nav-text">ConcurrentSkipListSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentSkipListMap"><span class="nav-text">ConcurrentSkipListMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deprecated-Vector-amp-HashTable"><span class="nav-text">Deprecated: Vector &amp; HashTable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数器CountDownLatch"><span class="nav-text">计数器CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量Semaphore"><span class="nav-text">信号量Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间交换数据的Exchanger"><span class="nav-text">线程间交换数据的Exchanger</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Server"><span class="nav-text">Server</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client"><span class="nav-text">Client</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#半关闭"><span class="nav-text">半关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可中断套接字"><span class="nav-text">可中断套接字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO"><span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从BIO到NIO"><span class="nav-text">从BIO到NIO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO包介绍"><span class="nav-text">NIO包介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-ByteBuffer"><span class="nav-text">NIO ByteBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-Channel"><span class="nav-text">NIO Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-Selector"><span class="nav-text">NIO Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Files-amp-Path"><span class="nav-text">Files &amp; Path</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO网络读写"><span class="nav-text">NIO网络读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与传统Socket比较"><span class="nav-text">与传统Socket比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程-BIO缺陷"><span class="nav-text">多线程-BIO缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO大文件读写"><span class="nav-text">NIO大文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统NIO读取"><span class="nav-text">传统NIO读取:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用内存映射"><span class="nav-text">使用内存映射:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射读取的优劣"><span class="nav-text">内存映射读取的优劣</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以响应线程中断的Channel"><span class="nav-text">可以响应线程中断的Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章参考"><span class="nav-text">本章参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注解"><span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用注解"><span class="nav-text">使用注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个注解"><span class="nav-text">定义一个注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准注解"><span class="nav-text">标准注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元注解"><span class="nav-text">元注解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安全"><span class="nav-text">安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#消息摘要-Message-Digest"><span class="nav-text">消息摘要(Message Digest)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息签名-Message-Signature"><span class="nav-text">消息签名(Message Signature)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对称加密"><span class="nav-text">对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#blowfish-amp-bcrypt"><span class="nav-text">blowfish &amp; bcrypt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非对称加密"><span class="nav-text">非对称加密</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Native-Method"><span class="nav-text">Native Method</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个Native方法"><span class="nav-text">实现一个Native方法:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-8"><span class="nav-text">Java 8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda"><span class="nav-text">Lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda表达式要点总结"><span class="nav-text">Lambda表达式要点总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建匿名类"><span class="nav-text">创建匿名类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式迭代-forEach"><span class="nav-text">表达式迭代 forEach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-amp-reduce"><span class="nav-text">map() &amp; reduce()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式接口"><span class="nav-text">函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Function功能型函数式接口"><span class="nav-text">Function功能型函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Predicate断言型函数式接口"><span class="nav-text">Predicate断言型函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer消费型函数式接口"><span class="nav-text">Consumer消费型函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Supplier供给型函数式接口"><span class="nav-text">Supplier供给型函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-API"><span class="nav-text">Stream API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流-Stream-的特性"><span class="nav-text">流(Stream)的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中间操作-amp-结束操作"><span class="nav-text">中间操作 &amp; 结束操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中间操作"><span class="nav-text">中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#filter"><span class="nav-text">filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#distinct"><span class="nav-text">distinct</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#limit-amp-skip"><span class="nav-text">limit &amp; skip</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort"><span class="nav-text">sort</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map"><span class="nav-text">map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#flatMap"><span class="nav-text">flatMap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结束操作"><span class="nav-text">结束操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forEach"><span class="nav-text">forEach</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reduce"><span class="nav-text">reduce()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#collect"><span class="nav-text">collect()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream的底层实现"><span class="nav-text">Stream的底层实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新的Data-amp-Time"><span class="nav-text">新的Data &amp; Time</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-9"><span class="nav-text">Java 9</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-10"><span class="nav-text">Java 10</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录-JDK常用类"><span class="nav-text">附录:JDK常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang📦继承关系图"><span class="nav-text">java.lang📦继承关系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-util📦继承关系图"><span class="nav-text">java.util📦继承关系图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录-补码-反码"><span class="nav-text">附录:补码,反码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录-运算符"><span class="nav-text">附录:运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-里的函数"><span class="nav-text">C++里的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算符-java"><span class="nav-text">位运算符(java)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whatsrtos</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://whatsrtos.github.io/30MinsTutorial/Java Tutorials/';
          this.page.identifier = '30MinsTutorial/Java Tutorials/';
          this.page.title = 'Java Tutorials';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
