<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="编程语言快速入门,C/C++,宏,指针," />










<meta name="description" content="—Part 1: ANSI C—基本数据类型 C/C++作为一种强类型语言, 一个变量被使用前必须被定义. 在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B) long(4B), float(4B), double(8B), long long(8B); 在64位系统中基本类型的长度(字节): char(1B), short(2B),">
<meta name="keywords" content="编程语言快速入门,C&#x2F;C++,宏,指针">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++ Tutorials">
<meta property="og:url" content="https://whatsrtos.github.io/30MinsTutorial/C_C++ Tutorials/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="—Part 1: ANSI C—基本数据类型 C/C++作为一种强类型语言, 一个变量被使用前必须被定义. 在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B) long(4B), float(4B), double(8B), long long(8B); 在64位系统中基本类型的长度(字节): char(1B), short(2B),">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://whatsrtos.github.io/images/C_C++%20Tutorials/cpp_vm_model.png">
<meta property="og:updated_time" content="2020-10-19T12:00:19.920Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C&#x2F;C++ Tutorials">
<meta name="twitter:description" content="—Part 1: ANSI C—基本数据类型 C/C++作为一种强类型语言, 一个变量被使用前必须被定义. 在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B) long(4B), float(4B), double(8B), long long(8B); 在64位系统中基本类型的长度(字节): char(1B), short(2B),">
<meta name="twitter:image" content="https://whatsrtos.github.io/images/C_C++%20Tutorials/cpp_vm_model.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://whatsrtos.github.io/30MinsTutorial/C_C++ Tutorials/"/>





  <title>C/C++ Tutorials | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://whatsrtos.github.io/30MinsTutorial/C_C++ Tutorials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whatsrtos">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C/C++ Tutorials</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,986
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="—Part-1-ANSI-C—"><a href="#—Part-1-ANSI-C—" class="headerlink" title="—Part 1: ANSI C—"></a>—Part 1: ANSI C—</h1><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li>C/C++作为一种强类型语言, 一个变量被使用前必须被定义.</li>
<li>在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B) long(4B), float(4B), double(8B), long long(8B);</li>
<li>在64位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(<strong>8B</strong>) long(<strong>8B</strong>), float(4B), double(8B), long long(8B);</li>
<li>long 和 int 范围是[-2^31,2^31)，即-2147483648~2147483647。</li>
<li>而unsigned范围是[0,2^32)，即0~4294967295。也就是说，常规的32位整数只能够处理40亿以下的数。</li>
<li>相比于C++98标准，C++11整型的最大改变就是多了long long。</li>
<li><p>long long整型有两种：long long和unsigned long long。在C++11中，标准要求long long整型可以在不同平台上有不同的长度，但至少有64位。我们在写常数字面量时，可以使用LL后缀（或是ll）标识一个long long类型的字面量，而ULL（或ull、Ull、uLL）表示一个unsigned long long类型的字面量。比如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli = <span class="number">-9000000000000000000L</span>L;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulli = <span class="number">-9000000000000000000U</span>LL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比如对于有符号的，下面的类型是等价的：long long、signed long long、long long int、signed long long int；而unsigned long long和unsigned long long int也是等价的。</p>
</li>
<li>同其他的整型一样，要了解平台上<code>long long</code>大小的方法就是查看<code>&lt;climits&gt;</code>（或<code>&lt;limits.h&gt;</code>中的宏）。<br>与long long整型相关的一共有3个：LLONG_MIN、LLONG_MAX和ULLONG_MIN，它们分别代表了平台上最小的long long值、最大的long long值，以及最大的unsigned long long值。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_min = LLONG_MIN;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_max = LLONG_MAX;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_max = ULLONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min of long long: %lld\n"</span>, ll_min); <span class="comment">// min of long long: -9223372036854775808</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max of long long: %lld\n"</span>, ll_max); <span class="comment">// max of long long: 9223372036854775807</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max of unsigned long long: %llu\n"</span>, ull_max);   <span class="comment">// max of unsigned long long: 18446744073709551615</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项:g++ -std=c++11 2-2-1.cpp</span></span><br><span class="line"><span class="comment">// 在代码清单中，将以上3个宏打印了出来，对于printf函数来说，</span></span><br><span class="line"><span class="comment">// 输出有符号的long long类型变量可以用符号%lld，</span></span><br><span class="line"><span class="comment">// 无符号的unsigned long long则可以采用%llu。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>@Ref: <a href="https://blog.csdn.net/dos5gw/article/details/6448048" target="_blank" rel="noopener">结构体对齐, 位域, 柔性数组 - DOS5GW的专栏 - CSDN博客</a></p>
</blockquote>
<h2 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h2><ul>
<li><a href="https://blog.csdn.net/dos5gw/article/details/6340996" target="_blank" rel="noopener">大端(Big Endian)与小端(Little Endian)详解 - DOS5GW的专栏 - CSDN博客</a></li>
</ul>
<p>大端/小端存储, big endian/little endian:</p>
<ul>
<li>MSB高位,LSB地位,比如自然数字0x1A39,1A是MSB,39是LSB,判断大小端存储,可根据数据在内存中存储的地址是以MSB/LSB为地址,</li>
<li>比如一个int,其LSB作为此数据的首地址(内存中的低地址),则为小端存储;<ul>
<li>–大端: LSB在高地址,MSB在低地址;</li>
<li>–小端: MSB在高地址,LSB在低地址;</li>
</ul>
</li>
<li>比如书写顺序0x1122,11是高字节MSB,22是低字节LSB.<ul>
<li>大端存储:高地址22,低地址11;</li>
<li>小端存储:高地址11,低地址22;</li>
</ul>
</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>位与<code>&amp;</code>, 位或<code>|</code>, 异或<code>^</code>, 取反<code>~</code>, 位左移<code>&lt;&lt;</code> , 位右移<code>&gt;&gt;</code></li>
<li>sizeof是C语言的一种单目操作符，如C语言的其他操作符++、–等。它并不是函数。sizeof操作符以字节形式给出了其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数的存储大小由操作数的类型决定。　<ul>
<li>当操作数具有数组类型时，其结果是数组的总字节数</li>
<li>联合类型操作数的sizeof是其最大字节成员的字节数</li>
<li>sizeof的优先级为2级，比乘除等3级运算符优先级高</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/30526656" target="_blank" rel="noopener">编程语言中，取余和取模的区别到底是什么？ - 知乎</a></p>
<blockquote>
<p>当除数和被除数不同符号时:<br>取余向0方向舍弃小数位, 取模向负无穷方向舍弃小数位<br>比如4/(-3)约等于-1.3,<br>取余: 4 rem 3 = -1<br>取模: 4 mod 3 = -2</p>
</blockquote>
</blockquote>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>格式化输出printf是一个变参函数, 原型为<code>int printf(char *format,...)</code> ,<br>C语言用宏来处理这些可变参数, 根据参数入栈的特点从最靠近第一个可变参数的固定参数开始, 依次获取每个可变参数的地址.  例如<code>printf (&quot;Decimals: %d %ld\n&quot;, 1977, 650000L);</code><br>需要注意的是格式要跟变量的长度对应, 比如long long要使用<code>%ll</code>, int类型不能使用<code>%c</code>格式.</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组-amp-指针的不同"><a href="#数组-amp-指针的不同" class="headerlink" title="数组 &amp; 指针的不同"></a>数组 &amp; 指针的不同</h2><p>比如有:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化的不同<ul>
<li>在第一句中,以<code>&amp;s[0]</code>开始的连续6个字节内存分别被赋值为: ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘/0’</li>
<li>第二句中,p被初始化为程序data段的某个地址,该地址是字符串”china”的首地址</li>
</ul>
</li>
<li>sizeof的不同: <code>sizeof(s)</code>应为6, 而sizeof(p)应为一个”指针”的大小.</li>
<li><code>&amp;</code>取地址操作符的不同:<ul>
<li><code>&amp;s</code>的类型为pointer to array of 6 chars.</li>
<li><code>&amp;p</code>的类型为pointer to pointer to char.</li>
</ul>
</li>
</ol>
<h2 id="数组退化"><a href="#数组退化" class="headerlink" title="数组退化"></a>数组退化</h2><p>数组类型也是一种数据类型, 其本质功能和其他类型无异:定义该类型的数据所占内存空间的大小以及可以对该类型数据进行的操作(及如何操作).<br>数组在某些情况下, “数组类型的变量”会退化成指针类型,<br>这时候无法再获取数组长度, 会影响<code>sizeof</code>操作符的结果,</p>
<h3 id="数组什么时候会”退化”"><a href="#数组什么时候会”退化”" class="headerlink" title="数组什么时候会”退化”"></a>数组什么时候会”退化”</h3><p>数组在除了3种情况外, 其他时候都要”退化”成指向首元素的指针. 这3中例外情况是:<br>比如有数组 <code>char s[10] = &quot;hello&quot;;</code></p>
<ol>
<li><code>sizeof(s)</code></li>
<li><code>&amp;s</code></li>
<li>用<code>char s[10]</code>作为左值创建”字符串”, <code>s</code>仍然是数组类型</li>
</ol>
<h2 id="静态数组索引-C99"><a href="#静态数组索引-C99" class="headerlink" title="静态数组索引(C99)"></a>静态数组索引(C99)</h2><p>下面的代码向编译器保证，你传递给f 的指针指向一个具有至少10个int 类型元素的数组的首个元素。我猜这也是为了优化；例如，编译器将会假定a 非空。编译器还会在你尝试要将一个可以被静态确定为null的指针传入或是一个数组太小的时候发出警告。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个不可修改的数组，这和说明符<code>int * const a</code>.作用是一样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">const</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柔性数组-flexible-array"><a href="#柔性数组-flexible-array" class="headerlink" title="柔性数组(flexible array)"></a>柔性数组(flexible array)</h2><p>C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。<br>柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。<br>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。<br>柔性数组到底如何使用呢？看下面例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure>
<p>有些编译器会报错无法编译可以改成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[];</span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以定义一个可变长的结构体，用 <code>sizeof(type_a)</code>得到的只有 4，就是<code>sizeof(i)=sizeof(int)</code>。<br>那个 0 个元素的数组没有占用空间，而后我们可以进行变长操作了。通过如下表达式给结构体分配内存：</p>
<p><code>type_a *p = (type_a*)malloc(sizeof(type_a) + 100*sizeof(int));</code></p>
<p>这样我们为结构体指针 p 分配了一块内存(该内存块大小远大于结构的大小)。用 <code>p-&gt;item[n]</code>就能简单地访问可变长元素。<br>但是这时候我们再用 <code>sizeof（*p）</code>测试结构体的大小，发现仍然为 4。<br>已经确定不包含柔性数组的内存大小。只是说在使用柔性数组时需要把它当作结构体的一个成员，仅此而已。再说白点，柔性数组其实与结构体没什么关系，算不得结构体的正式成员。</p>
<p>需要说明的是：C89不支持这种东西，C99把它作为一种特例加入了标准。但是，C99<br>所支持的是 incomplete type，而不是 zero array，形同 <code>int item[0];</code>这种形式是非法的，C99支<br>持的形式是形同 <code>int item[];</code>只不过有些编译器把 <code>int item[0];</code>作为非标准扩展来支持，而且在<br>C99发布之前已经有了这种非标准扩展了，C99发布之后，有些编译器把两者合而为一了。<br>当然，上面既然用 malloc函数分配了内存，肯定就需要用 free函数来释放内存：<code>free(p);</code></p>
<p>参考:</p>
<ul>
<li>结构体对齐 <a href="http://blog.csdn.net/yinkaizhong/archive/2009/12/06/4951288.aspx" target="_blank" rel="noopener">http://blog.csdn.net/yinkaizhong/archive/2009/12/06/4951288.aspx</a> @Ref</li>
<li>柔性数组 <a href="http://blog.csdn.net/yiruirui0507/archive/2010/07/22/5756328.aspx" target="_blank" rel="noopener">http://blog.csdn.net/yiruirui0507/archive/2010/07/22/5756328.aspx</a> @Ref</li>
</ul>
<h1 id="指针-amp-引用"><a href="#指针-amp-引用" class="headerlink" title="指针&amp;引用"></a>指针&amp;引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>函数指针: <code>typedef void (*pf)(int, int);</code></li>
<li><code>restrict</code>关键词是一个限定词，可以被用在指针上。它向编译器保证，在这个指针的生命周期内，任何通过该指针访问的内存，都只能被这个指针改变。比如，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">restrict</span> x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">    (*y)++;</span><br><span class="line">    <span class="keyword">int</span> z = *x;</span><br><span class="line">    (*y)--;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>!=&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="keyword">if</span>(!other.m_data) m_data=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_data)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_data,other.m_data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回this的解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>在C99之前，你只能按顺序初始化一个结构体。在C99中你可以这样做</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo = &#123;.z = <span class="number">3</span>, .x = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码首先初始化了foo.z,然后初始化了foo.x. foo.y 没有被初始化，所以被置为0。<br>这一语法同样可以被用在数组中。以下三行代码是等价的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体字节对齐"><a href="#结构体字节对齐" class="headerlink" title="结构体字节对齐"></a>结构体字节对齐</h2><ol>
<li><p>一般结构体的<code>sizeof</code>, gcc和cl编译器有所不同,以cl为例,</p>
<ul>
<li>cl编译器下,<ul>
<li>（1）结构体成员变量的首地址能够被这个成员（该成员可能是个结构体）最宽基本类型成员的大小所整除；</li>
<li>（2）sizeof(struct)的值等于struct内最大基本元素长度的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</li>
<li>（3）每个成员相对结构体首地址的偏移量是该成员长度的整数倍，</li>
</ul>
</li>
<li>gcc以4的整数倍对齐;</li>
</ul>
</li>
<li><p>包含结构体成员的结构体,</p>
<ul>
<li>（1）在寻找最宽基本类型成员时，应当包括“子结构体”的成员；</li>
<li><p>（2）“子结构体变量”的首地址能够被其最宽基本类型成员的大小所整除；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;; <span class="comment">//sizeof(S1) = 8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    S1 s;  <span class="comment">//8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>S1或S3的最宽简单成员的类型都为int，所以S3的最宽简单类型为int；<br>S3::s的类型是struct S1，其起始地址是sizeof(int)的整数倍（struct S1最宽的成员是int型）；<br>S3占用内存如下：<br>S3:c1占1字, 填充3字, S1:c占一字, 填充3字, S1:i占4字, S3:c2占1字, 填充3字, 故sizeof(struct S3) = 16;</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>改变缺省的对齐条件, 即“成员相对于结构体首地址的偏移量，是成员大小的整数倍”，变成了“成员相对于结构体首地址的偏移量，是对齐字节的整数倍”<br>VC6中使用语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push) <span class="comment">// 将当前pack设置压栈保存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2) <span class="comment">//按照2字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;; <span class="comment">// 6 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  c1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">sss</span>;</span></span><br><span class="line">    <span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>#pragma pack(n)</code>，如果n比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，结构体成员的偏移量应该取二者的最小值。<br>上面对定义中最宽的int，和#pragma pack(2)比较，所以对齐条件是2字节；<br>char S1::c占1字，int S1::i宽度是4，这里不以4而是以2对齐，所以int S1::i的起始位置是2，sizeof(S1) == 6。<br>注: 没有任何成员的“空结构体”占1byte；</p>
</blockquote>
</li>
</ol>
<h2 id="含位域结构体的sizeof"><a href="#含位域结构体的sizeof" class="headerlink" title="含位域结构体的sizeof"></a>含位域结构体的sizeof</h2><p>使用位域的主要目的是压缩存储，其大致规则为：</p>
<ul>
<li>1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li>
<li>2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li>
<li>3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；</li>
<li>4) 如果位域字段之间穿插着非位域字段，则不进行压缩；</li>
<li>5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><code>String flows(&quot;ffc&quot;);</code>  # flows分配在?</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>头文件:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *str=<span class="literal">NULL</span>);<span class="comment">//构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> Mystring&amp; obj); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring &amp;obj);</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> Mystring &amp;obj);</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Mystring &amp;obj);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span>  <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line">    <span class="keyword">friend</span>  <span class="built_in">std</span>::istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;in, MyString &amp;obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>源文件:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line">Mystring Mystring::<span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分配内存空间，记得+1，因为c风格的字符串以'\n'结尾，需要多加一个字符</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;pstr=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(obj.pstr)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pstr,obj.pstr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="宏-macro"><a href="#宏-macro" class="headerlink" title="宏(macro)"></a>宏(macro)</h1><p>C/C++的宏定义将一个标识符定义为一个字符串，源程序中的该标识符均以指定的字符串来代替。宏的替换是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。<br>宏主要用在宏定义和条件编译</p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h3><p><code>#define MAX 1000</code>: 在《Effective C++》中，这种做法却并不提倡，书中更加推荐以const常量来代替宏常量。因为在进行词法分析时，宏的引用已经被其实际内容替换，因此宏名不会出现在符号表中。所以一旦出错，看到的将是一个无意义的数字，比如上文中的1000，而不是一个有意义的名称，如上文中的MAX。而const在符号表中会有自己的位置，因此出错时可以看到更加有意义的错误提示。</p>
<h3 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&lt;(b) ? (b) : (a))</span></span><br></pre></td></tr></table></figure>
<p>为什么大量的宏定义中用到了<code>do-while</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x) bar(x); baz(x)</span></span><br><span class="line"><span class="comment">// 如果这样使用宏:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    FOO(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 会被替换成:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    bar(x); baz(x); <span class="comment">// 第二句脱离了if控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进一下, 加上大括号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x)  &#123; bar(x); baz(x); &#125;</span></span><br><span class="line"><span class="comment">// 被替换成这样:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    &#123; bar(x); baz(x); &#125;; <span class="comment">// 多了个分号, 编译错误</span></span><br></pre></td></tr></table></figure>
<p>所以正确的写法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x) do &#123; bar(x); baz(x); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样使用宏:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    FOO(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 会被替换成:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    <span class="keyword">do</span> &#123; bar(x); baz(x); &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>do{...} while(condition)</code>语句最后可以有分号也可以没有, 这两种语法上都正确</p>
<h3 id="宏定义中的”-”和”-”"><a href="#宏定义中的”-”和”-”" class="headerlink" title="宏定义中的”#”和”##”"></a>宏定义中的”#”和”##”</h3><p><code>#</code>的功能是将其后面的宏参数进行字符串化操作（Stringfication）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_RUN(func)</span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="built_in">printf</span>(<span class="string">"entry:"</span>#func<span class="string">"\n"</span>); func(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>#func</code>替换后, 作为字符串拼接, 相当于<code>printf(&quot;entry:&quot; + funcName + &quot;\n&quot;)</code></p>
<p><code>##</code>##被称为连接符（concatenator），用来将两个Token连接为一个Token。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> * name;</span><br><span class="line">  <span class="keyword">void</span> (*function) (<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMAND(NAME) &#123; NAME, NAME ## _command &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后你就用一些预先定义好的命令来方便的初始化一个command结构的数组了：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command</span> <span class="title">cmds</span>[] = &#123;</span></span><br><span class="line">COMMAND(quit),</span><br><span class="line">COMMAND(help),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><code>#define</code>常与<code>#ifdef</code>, <code>#ifndef</code>, <code>defined</code>指令配合使用，用于条件编译。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER_INC_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER_INC_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>用宏控制debug日志:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Debug information\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>通过DEBUG宏，我们可以在代码调试的过程中输出辅助调试的信息。当DEBUG宏被删除时，这些输出的语句就不会被编译。更重要的是，这个宏可以通过编译参数来定义。因此通过改变编译参数，就可以方便的添加和取消这个宏的定义，从而改变代码条件编译的结果。</p>
<h1 id="—Part-2-C-—"><a href="#—Part-2-C-—" class="headerlink" title="—Part 2: C++—"></a>—Part 2: C++—</h1><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul>
<li>private：只能由1.该类中的函数、2.其友元函数访问。不能被任何其他访问，该类的对象也不能访问。</li>
<li>protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。但不能被该类的对象访问。</li>
<li>public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。</li>
</ul>
<p>注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。</p>
<h2 id="类实例占用的内存结"><a href="#类实例占用的内存结" class="headerlink" title="类实例占用的内存结"></a>类实例占用的内存结</h2><p>@TODO: 虚函数表</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>析构函数virtual的必要性? 如果一个类是作为基类的,那么该类的析构应该写为virtual; 这样在 <code>delete 基类指针</code> 时, 会自动选择相应版本的析构函数.</li>
</ul>
<h2 id="类的继承后方法属性变化"><a href="#类的继承后方法属性变化" class="headerlink" title="类的继承后方法属性变化"></a>类的继承后方法属性变化</h2><ul>
<li>private 属性不能够被继承。</li>
<li>使用private继承，父类的protected和public属性在子类中变为private；</li>
<li>使用protected继承，父类的protected和public属性在子类中变为protected；</li>
<li>使用public继承，父类中的protected和public属性不发生改变;</li>
</ul>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><ul>
<li><code>class Divide: public Base1, protected Base2 { ... };</code><ul>
<li>Base的private在Divide中是否占用空间 // yes</li>
<li>Base类的static成员, static成员是在堆还是全局区 ?</li>
<li>继承了多个基类的派生类, 有多个虚函数表,</li>
<li>如果派生类没有重写任何基类的virtual函数, 派生类也有虚函数表(vtable), 里面是指向基类的函数</li>
<li>如果派生类没有重写任何基类的virtual函数, 且派生类新建了一个virtual函数, 派生类的虚函数表(vtable)里面依次基类虚函数指针, 派生类自己的虚函数指针</li>
</ul>
</li>
</ul>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>@TODO</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="充满风险的隐式类型转换"><a href="#充满风险的隐式类型转换" class="headerlink" title="充满风险的隐式类型转换"></a>充满风险的隐式类型转换</h3><p>施工中</p>
<h3 id="现实类型转换"><a href="#现实类型转换" class="headerlink" title="现实类型转换"></a>现实类型转换</h3><ul>
<li>旧风格的类型转换:<ul>
<li>C 风格（C-style）强制转型: <code>(T) exdivssion</code> // cast exdivssion to be of type T</li>
<li>函数风格（Function-style）强制转型: <code>T(exdivssion)</code> // cast exdivssion to be of type T</li>
</ul>
</li>
<li><p><code>static_cast</code>: 用法<code>static_cast &lt; type-id &gt; ( expression )</code>,</p>
<ul>
<li>上行转换（把子类的指针或引用转换成基类表示）是安全的；</li>
<li>进行下行转换（把基类指针或引用转换成子类指针或引用），由于没有动态类型检查，所以是不安全的</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证</li>
<li><code>static_cast</code>不能转换掉expression的const、volitale、或者__unaligned属性</li>
<li><code>static_cast</code>转换失败会…[?]  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static_cast 示例</span></span><br><span class="line">Base *a   = <span class="keyword">new</span> Base;</span><br><span class="line">Derived *b = <span class="keyword">static_cast</span>&lt;Derived *&gt;(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14159265</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>dynamic_cast</code>:  主要用来在继承体系中的安全向下转型。它能安全地将指向基类的指针转型为指向子类的指针或引用，</p>
<ul>
<li>为什么需要<code>dynamic_cast</code>强制转换? 当无法使用virtual函数的时候</li>
<li>如果转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时）</li>
<li><code>dynamic_cast</code> 会动用运行时信息（RTTI）来进行类型安全检查，因此<code>dynamic_cast</code>存在一定的效率损失。</li>
<li>基类要有虚函数，否则会编译出错；<code>static_cast</code>则没有这个限制。</li>
</ul>
</li>
</ul>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li><a href="https://msdn.microsoft.com/zh-cn/library/hh279674.aspx" target="_blank" rel="noopener">智能指针（现代 C++）</a></li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>@TODO</p>
<h1 id="C-设计技巧"><a href="#C-设计技巧" class="headerlink" title="C++ 设计技巧"></a>C++ 设计技巧</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>资源获取即初始化（ Resource Acquisition Is Initialization ），或称 RAII。<br>它将必须在使用前请求的资源（被分配的堆内存、执行的线程、打开的接头、打开的文件、被锁的互斥、磁盘空间、数据库连接等——任何存在于受限供给中的事物）的生命周期绑定到一个对象的生存期。</p>
<p>RAII 可总结如下:</p>
<ul>
<li>将资源的操作封装入一个RAII类里:<ul>
<li>构造函数请求资源，并建立所有类不变量或在它无法完成时抛出异常，</li>
<li>析构函数释放资源并决不抛出异常；</li>
</ul>
</li>
<li>始终经由RAII类的实例使用资源，在栈上创建RAII类型的函数内变量，当函数退出时依靠”Stack winding”来保证一定调用RAII类的析构函数完成资源释放</li>
</ul>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;TYPENAME T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAII</span> &#123;</span></span><br><span class="line">  T* p_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  explicit RAII(T* p) : p_(p) &#123;&#125;</span><br><span class="line">  ~RAII() &#123;</span><br><span class="line">    <span class="keyword">delete</span> p_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> *p_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  RAII(<span class="keyword">const</span> RAII&amp; other);</span><br><span class="line">  RAII&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RAII&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">  RAII&lt;SOMERESOURCE&gt; p_;</span><br><span class="line">  RAII&lt;SOMERESOURCE&gt; p2_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Example() :</span><br><span class="line">    p_(<span class="keyword">new</span> SomeResource()),</span><br><span class="line">    p2_(<span class="keyword">new</span> SomeResource()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~Example() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleting Example, freeing SomeResource!/n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题: <code>new Example()</code>生成的<code>Example</code>实例, 如果没有调用<code>delete()</code>, <code>RAII</code>类的析构函数会被调用到吗?</p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>错误的加锁:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.lock();    <span class="comment">// 请求互斥</span></span><br><span class="line">    f();             <span class="comment">// 若 f() 抛异常，则互斥不被释放</span></span><br><span class="line">    mutex.unlock();  <span class="comment">// 抵达此语句，互斥才被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的方法, 使用<code>std::lock_guard</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mutex; <span class="comment">// 定义全局的mutex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    f(); <span class="comment">// f()抛出异常, 仍然会调用到~lock_guard() 释放锁</span></span><br><span class="line">    <span class="comment">// 运行到这里自动执行~lock_guard()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注:lock_guard是互斥封装器, 构造/析构函数定义如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">explicit lock_guard(Mutex&amp; m_):</span><br><span class="line">    m(m_)</span><br><span class="line">&#123;</span><br><span class="line">    m.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~lock_guard()</span><br><span class="line">    &#123;</span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考:</p>
<ul>
<li><a href="http://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">RAII - cppreference.com</a> @Ref</li>
<li><a href="http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802307.html" target="_blank" rel="noopener">【C++设计技巧】C++中的RAII机制</a> @Ref</li>
</ul>
<h2 id="Pimpl"><a href="#Pimpl" class="headerlink" title="Pimpl"></a>Pimpl</h2><p>这个机制是”Private Implementation”的缩写: 也即 <strong>实现私有化</strong>，力图使得头文件对改变不透明。</p>
<h3 id="“实现私有化”必要性"><a href="#“实现私有化”必要性" class="headerlink" title="“实现私有化”必要性"></a>“实现私有化”必要性</h3><p>在C++中, 头文件(类的声明)和源文件(类的实现)是分开的,<br>举个例子, 头文件<code>base.h</code>里声明了一个基类<code>Base</code>, 如果改动<code>Base</code>的公有接口, 会导致所有包含<code>base.h</code>的类(调用Base类的代码, 以及Base的派生类)都有重新编译, 在一个大工程中，这样的修改可能导致重新编译时间的激增。你可以使用Doxygen或者SciTools看看头文件依赖。<br>改动公有接口导致的编译时间激增是可以理解的, 但是如果我们改动了<code>Base</code>的私有接口或者成员, 也会导致上面编译时间激增的情况, 这就有些不可接受了.</p>
<h3 id="如何Pimpl"><a href="#如何Pimpl" class="headerlink" title="如何Pimpl"></a>如何Pimpl</h3><p>MyClass.h 文件内容如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassImpl</span>;</span>   <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MyClass();</span><br><span class="line">  ~MyClass();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MyClassImpl *m_pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>MyClass.cpp 文件内容如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义MyClass的函数:</span></span><br><span class="line">MyClass::MyClass() : m_pImpl(<span class="keyword">new</span> MyClassImpl) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~MyClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::foo() &#123;</span><br><span class="line">    <span class="keyword">return</span> m_pImpl-&gt;foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并定义MyClassImpl</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> var++; &#125;</span><br><span class="line">        <span class="keyword">int</span> var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Pimpl要实现的是, 在对类的私有函数/成员做改动时, 不希望(所有包含该头文件的)源文件被重新编译.</li>
<li><strong>如果一个类被设计为基类，应避免在头文件中出现private函数或成员</strong>， 如果该类有private的函数或成员，最好把它们放进“前置声明（forward declaration）”的类里面，以避免private的声明出现在头文件；</li>
<li>Java需要这种机制吗 ? 不需要, java里有<code>interface</code>, interface里不包含私有数据的, 所以不会有“改动上层类的私有数据导致编译量增加”这种问题.</li>
</ul>
<h3 id="前置声明-forward-declaration"><a href="#前置声明-forward-declaration" class="headerlink" title="前置声明(forward declaration)"></a>前置声明(forward declaration)</h3><p>如果类A中, 有C类型的成员, 则可以在A.h中声明该成员之前, 用<code>class C;</code>的方式来前置声明类型C, 而不再需要在A.h中包含C.h文件:</p>
<p>A.h头文件:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include "C.h"  // 不再需要这一行了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span> <span class="comment">// 前置声明C</span></span><br><span class="line">    C* ptr; <span class="comment">// 成员声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是使用类型的前置声明是有条件的。假设有一个类C，那么如果你的类中如果有定义类型为C的非静态成员，抑或你的类继承了C的话，就不能使用类Test的前置声明，只能用<code>include C.h</code>的方式<br>大概有三种情况可以使用前置声明：</p>
<ul>
<li>参数或返回类型为C的函数声明；</li>
<li>类型为C的类静态成员；</li>
<li>类成员变量的类型是 C类型的指针或引用: <code>C*</code>或 <code>C&amp;</code>；</li>
</ul>
<p>参考:</p>
<ul>
<li><a href="http://www.cnblogs.com/gnuhpc/archive/2012/06/30/2570761.html" target="_blank" rel="noopener">【C++程序设计技巧】Pimpl机制</a> @Ref</li>
</ul>
<h2 id="NVI"><a href="#NVI" class="headerlink" title="NVI"></a>NVI</h2><p>NVI（Non-Virtual Interface ）机制：将虚函数声明为非公有，而将公有函数都声明为非虚 —— 虚拟和公有选其一。</p>
<ul>
<li>如果在基类中作为”对外接口”(public)的函数, 一定设计成非virtual的</li>
<li>当且仅当子类需要调用基类的虚函数时才将虚函数设置为protected</li>
<li>NVI机制不适用于析构函数，对于析构函数，如果是public的也应该是virtual的</li>
</ul>
<blockquote>
<p>如果一个类是作为基类的,那么该类的析构应该写为virtual; 这样在”delete 基类指针” 时, 会自动选择相应版本的析构函数.</p>
</blockquote>
<h3 id="为什么需要NVI"><a href="#为什么需要NVI" class="headerlink" title="为什么需要NVI"></a>为什么需要NVI</h3><p>在标准C++库中我们可以看到这样的一个现象：6个公有虚函数，并且都是std::exception::what()和其重载。142个非公有虚函数。<br>这样设计的目的何在呢，为什么“多此一举”的把虚函数设置为非公有呢？</p>
<p>先看示例代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">         DoFoo1();</span><br><span class="line">         DoFoo2();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoFoo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base's DoFoo1"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoFoo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base's DoFoo2"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoFoo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived's DoFoo2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为C++没有Interface的概念, 我们把基类里定义的 <strong>public且非虚的函数</strong> 视作”接口”, 与java中的接口不同的是, 基类的”接口”函数有自己的函数体.</p>
</blockquote>
<ul>
<li>一般在基类的”接口”里定义更上层的代码(参件<code>Foo()</code>函数), 而把具体的实现放进private/protected的虚函数, 这样做的好处是实现了接口和实现的分离;</li>
<li>派生类可以从基类继承的函数声明为<code>protected virtual</code>的;</li>
<li>需要派生类自己实现的函数声明为<code>private virtual</code>的;</li>
</ul>
<p>Pimpl和NVI都实现了：接口和实现的分离，将不经常变动的控制代码放入public非虚函数，经常变更或者需要派生类重写的放进非public的虚函数。<br>从设计模式上来看，Pimpl用的是委托，NVI用的继承.</p>
<p>参考:</p>
<ul>
<li><a href="http://www.cnblogs.com/gnuhpc/archive/2012/01/17/2324836.html" target="_blank" rel="noopener">【C++程序设计技巧】NVI（Non-Virtual Interface ）</a> @Ref</li>
</ul>
<h1 id="—Part3-OS—"><a href="#—Part3-OS—" class="headerlink" title="—Part3: OS—"></a>—Part3: OS—</h1><h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>自然对齐 <code>naturally aligned</code>（我没找到英文定义，不知道源自哪里）</p>
<p>比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。<br>如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。<br>对于C/C++中的基本数据类型，假设它的长度为n字节，那么该类型的变量会被编译器默认分配到n字节对齐的内存上。<br>例如，char的长度是1字节，char类型变量的地址将是1字节对齐的（任意值均可）；int的长度是4字节，所以int类型变量将被分配到4字节对齐的地址上。这种默认情况下的变量对齐方式又称作自然对齐（naturally aligned）</p>
<blockquote>
<p><a href="https://www.quora.com/What-is-natural-alignment-Why-should-a-generic-pointer-be-aligned" target="_blank" rel="noopener">What is natural alignment? Why should a generic pointer be aligned? - Quora</a></p>
</blockquote>
<p><strong>struct对齐方式:</strong></p>
<ul>
<li>每个成员相对结构体首地址的偏移量是该成员长度的整数倍，如果不是整数倍需要填充字节（gcc以4的整数倍对齐）;</li>
<li>“struct类型”的成员的首地址能够被这个成员（该成员是个结构体）最宽基本类型成员的大小所整除；</li>
<li>sizeof(struct)的值等于struct内最大基本元素长度的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</li>
</ul>
<blockquote>
<p>写代码时，通常只需要关注：尽量将数据宽度大的字段(也即较长的double/longlong型变量)放到结构体的前面即可，数据宽度较小的字段无需编译器补齐，从而可以节约内存。</p>
</blockquote>
<p>问题: 函数堆栈里的局部变量, 是不是按照上面的规则对齐的?</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>回顾: 进程的虚拟内存地址布局</p>
<p><img src="/images/C_C++ Tutorials/cpp_vm_model.png" alt="进程虚拟内存布局"></p>
<p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li>
<li>Data：这里存放的是初始化过的全局变量</li>
<li>BSS：这里存放的是未初始化的全局变量</li>
<li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的<code>brk</code>相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与<code>mmap</code>系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：这是栈区域，自高地址向低地址增长</li>
</ul>
<h2 id="深入理解malloc"><a href="#深入理解malloc" class="headerlink" title="深入理解malloc"></a>深入理解malloc</h2><p><code>void *ptr = malloc(N)</code> 之后发生了什么?</p>
<ul>
<li>函数<code>malloc()</code>通过<code>brk()</code>给进程分配了N bytes的线性地址区域(VM)  此时系统并没有随即分配页框(RAM), 进程也没有占用N bytes的物理内存. // 这也表明了, 你时常在使用top的时候VIRT值增大, 而RES值却不变的原因.</li>
<li>当第一次通过指针使用此内存页, 在RAM中找不到与之相对应的页框. 发生缺页异常, 系统灵敏地捕获这一异常, 进入缺页异常处理阶段：接下来, 系统会分配一个页框(RAM)映射给它, 我们把这种情况(被访问的页还没有被放在任何一个页框中, 内核分配一新的页框并适当初始化来满足调用请求)称为Demand Paging.</li>
<li>过了很长一段时间, 通过<code>*ptr</code>再次引用内存第一页. 若系统在RAM找不到它映射的页框(可能交换至磁盘了). 发生缺页异常, 并被系统捕获进入缺页异常处理. 接下来, 系统则会分配一页页框(RAM), 找到备份在磁盘的那“页”, 并将它换入内存(其实因为换入操作比较昂贵, 所以不总是只换入一页, 而是预换入多页. 这也表明某些文档说：”vmstat某时出现不少si并不能意味着物理内存不足”).<br>凡是类似这种会迫使进程去睡眠(很可能是由于当前磁盘数据填充至页框(RAM)所花的时间), 阻塞当前进程的缺页异常处理称为主缺页(major falut), 也称为<code>大缺页</code>. 相反, 不会阻塞进程的缺页, 称为次缺页(minor fault).</li>
<li>通过指针使用到了N bytes的第二页. 参见第一次访问N bytes第一页, “Demand Paging”</li>
<li>通过<code>free()</code>释放了内存, 线性地址区域被删除, 页框也被释放.</li>
<li>再次通过<code>*ptr</code>引用内存页, 已被<code>free()</code>了(用户进程本身并不知道). 发生缺页异常, 缺面异常处理程序会检查出这个缺页不在进程内存空间之内. 对待这种编程错误引起的缺页异常, 系统会杀掉这个进程, 并且报告著名的段错误(Segmentation fault).</li>
</ul>
<blockquote>
<p>主缺页异常处理过程示意图,参见 <a href="https://www.slideshare.net/guestb7dc8e/handling-page-fault" target="_blank" rel="noopener">Handling Page Fault</a></p>
</blockquote>
<h3 id="Mapping-Area和Heap"><a href="#Mapping-Area和Heap" class="headerlink" title="Mapping Area和Heap"></a>Mapping Area和Heap</h3><ul>
<li>如果malloc申请的字节数N &gt; 128k, 那么malloc会调用<code>mmap</code>在Mapping Area区申请一块内存.</li>
<li>对于小于128k的内存, malloc会调用<code>brk</code>在Heap区申请内存.</li>
<li>Mapping Area和Heap的不同在于:<ul>
<li>malloc在Mapping Area区申请的内存块, 当调用free时, 虚拟内存和物理内存一起被释放了;</li>
<li>malloc在Heap区申请的内存, 当调用<code>free(p)</code>时, 如果p指向这块内存的更高的地址还有未free的内存块, p的内存块的虚拟内存/物理内存都不会立刻释放, 而是仅仅标示为”可再分配的”,</li>
<li>实际上Linux维护了一个结构体链来维护已经分配过的Heap区, 每个结构体都对应一块malloc申请的内存块, 当调用malloc申请内存时(如果小于128k), 系统则会在这个链表里寻找一个”已经free且足够大”的块, 如果找不到符合条件的块, 则会在Heap的<code>Mapped Region</code>申请新的;</li>
<li>寻找”已经free且足够大”的块有first fit和best fit两种, 如果使用first fit不可避免的有空间浪费</li>
</ul>
</li>
<li>因为Heap区都是小于128k的细碎内存块, 上面的链表可以防止反复申请/释放带来的内存碎片, 但mmap对应的区域都是大块(大于128K)的内存, 所以不用采用上面的机制.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         +-----------+</span><br><span class="line">         |  Mapping  |</span><br><span class="line">         |  Area     |</span><br><span class="line">         +------------- - - -+--</span><br><span class="line">         |           |       |</span><br><span class="line">         |  Unmapped |       |</span><br><span class="line">         |   Region  |       |</span><br><span class="line">         |           |     Heap</span><br><span class="line">break -&gt; +-----------+</span><br><span class="line">         |  Mapped   |       |</span><br><span class="line">         |  Region   |       |</span><br><span class="line">         |           |       |</span><br><span class="line">         +------------- - - -+--</span><br><span class="line">         |   BSS     |</span><br><span class="line">         |   DATA    |</span><br><span class="line">         |   TEXT    |</span><br><span class="line">         +-----------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；<br>而从break往高地址，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
</blockquote>
<p>参考:</p>
<ul>
<li><a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="noopener">CodingLabs - 如何实现一个malloc</a> @Ref</li>
<li><a href="https://vinoit.me/2016/05/20/linux-memory-alloc/" target="_blank" rel="noopener">Linux内存分配的原理–malloc/brk/mmap | VZ’s Blog</a> @Ref</li>
</ul>
<h2 id="深入理解new"><a href="#深入理解new" class="headerlink" title="深入理解new"></a>深入理解new</h2><p>C++中的<code>new</code>, <code>operator new</code>, <code>placement new</code>:</p>
<ol>
<li>operator new: <code>void* buf = operator new(100)</code>;  operator new只负责申请内存, 在程序中遇到<code>char* buf = new char[100]</code>语句时，它将转换为对函数operator new的调用</li>
<li>new(new operator): <code>A *a = new A();</code> // 申请内存和构造</li>
<li>placement new expression(定位表达式) : <code>A *p = new(pArea) A();</code> // prt是被分配好内存的指针<ul>
<li><code>delete *p</code>和<code>delete pArea</code>的区别?</li>
</ul>
</li>
</ol>
<h3 id="new-new-operator"><a href="#new-new-operator" class="headerlink" title="new(new operator)"></a>new(new operator)</h3><ul>
<li>new(<code>new operator</code>或者叫<code>new运算符</code>): 负责分配内存并调用构造函数, 有<code>new</code>和<code>::new</code>之分，前者位于std</li>
<li>对应的删除<code>delete operator</code>, 调用析构函数并释放内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A* a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>
<p>通过反汇编可以看出<code>A* = new A</code>会被gcc解析成<code>operator new(sizeof(A))</code>和<code>A()</code>两个步骤, <code>delete a</code>被解析为<code>~A()</code>和<code>operator delete(a)</code>两个步骤。</p>
<p>通过下面的<code>operator new</code>一节可以得知, 如果一个类重载了operator new函数, new运算符会调用该类自己的operator new版本,<br>但是下面的语句可以指定使用全局的operator new:  <code>A *p = ::new A;</code></p>
<h3 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h3><ul>
<li><code>operator new</code>指对new的重载形式，它是一个函数，并不是运算符。只负责分配内存而不会调用构造, 对于<code>operator new</code>来说，分为全局重载和类重载<ul>
<li>全局重载: <code>void* ::operator new(size_t size)</code></li>
<li>类中重载: <code>void* A::operator new(size_t size)</code>, 注意operator new的参数是<code>size_t</code>, 返回是void指针</li>
</ul>
</li>
<li><code>operator new()</code>完成的操作一般只是分配内存，事实上系统默认的全局<code>::operator new(size_t size)</code>也只是调用malloc分配内存，并且返回一个<code>void*</code>指针。而构造函数的调用(如果需要)是在new(<code>new operator</code>或者叫<code>new运算符</code>)中完成的。</li>
<li>如果调用<code>operator new</code>分配内存失败, 会尝试调用new_handler, 如果仍然失败, 则抛出std::bad_alloc</li>
<li>对应的删除operator delete: <code>operator delete(buf)</code>;</li>
</ul>
<p>全局operaotr new 源码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// try to allocate size bytes</span></span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>) <span class="comment">//申请空间</span></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>) <span class="comment">//若申请失败则调用处理函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// report no memory</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc nomem;</span><br><span class="line">            _RAISE(nomem); <span class="comment">// #define _RAISE(x) ::std:: _Throw(x) 抛出nomem的异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何调用operator new：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定调用全局的operator new , 而不是类自己重载的版本 // 存疑</span></span><br><span class="line"><span class="keyword">void</span> *p = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>operator new有三种形式：</p>
<ul>
<li>(1)throwing <code>void* operator new (std::size_t size) throw (std::bad_alloc);</code></li>
<li>(2)nothrow  <code>void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) throw();</code></li>
<li>(3)placement <code>void* operator new (std::size_t size, void* ptr) throw();</code></li>
</ul>
</li>
<li><p><code>A* a = new A;</code> 这句代码里的new先是调用了throwing版本的operator new分配内存, 然后调用构造;</p>
</li>
<li><code>A* a = new(std::nothrow) A;</code> new先调用nothrow版本的operator new, 然后调用构造;</li>
<li>placement版本的operator new，它也是对operator new的一个重载，定义于<code>&lt;new&gt;</code>中, 它多接收一个ptr参数，但它只是简单地返回ptr, 内部什么都没有做, 当使用 <strong>placement new expression</strong> 的时候会调用这个版本的operator new</li>
</ul>
<h4 id="重载-operator-new"><a href="#重载-operator-new" class="headerlink" title="重载::operator new"></a>重载::operator new</h4><p>Effective C++ 第三版第 50 条列举了定制 new/delete 的几点理由</p>
<ul>
<li>检测代码中的内存错误</li>
<li>优化性能</li>
<li>获得内存使用的统计数据</li>
</ul>
<ol>
<li>不改变operator new的默认参数重载: 用这种方式的重载，使用方不需要包含任何特殊的头文件，也就是说不需要看见这两个函数声明。“性能优化”通常用这种方式。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"global op new called, size = %zu\n"</span>,sz);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">puts</span>(<span class="string">"global op delete called"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以下调用自定义的operator new/delete:</span></span><br><span class="line">     <span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">     <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">     <span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>增加新的参数的operator new, 为了跟踪内存分配的错误</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line)</span></span>;  <span class="comment">// 其返回的指针必须能被普通的 ::operator delete(void*) 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line)</span></span>;   <span class="comment">// 这个函数只在析构函数抛异常的情况下才会被调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new (__FILE, __LINE__)会调用构造函数吗?</span></span><br><span class="line">Foo* p = <span class="keyword">new</span> (__FILE, __LINE__) Foo;</span><br></pre></td></tr></table></figure>
<h4 id="重载class-operator-new"><a href="#重载class-operator-new" class="headerlink" title="重载class::operator new"></a>重载class::operator new</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"custom new for size "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"custom new for size "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 以下会调用类成员的operator new/delete</span></span><br><span class="line">     X* p1 = <span class="keyword">new</span> X;</span><br><span class="line">     <span class="keyword">delete</span> p1;</span><br><span class="line">     X* p2 = <span class="keyword">new</span> X[<span class="number">10</span>];</span><br><span class="line">     <span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载时的优先顺序"><a href="#重载时的优先顺序" class="headerlink" title="重载时的优先顺序"></a>重载时的优先顺序</h4><p>在使用 new运算符分配类类型的对象时（如果该类重载了operator new），将调用该类的operator new。<br>在使用 new运算符分配内置类型的对象、未重载operator new函数的类类型的对象、任何类型的数组时，将调用全局operator new 函数。</p>
<h4 id="new-handler"><a href="#new-handler" class="headerlink" title="new_handler"></a>new_handler</h4><p>operator new失败, 会调用<code>new_handler</code>, 如果<code>new_handler</code>不存在则抛出一个<code>std::bad_alloc</code>异常,<br><code>std::set_new_handler</code>可以为当前operator new指定一个new_handler</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*p_new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::set_new_handler(p_new_handler);</span><br><span class="line"><span class="keyword">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000000000L</span>];</span><br></pre></td></tr></table></figure>
<p>如何设计一个良好的new_handler ? 《Effective C++》建议以下几种做法(选1即可):</p>
<ol>
<li>让更多的内存可以被使用（也就是清理内存，让出更多的空间给这里的内存分配操作）</li>
<li>安装另一个new_handler（当这个new_handler无法处理当前分配失败的情况时，我们可以装在另外一个new_handler试图处理这种情况）</li>
<li>卸载new_handler（如果当前的new_handler确实无法处理当前错误，那么就将当前的new_handler卸载，例如nullptr，让new抛出bad::alloc的异常）</li>
<li>直接抛出bad::alloc的异常</li>
<li>调用abort()或exit()直接终止程序</li>
</ol>
<h3 id="placement-new-expression"><a href="#placement-new-expression" class="headerlink" title="placement new expression"></a>placement new expression</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(T)]; <span class="comment">// 分配内存</span></span><br><span class="line">T* tptr = <span class="keyword">new</span>(ptr) T(<span class="string">"hello"</span>);   <span class="comment">// 在已分配内存进行构造</span></span><br><span class="line">tptr-&gt;~T();                      <span class="comment">// 析构</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>
<p>第二行的<code>new(ptr) T(&quot;hello&quot;)</code>会调用operator new的placement形式</p>
<blockquote>
<p>delete tptr能释放ptr指向的内存吗?</p>
</blockquote>
<h3 id="delete和operator-delete"><a href="#delete和operator-delete" class="headerlink" title="delete和operator delete"></a>delete和operator delete</h3><ul>
<li>delete: 调用析构函数并释放内存</li>
<li>operator delete: <code>operator delete(buf)</code></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/solstice/article/details/6198937" target="_blank" rel="noopener">C++ 工程实践(2)：不要重载全局 ::operator new() - CSDN博客</a> @Ref</li>
<li><a href="http://zh.cppreference.com/w/cpp/language/new" target="_blank" rel="noopener">new 表达式 - cppreference.com</a> @Ref</li>
<li><a href="http://zh.cppreference.com/w/cpp/memory/new/operator_new" target="_blank" rel="noopener">operator new, operator new[] - cppreference.com</a> @Ref</li>
</ul>
<h1 id="—Part4-Debug-amp-Perf—"><a href="#—Part4-Debug-amp-Perf—" class="headerlink" title="—Part4: Debug &amp; Perf—"></a>—Part4: Debug &amp; Perf—</h1><h1 id="排查指针-内存问题-amp-解决方案"><a href="#排查指针-内存问题-amp-解决方案" class="headerlink" title="排查指针/内存问题 &amp; 解决方案"></a>排查指针/内存问题 &amp; 解决方案</h1><p>指针引起的内存问题:</p>
<ul>
<li>野指针读写: 野指针指的是未经初始化的指针（似乎<code>int *p;</code>定义的指针没有自动置为Null）</li>
<li>悬垂指针读写: 被free释放但是没有置为Null的指针</li>
<li>数组等类型读写越界</li>
<li>内存释放两次（DF，Double Free），第二次释放导致coredump</li>
<li>内存泄漏, 通常是不匹配地使用 malloc/new/new[] 和 free/delete/delete[]</li>
</ul>
<h2 id="Core-Down问题排查"><a href="#Core-Down问题排查" class="headerlink" title="Core Down问题排查"></a>Core Down问题排查</h2><p>引起core down的原因可能有:</p>
<ul>
<li>数组访问越界, 读到错误的数据, 这种情况一般直接Core down?</li>
<li>数组/指针写越界, 破坏了其他的数据, 这种情况可能当时不引起Core down</li>
<li>Double Free, 第二次<code>free()</code>直接Core down</li>
</ul>
<h3 id="不使用第三方工具"><a href="#不使用第三方工具" class="headerlink" title="不使用第三方工具"></a>不使用第三方工具</h3><p>重载new/ malloc, 申请的内存添加头部/尾部特殊字节(线程id), 并用magic number填充, core down时可以分析是被哪个线程写入了</p>
<h3 id="使用第三方工具-库解决方案"><a href="#使用第三方工具-库解决方案" class="headerlink" title="使用第三方工具/库解决方案:"></a>使用第三方工具/库解决方案:</h3><h4 id="一些满足特殊现象的分析方法"><a href="#一些满足特殊现象的分析方法" class="headerlink" title="一些满足特殊现象的分析方法:"></a>一些满足特殊现象的分析方法:</h4><ul>
<li>对于固定会越界的代码位置来说，计算好数据位置，使得越界后第一个字节的内存起始的内存页<code>mprotect</code>写保护中就可以了。随后像man文档的例子一样注册SIGSEGV信号的处理函数即可，这里可以用backtrace(3)和backtrace_symbols(3)等函数来打出调用栈，轻松找过越界的罪魁祸首</li>
<li><code>gdb</code>调试支持对内存位置设置修改断点，而且gdb的内存断点不像直接用<code>mprotect()</code>有那么多限制</li>
</ul>
<h4 id="静态分析工具"><a href="#静态分析工具" class="headerlink" title="静态分析工具"></a>静态分析工具</h4><p>代码静态分析工具, google有很多, 可以检查疑似写内存的问题</p>
<h4 id="分析coredump文件"><a href="#分析coredump文件" class="headerlink" title="分析coredump文件"></a>分析coredump文件</h4><p>一般方法仍然是分析coredump文件, coredump文件里有哪些有用的信息?</p>
<ul>
<li><strong>glibc的MALLOC_CHECK环境变量</strong>,  适用于“double free”, “free(invalid )”<ul>
<li>实现: 实际上malloc()分配的内存会比用户实际申请的长度大一点，在返回给用户代码的指针位置的前面有一个固定大小的结构，放置着该块内存的长度、属性和管理的数据结构。</li>
<li>每当在程序运行过程free内存给glibc时，glibc会检查其隐藏的元数据的完整性，如果发现错误就会立即abort。</li>
</ul>
</li>
<li><strong>electric-fence内存调试库</strong>: 适用于内存被写坏, 延后引发的core down。<ul>
<li>原理是采用Linux的虚拟内存机制来保护动态分配的内存，在申请的内存的位置放置只读的哨兵页，在程序越界读写时直接coredump退出。</li>
<li>因为对内存做保护使用了mprotect(2)等API，这个API对内存设置只读等属性要求内存页必须是4K对齐的（本质上是Intel CPU的页属性设置的要求），所以内存使用率较低的程序可以用该库进行检查，但是内存使用率很高的程序在使用过程中会造成内存暴涨而不可用。</li>
</ul>
</li>
<li><strong>Valgrind仿真工具</strong>(最常用的是Memcheck) 可以检查: 使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li>
<li>以上两种工具都很明显影响性能, 新版本的gcc（gcc49）提供了很好的内存访问检查机制<code>命令行参数 -fsanitize=address -fno-omit-frame-pointer</code><ul>
<li>检查内存越界的实现是..?</li>
</ul>
</li>
<li>另外, Google的 <strong>address sanitizer</strong>（简称asan）是一个用来检测c/c++程序的快速内存检测工具。相比valgrind的优点就是速度快，官方文档介绍对程序性能的降低只有2倍。</li>
</ul>
<h2 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h2><ul>
<li>代码静态检查工具</li>
<li>Valgrind仿真</li>
<li>重载全局的malloc / free函数，申请和释放内存的时候打印函数和返回地址（用异步日志库）</li>
</ul>
<blockquote>
<p>C++考虑使用shared_ptr, RAII机制来避免内存泄漏</p>
</blockquote>
<h2 id="多线程-amp-高并发情况下"><a href="#多线程-amp-高并发情况下" class="headerlink" title="多线程 &amp; 高并发情况下"></a>多线程 &amp; 高并发情况下</h2><p>在增加debug log/ efence动态库 / 都会严重影响qps导致Core down无法重现, 另外特殊网络环境(高延迟, 丢包)下才会重现的问题</p>
<ul>
<li>弱网络环境模拟<code>traffic control</code>: 能够控制网络速率、丢包率、延时等网络环境，作为iproute工具集中的一个工具，由linux系统自带</li>
<li>Http压测工具<code>wrk</code>, 类似ab</li>
</ul>
<p>手动异常测试请求:</p>
<ol>
<li>异常的tcp连接。即在客户端 tcp connent系统调用时，10%概率直接close这个socket。</li>
<li>异常的ssl连接。考虑两种情况，full handshake第一阶段时，即发送 client hello时，客户端10%概率直接close连接。full handshake第二阶段时，即发送 clientKeyExchange时，客户端 10%概率直接直接关闭 TCP连接。</li>
<li>异常的HTTPS请求，客户端10%的请求使用错误的公钥加密数据，这样nginx解密时肯定会失败。</li>
</ol>
<p>使用 tcpcopy等工具在线上引流到测试机器进行压测，如果常规流量达不到重现标准，可以对流量进行放大。若线上搭建环境测试有困难，可以对线上流量抓包，然后在线下重放（tcpdump、tcpreplay和tcprewrite等工具）。<br>这一步之后，一般情况下都能增大重现的概率。如果还难以重现，往往都是一些代码本身的竞态条件（Race Condition）造成的，一般需要在引流测试的同时对CPU或者IO加压，以增大资源竞争的概率来增加问题复现的概率。甚至有些问题是出现网络抖动等情况下，需要模拟弱网络的环境（Linux 2.6内核以上有netem模块，可以模拟低带宽、传输延迟、丢包等情况，使用tc这个工具就可以设置netem的工作模式）。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://0xffffff.org/2017/01/22/39-multi-thread-memory-bug/" target="_blank" rel="noopener">Linux环境下多线程C/C++程序的内存问题调试 | 浅墨的部落格</a> @Ref</li>
<li><a href="http://wetest.qq.com/lab/view/?id=103" target="_blank" rel="noopener">高并发性能调试经验分享 - 腾讯WeTest</a> @Ref</li>
<li><a href="http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html" target="_blank" rel="noopener">定位多线程内存越界问题实践总结 - DJ IN MUSIC - 博客园</a> @Ref</li>
</ul>
<h1 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h1><p>@Ref： <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" target="_blank" rel="noopener">Perf – Linux下的系统性能调优工具，第 1 部分</a></p>
<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p>perf应该是最全面最方便的一个性能检测工具。由 linux内核携带并且同步更新，基本能满足日常使用。</p>
<ul>
<li>使用 perf，您可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；您也可以分析软件事件，比如 Page Fault 和进程切换。</li>
<li>使用 Perf 可以计算每个时钟周期内的指令数，称为 IPC，IPC 偏低表明代码没有很好地利用 CPU。</li>
<li>Perf 还可以对程序进行函数级别的采样，从而了解程序的性能瓶颈究竟在哪里等等。</li>
</ul>
<p>通过<code>perf top</code>就能列举出当前系统或者进程的热点事件，函数的排序。 perf record能够纪录和保存系统或者进程的性能事件，用于后面的分析，比如火焰图。</p>
<h2 id="oprofile"><a href="#oprofile" class="headerlink" title="oprofile"></a>oprofile</h2><p>基本被perf取代</p>
<blockquote>
<p>@Ref: <a href="http://velep.com/archives/1013.html" target="_blank" rel="noopener">linux性能分析工具oprofile的安装与使用 » reille blog</a></p>
</blockquote>
<h2 id="gprof"><a href="#gprof" class="headerlink" title="gprof"></a>gprof</h2><p>gprof主要是针对应用层程序的性能分析工具，缺点是需要重新编译程序，而且对程序性能有一些影响。不支持内核层面的一些统计，优点就是应用层的函数性能统计比较精细，接近我们对日常性能的理解，比如各个函数时间的运行时间，，函数的调用次数等，很人性易读。<br>原理是 编译期前在每个函数增加一个mcount函数调用, 用来记录函数耗时和调用次数。</p>
<h2 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h2><p>systemtap 其实是一个运行时程序或者系统信息采集框架，主要用于动态追踪，当然也能用做性能分析，功能最强大，同时使用也相对复杂。不是一个简单的工具，可以说是一门动态追踪语言。如果程序出现非常麻烦的性能问题时，推荐使用 systemtap。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程语言快速入门/" rel="tag"># 编程语言快速入门</a>
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
            <a href="/tags/宏/" rel="tag"># 宏</a>
          
            <a href="/tags/指针/" rel="tag"># 指针</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/后端架构/Arch-架构-并发系统-C100K/" rel="next" title="高并发系统(C10K, C100K)">
                <i class="fa fa-chevron-left"></i> 高并发系统(C10K, C100K)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/数据结构与算法/Algorithm-算法设计/" rel="prev" title="笔记：算法设计">
                笔记：算法设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/hexo_avatar.png"
                alt="whatsrtos" />
            
              <p class="site-author-name" itemprop="name">whatsrtos</p>
              <p class="site-description motion-element" itemprop="description"><s>代码朋克</s></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">123</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">253</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#—Part-1-ANSI-C—"><span class="nav-text">—Part 1: ANSI C—</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#大小端存储"><span class="nav-text">大小端存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#格式化输出"><span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-amp-指针的不同"><span class="nav-text">数组 &amp; 指针的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组退化"><span class="nav-text">数组退化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组什么时候会”退化”"><span class="nav-text">数组什么时候会”退化”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态数组索引-C99"><span class="nav-text">静态数组索引(C99)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#柔性数组-flexible-array"><span class="nav-text">柔性数组(flexible array)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针-amp-引用"><span class="nav-text">指针&amp;引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针"><span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体"><span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体字节对齐"><span class="nav-text">结构体字节对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#含位域结构体的sizeof"><span class="nav-text">含位域结构体的sizeof</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重载函数"><span class="nav-text">重载函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载运算符"><span class="nav-text">重载运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宏-macro"><span class="nav-text">宏(macro)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#宏定义"><span class="nav-text">宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#宏常量"><span class="nav-text">宏常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏函数"><span class="nav-text">宏函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏定义中的”-”和”-”"><span class="nav-text">宏定义中的”#”和”##”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件编译"><span class="nav-text">条件编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#—Part-2-C-—"><span class="nav-text">—Part 2: C++—</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制"><span class="nav-text">访问控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类实例占用的内存结"><span class="nav-text">类实例占用的内存结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数"><span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承后方法属性变化"><span class="nav-text">类的继承后方法属性变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承"><span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚继承"><span class="nav-text">虚继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#充满风险的隐式类型转换"><span class="nav-text">充满风险的隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#现实类型转换"><span class="nav-text">现实类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#智能指针"><span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL"><span class="nav-text">STL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-设计技巧"><span class="nav-text">C++ 设计技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RAII"><span class="nav-text">RAII</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子1"><span class="nav-text">例子1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子2"><span class="nav-text">例子2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pimpl"><span class="nav-text">Pimpl</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“实现私有化”必要性"><span class="nav-text">“实现私有化”必要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何Pimpl"><span class="nav-text">如何Pimpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前置声明-forward-declaration"><span class="nav-text">前置声明(forward declaration)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NVI"><span class="nav-text">NVI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要NVI"><span class="nav-text">为什么需要NVI</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#—Part3-OS—"><span class="nav-text">—Part3: OS—</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存对齐"><span class="nav-text">内存对齐</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配"><span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解malloc"><span class="nav-text">深入理解malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mapping-Area和Heap"><span class="nav-text">Mapping Area和Heap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解new"><span class="nav-text">深入理解new</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-new-operator"><span class="nav-text">new(new operator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operator-new"><span class="nav-text">operator new</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载-operator-new"><span class="nav-text">重载::operator new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载class-operator-new"><span class="nav-text">重载class::operator new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载时的优先顺序"><span class="nav-text">重载时的优先顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-handler"><span class="nav-text">new_handler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#placement-new-expression"><span class="nav-text">placement new expression</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete和operator-delete"><span class="nav-text">delete和operator delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#—Part4-Debug-amp-Perf—"><span class="nav-text">—Part4: Debug &amp; Perf—</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排查指针-内存问题-amp-解决方案"><span class="nav-text">排查指针/内存问题 &amp; 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-Down问题排查"><span class="nav-text">Core Down问题排查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不使用第三方工具"><span class="nav-text">不使用第三方工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用第三方工具-库解决方案"><span class="nav-text">使用第三方工具/库解决方案:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一些满足特殊现象的分析方法"><span class="nav-text">一些满足特殊现象的分析方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态分析工具"><span class="nav-text">静态分析工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析coredump文件"><span class="nav-text">分析coredump文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏排查"><span class="nav-text">内存泄漏排查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程-amp-高并发情况下"><span class="nav-text">多线程 &amp; 高并发情况下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考-1"><span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序性能分析"><span class="nav-text">程序性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#perf"><span class="nav-text">perf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#oprofile"><span class="nav-text">oprofile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gprof"><span class="nav-text">gprof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#systemtap"><span class="nav-text">systemtap</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whatsrtos</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://whatsrtos.github.io/30MinsTutorial/C_C++ Tutorials/';
          this.page.identifier = '30MinsTutorial/C_C++ Tutorials/';
          this.page.title = 'C/C++ Tutorials';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
