<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Linux,命令行,后端技术,内存寻址,进程,IPC,信号,Systemd,Sysvinit,用户态,内核态," />










<meta name="description" content="常用命令使用 manman 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 man lsof 第一行是 “LSOF(8)”, 表示是第8类, man man 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:   系统命令 系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行 各种库函数手册">
<meta name="keywords" content="Linux,命令行,后端技术,内存寻址,进程,IPC,信号,Systemd,Sysvinit,用户态,内核态">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux进阶（命令行，系统配置，内存管理，进程，信号）">
<meta property="og:url" content="https://whatsrtos.github.io/Linux/Linux-Primer/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="常用命令使用 manman 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 man lsof 第一行是 “LSOF(8)”, 表示是第8类, man man 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:   系统命令 系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行 各种库函数手册">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/linux-compress-cmd.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-Net-Throughput-A-Day.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-Net-Throughput-Iftop.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/linux_system_call.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-DirectIO-vs-BufferIO.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-IO-Blocked.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-IO-NonBlocking.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-IO-Multiplexing.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/Linux-IO-Async.png">
<meta property="og:image" content="https://whatsrtos.github.io/images/Linux-Primer/64bit_linux_memory.png">
<meta property="og:image" content="http://7xjtfr.com1.z0.glb.clouddn.com/segment_descriptor.png">
<meta property="og:updated_time" content="2021-02-15T07:01:38.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux进阶（命令行，系统配置，内存管理，进程，信号）">
<meta name="twitter:description" content="常用命令使用 manman 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 man lsof 第一行是 “LSOF(8)”, 表示是第8类, man man 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:   系统命令 系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行 各种库函数手册">
<meta name="twitter:image" content="https://whatsrtos.github.io/images/Linux-Primer/linux-compress-cmd.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://whatsrtos.github.io/Linux/Linux-Primer/"/>





  <title>Linux进阶（命令行，系统配置，内存管理，进程，信号） | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://whatsrtos.github.io/Linux/Linux-Primer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whatsrtos">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux进阶（命令行，系统配置，内存管理，进程，信号）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  18,060
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="使用-man"><a href="#使用-man" class="headerlink" title="使用 man"></a>使用 man</h2><p>man 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 <code>man lsof</code> 第一行是 “LSOF(8)”, 表示是第8类, <code>man man</code> 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:</p>
<blockquote>
<ol>
<li>系统命令</li>
<li>系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行</li>
<li>各种库函数手册，例如glibc，pthread库API等，如果是非C库，则会标注出对于的链接选项</li>
<li>特殊设备文件，例如zero, mem等</li>
<li>文件格式手册，描述Linux支持的各种文件系统以及对于的C接口结构，如vfat/iso</li>
<li>游戏程序文档</li>
<li>其它的各种各样不在前边分类的文档（8/9除外）</li>
<li>系统管理员命令，一般仅供root用户使用，如cron/useradd等</li>
<li>Linux内核相关部分的手册，一般情况很少用到，这一节就没有intro介绍页</li>
</ol>
</blockquote>
<ul>
<li><code>man ascii</code>: 该命令用来查看 ASC II表</li>
<li><code>man malloc</code>: 查看malloc用法, 如果显示 “No manual entry for malloc”, 则需要安装 “man-pages”: <code>yum -y install man-pages</code></li>
</ul>
<h2 id="ps-top-free-vmstat"><a href="#ps-top-free-vmstat" class="headerlink" title="ps, top, free, vmstat"></a>ps, top, free, vmstat</h2><p><code>vmstat</code>, <code>sar</code>, <code>iostat</code>, <code>iotop</code><br>@Ref 参考 → <a href="https://whatsrtos.github.io/Linux/Linux-Performance/#基础性能参数">Linux-Performance.md</a></p>
<h2 id="sort-uniq-wc-cut"><a href="#sort-uniq-wc-cut" class="headerlink" title="sort, uniq, wc, cut"></a>sort, uniq, wc, cut</h2><ul>
<li><p><code>sort</code>参数:</p>
<ul>
<li>-t 指定分隔符</li>
<li>-n 按数字大小排序, 如果不加-n默认是ASCII码排序</li>
<li>-r 倒序</li>
<li>-k 1,5 指定按哪一列排序, 默认是从第N列到行尾, <code>-k4</code>指定按第四列排序</li>
</ul>
<blockquote>
<p>例:<br>按进程VSS内存排序: <code>ps aux | tr -s &quot; &quot; | sort -nrk 5 | cut -d &quot; &quot; -f 1,2,5,6,11- | more</code><br>分隔符为”:”的文件按照第5列数值排序: <code>cat file | sort -t : -nrk 1,5</code></p>
</blockquote>
</li>
<li><p><code>uniq</code>只能去除相邻行的重复, 所以一般跟<code>sort</code>联用. <code>cat /proc/cpuinfo | grep &#39;physical id&#39; | sort | uniq | wc -l</code></p>
</li>
<li><code>wc</code>: -l行数, -w单词数</li>
<li><p><code>cut</code>用来显示行中的指定部分, 分隔符用-d 参数(如果不加-d参数则分隔符是制表符), 取出第几列用-f 参数(从1开始),<br>例: <code>who | cut -d &#39; &#39; -f 2</code></p>
<blockquote>
<p>注: cut通常和其他命令一起使用, 用来处理其他命令的输出, 但实际情况下很多命令的分隔符并不统一, 所以用 awk比 cut更方便: <code>ls -l | awk &#39;{print $9}&#39;</code></p>
</blockquote>
</li>
</ul>
<h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><ul>
<li>创建软链接: <code>ln -s src target</code>  // 记住 <code>ln ... as ...</code></li>
<li>创建硬链接: <code>ln src target</code></li>
<li>软链接vs硬链接:<ul>
<li>允许对目录创建软链接,硬链接不可以</li>
<li>可以跨文件系统创建软链接, 硬链接不可以</li>
<li>删除源文件, 软链接将失效, 硬链接仍保留删除前源文件内容</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></p>
</blockquote>
<h2 id="gzip-bzip2-tar"><a href="#gzip-bzip2-tar" class="headerlink" title="gzip, bzip2, tar"></a>gzip, bzip2, tar</h2><p><img src="/images/Linux-Primer/linux-compress-cmd.png" alt="linux_compress_cmd"></p>
<p>压缩与读压缩命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -v file1    # 压缩为gz格式</span><br><span class="line">bzip2 -z file1   # 压缩为bz2格式</span><br><span class="line"></span><br><span class="line">zcat file1.gz    # 不解压读取gz</span><br><span class="line">bzcat file1.bz2  # 不解压读取bz2</span><br><span class="line"></span><br><span class="line">gzip -d file1.gz   # 解压gz</span><br><span class="line">bzip2 -d file1.bz2 # 解压bz2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意: gzip压缩后不保留源文件, bzip2必须加<code>-k</code>参数才保留源文件</p>
</blockquote>
<p>打包与解包:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar cvzf file1 file1.tar.gz   # 打包为 tar.gz</span><br><span class="line">tar cvjf file1 file1.tar.bz2  # 打包为 tar.bz2</span><br><span class="line"></span><br><span class="line">tar xvzf file1.tar.gz</span><br><span class="line">tar xvjf file1.tar.bz2</span><br></pre></td></tr></table></figure></p>
<h2 id="where-which-locate"><a href="#where-which-locate" class="headerlink" title="where, which, locate"></a>where, which, locate</h2><p>功能和which类似, 也是一种查找, 区别在于locate搜索的是数据库/var/lib/locatedb所以速度更快, 例如<code>locate _vimrc</code></p>
<h2 id="sed-awk"><a href="#sed-awk" class="headerlink" title="sed, awk"></a>sed, awk</h2><p>@Ref 参考 → <a href="https://whatsrtos.github.io/Linux/Linux-Sed_Awk_Grep/">sed &amp; awk &amp; grep</a></p>
<h2 id="find-grep-ack"><a href="#find-grep-ack" class="headerlink" title="find, grep, ack"></a>find, grep, ack</h2><ul>
<li><strong>find</strong>:<ul>
<li>按时间查找, 可用参数有: <code>-mmin</code> 以分钟为单位, <code>-mtime</code> 以天为单位, 后面的数字<code>+</code>表示比该时间更早, <code>-</code>表示该时间之后-当前,<ul>
<li>查找N天之前更早的文件: <code>find . -mtime +3 -name &#39;*.log&#39;</code></li>
<li>查找N天前-当前时刻的文件: <code>find . -mtime -3 -name &#39;*.log&#39;</code></li>
</ul>
</li>
<li>在当前目录及其子目录下查找符号链接文件: <code>find -type l</code></li>
<li>在当前目录及其子目录下查文件夹: <code>find -type d</code></li>
<li>在当前目录查找普通文件: <code>find -type f</code></li>
<li>在root目录下及其最大3层深度的子目录中查找: <code>find / -max-depth 3 -name log</code></li>
<li>查找特定文件并ls列出: <code>find -name *.java -exec ls -l {} \;</code> 注意exec的参数必须以”分号”结束,分号还要加转义符.解释:<ul>
<li><code>{}</code>是前面find找到的文件,</li>
<li><code>-exec</code>后面的参数后面跟的是command命令, 它的终止是以<code>;</code>为结束标志的, 所以这句命令后面的”分号”是不可缺少的, 考虑到各个系统中分号会有不同的意义, 所以前面加反斜杠.  参考 <a href="https://stackoverflow.com/questions/6085156/using-semicolon-vs-plus-with-exec-in-find" target="_blank" rel="noopener">Using semicolon (;) vs plus (+) with exec in find - Stack Overflow</a></li>
<li>shell的内建命令<code>-exec</code>将并不启动新的shell, 而是用要被执行命令替换当前的shell进程, 并且将老进程的环境清理掉, 而且exec命令后的其它命令将不再执行. 以新的进程去代替原来的进程, 但进程的PID保持不变.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>grep</strong>:<ul>
<li>查找某个文件: <code>grep &quot;Invalid user&quot; /var/log/auth.log</code></li>
<li>在某个目录下递归查找: <code>grep -irn &quot;xxx&quot; /dir</code></li>
</ul>
</li>
</ul>
<ul>
<li><strong>ack</strong>:<ul>
<li><code>ack xxxx dir/log1</code>: 在指定文件里搜索xxx</li>
<li><code>ack --java xxxx</code>: 在java文件里搜索xxx</li>
<li><code>ack -i xxx</code>: 不区分大小写</li>
<li><code>ack -w xxx</code>: 全词匹配</li>
</ul>
</li>
</ul>
<h2 id="who-w-whoami-last"><a href="#who-w-whoami-last" class="headerlink" title="who, w, whoami, last"></a>who, w, whoami, last</h2><ul>
<li><code>w</code> - Show who is logged on and what they are doing.</li>
<li><code>who</code> - show who is logged on</li>
<li><code>whoami</code> - print effective userid</li>
<li><code>who am i</code> - When a user logs in as a root across the network, both the command</li>
<li><code>whoami</code> and <code>who am i</code> will show you root. However, when a user abc logs in remotely<br>and runs <code>su – root</code>, <code>whoami</code> will show root whereas <code>who am i</code> will show abc</li>
<li><code>last</code>: 获取每个用户登录的持续时间. 该记录保存在: <code>/var/log/wtmp</code></li>
</ul>
<h2 id="lsof-fuser"><a href="#lsof-fuser" class="headerlink" title="lsof, fuser"></a>lsof, fuser</h2><p><strong>fuser:</strong><br>列出哪个进程在使用文件: <code>fuser /etc/filenames</code></p>
<p><strong>lsof:</strong></p>
<ul>
<li>常用参数:<ul>
<li><code>-p 进程id</code></li>
<li><code>-i :端口号</code></li>
<li><code>-P</code> :  默认情况lsof会显示 “端口名字” 而不是 “数字类型的端口号” （如果此端口号有名字的话）, <code>-P</code>可以指定显示数字端口号, 而不是名字</li>
</ul>
</li>
<li>用法示例:<ul>
<li>查找已被删除但硬盘空间不释放的文件: <code>lsof |grep delete</code>, 这个文件的innode链接被移除了, 但还没有被删掉</li>
<li>某个端口: <code>lsof -i TCP:8080</code> or <code>lsof -i :80</code></li>
<li>某个进程: <code>lsof -p PID</code></li>
<li>查看所有活动状态的网络服务: lsof -i</li>
<li>查看某个用户打开的文件: <code>lsof -u ^root</code>, 或者<code>lsof | grep ^root</code></li>
</ul>
</li>
</ul>
<p>Example: lsof返回数据如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND     PID    USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class="line">init          1    root  cwd       DIR                8,1        4096          2 /</span><br><span class="line">crond      4621    root  txt       REG                8,5       64096     151941 /usr/sbin/crond</span><br><span class="line">crond      4621    root  DEL       REG                8,1                    115 /lib64/libnss_files-2.12.so</span><br><span class="line">nginx     42544    root  194u     unix 0xffff880012b9a080         0t0  510761950 socket</span><br><span class="line">nginx     42544    root  195u     unix 0xffff8800cbb99cc0         0t0  510761952 socket</span><br><span class="line">java      27672    root   66u     IPv4           41351930         0t0        TCP *:56494 (LISTEN)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lsof | awk &#39;{process[$1]++;} END{for(key in process) printf(&quot;%s:%d\n&quot;, key, process[key])}&#39;</code>  #每个进程打开的文件数</li>
<li><code>lsof | awk &#39;{if($8 == &quot;TCP&quot;) opened_tcp++} END{print opened_tcp }&#39;</code>  #打开TCP连接数量</li>
<li><code>lsof | awk &#39;{opened_type[$5]++} END{ for(key in opened_type) printf(&quot;%s : %d\n&quot;, key, opened_type[key])}&#39;</code> #打开文件按TYPE统计</li>
</ul>
<h2 id="du-df-fdisk"><a href="#du-df-fdisk" class="headerlink" title="du, df, fdisk"></a>du, df, fdisk</h2><ul>
<li>du:<ul>
<li>查看当前子目录大小: <code>du -h --max-depth=1</code></li>
<li>当前目录文件按大小排序: <code>du -s * | sort -n | tail</code></li>
</ul>
</li>
</ul>
<h2 id="exec-xargs"><a href="#exec-xargs" class="headerlink" title="-exec, xargs"></a>-exec, xargs</h2><p>xargs的作用一般等同于大多数Unix shell中的反引号, 但更加灵活易用, 并可以正确处理输入中有空格等特殊字符的情况. 对于经常产生大量输出的命令如find、locate和grep来说非常有用: <code>file * |grep ASCII | cut -d&quot;:&quot; -f1 |xargs ls -l</code></p>
<ul>
<li>-exec查找并grep: <code>find . -name &quot;*.php&quot; -exec grep -in &quot;string&quot; {} \;</code> 最后的<code>\;</code>是-exec的结束标识</li>
<li>xargs: <code>find . -name &quot;*.php&quot; | xargs grep -in &quot;string&quot;</code></li>
</ul>
<h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h2><ul>
<li>查看所有的限制: <code>ulimit -a</code><ul>
<li>set 最大打开文件句柄数: <code>ulimit -n 65535</code>, 查看当前值<code>ulimit -n</code></li>
<li>set 最大进程数: <code>ulimit -u 32768</code>, 查看当前值<code>ulimit -u</code></li>
<li>set 线程栈的大小: <code>ulimit -s 10240</code></li>
<li>set core文件大小: <code>ulimit -c xxx</code>, 不限制core的大小: <code>ulimit -c unlimited</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>ulimit起作用的范围是当前Shell, 并不是作用于”当前用户”, 如要对”用户”做限制, 则需要修改系统文件<code>/etc/security/limits.conf</code></p>
</blockquote>
<h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。</p>
<ul>
<li><code>umask 022</code>: 用户权限为755</li>
<li><code>umask 077</code>: 用户权限为700</li>
</ul>
<h2 id="su-sudo"><a href="#su-sudo" class="headerlink" title="su, sudo"></a>su, sudo</h2><p>su:</p>
<ul>
<li><code>su</code>: 切换到root用户, 切换之前的环境变量一并被带到了新shell里;</li>
<li><code>su - user_name</code>:  切换用户, 切换之后的环境变量会改变为新用户的,  <code>su -</code> 同<code>su - root</code><ul>
<li>例: <code>su - root -c commands</code>, 执行完commands之后自动切换会原来的用户.</li>
</ul>
</li>
</ul>
<p>sudo:</p>
<ul>
<li><code>sudo</code>是受限制的su, 两个命令的最大区别是：<code>sudo</code> 命令需要输入当前用户的密码，<code>su</code> 命令需要输入 root 用户的密码。</li>
<li><code>sudo -s cmd</code>: 执行cmd命令, 如果是<code>sudo -s</code>则会启动一个可交互shell, 有点类似<code>su</code>,</li>
<li>通过修改<code>/etc/sudoer</code>配置哪些用户具有执行sudo的权限, sudo命令能继承哪些环境变量也是在<code>/etc/sudoer</code>中配置的.</li>
</ul>
<h2 id="export-amp-环境变量"><a href="#export-amp-环境变量" class="headerlink" title="export &amp; 环境变量"></a>export &amp; 环境变量</h2><ul>
<li><code>VAR=hello</code> $VAR scope is restricted to the shell;</li>
<li><code>export VAR=hello</code> makes the $VAR available to child processes;</li>
</ul>
<p>每个进程的环境变量可以在<code>/proc/$PID/evnrion</code>查看.</p>
<h2 id="sh-exec-source的区别"><a href="#sh-exec-source的区别" class="headerlink" title="sh, exec, source的区别"></a>sh, exec, source的区别</h2><ul>
<li><code>source</code> 和 点命令<code>.</code>是一样的, 不会启动子shell, 不需要script有可执行权限, script里定义的变量也会被导入当前的shell环境.</li>
<li><code>./script</code> 启动子shell, script里的变量不会被带进当前环境, 相当于<code>fork</code>, 需要脚本有x权限</li>
<li><code>sh ./script</code> 先启动了一个子shell, 子shell继承父shell的环境变量, 但子shell里新建变量、改变变量 不会被带回父shell, 除非用<code>export VAR=&quot;xxx&quot;</code></li>
<li><code>exec cmd</code> 产生了新的进程, 新进程会关闭当前shell的进程, 新的进程继承了原shell的PID号, 原shell剩下的内容不会执行,</li>
</ul>
<h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><p>多命令顺序执行:</p>
<ul>
<li>分号（<code>;</code>）： 顺序执行，命令之间不存在关系，互不影响<ul>
<li>例 <code>ls; date; cd /user; pwd</code></li>
</ul>
</li>
<li>逻辑与（<code>&amp;&amp;</code>）： 只有第一条命令成功执行，才会执行第二条命令<ul>
<li>例 <code>cd ~/dir &amp;&amp; git commit -am &quot;u&quot; &amp;&amp; git pull &amp;&amp; git push</code></li>
</ul>
</li>
<li>逻辑或（<code>||</code>）： 第一条成功执行，第二条不执行; 第一条非正确执行，第二条才会执行</li>
</ul>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>并不是所有的程序都像 Nginx, Redis, httpd一样提供守护进程, 保证在关闭终端会话后正常运行.<br>如果终端会话关闭，那么程序也会被关闭。为了能够后台运行，那么我们就可以使用nohup:</p>
<ul>
<li><code>nohup cmd &amp;</code> : 后台运行cmd, 程序运行的输出信息放到当前目录的 nohup.out 文件中去</li>
<li><code>nohup command &gt; myout.log 2&gt;&amp;1 &amp;</code> : 后台运行cmd, 并指定输出的文件</li>
</ul>
<blockquote>
<p>nohup的原理也很简单，终端关闭后会给此终端下的每一个进程发送<code>SIGHUP</code>信号，而使用nohup运行的进程则会忽略这个信号，因此终端关闭后进程也不会退出。</p>
</blockquote>
<h2 id="命令重定向"><a href="#命令重定向" class="headerlink" title="命令重定向"></a>命令重定向</h2><blockquote>
<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件: 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将输出重定向到 file</span></span><br><span class="line">command &gt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将输出追加重定向到 file</span></span><br><span class="line">command &gt;&gt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为n的文件重定向到 file</span></span><br><span class="line"><span class="meta">n&gt;</span><span class="bash">file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为 n 的文件以追加的方式重定向到 file</span></span><br><span class="line"><span class="meta">n&gt;</span><span class="bash">&gt;file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为 m 和 n 的内容合并,注意</span></span><br><span class="line"><span class="meta">n&gt;</span><span class="bash">&amp;m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为 m 和 n 的内容合并, 一并输出到 file</span></span><br><span class="line">command &gt; file m&gt;&amp;n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关 <code>command &gt;out.file  2&gt;&amp;1 &amp;</code> 的解释(注意文件描述符和重定向符号之间不能有空格):<br>最后的<code>&amp;</code> 表示后台运行;<br>为什么是 <code>2&gt;&amp;1</code> 而不是 <code>2&gt;1</code> ? 这样做会直接输出文件名为1的文件;<br><code>&gt;outfile</code> 和 <code>2&gt;&amp;1</code> 的顺序可以交换吗? 不可以, <code>command 2&gt;&amp;1 &gt;out.file</code> ,  先<code>2&gt;&amp;1</code> 的意思是 stderr输出到 stdout, 此时的 stdout是输出到终端的, stderr也就被输出到终端, 然后 <code>&gt;out.file</code>是把 stdout输出到文件, 但是此时 stderr还是输出到终端的;</p>
</blockquote>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 file的内容作为标准输入</span></span><br><span class="line">command &lt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 infile的内容作为标准输入, 标准输出写入 outfile</span></span><br><span class="line">command &lt; infile &gt; outfile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Here Document 式重定向输入, 将定界符（下面例子中的EOF没有特殊含义, 可以自定义界定符）之间的作为stdin</span></span><br><span class="line">command &lt;&lt; EOF</span><br><span class="line">    hello</span><br><span class="line">    world</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
</blockquote>
<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><ul>
<li>创建一个空文件, 除了touch还可 : <code>&gt; file</code></li>
<li>用ssh远程执行本地脚本, 不用scp拷贝 : <code>ssh root@host bash &lt; /local/xxx.sh</code></li>
<li><code>&lt;(COMMAND)</code> 可以作为一个文件 : <code>diff /etc/host &lt;(ssh remote cat /etc/hosts)</code></li>
</ul>
<h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><ul>
<li>脚本内执行<code>java -jar ...</code>命令, 通过<code>$!</code>获得子进程ID</li>
<li>脚本执行<code>wait 子进程ID</code></li>
<li>如下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_term() &#123;</span><br><span class="line">    kill -TERM "$child_pid"</span><br><span class="line">    wait "$child_pid"</span><br><span class="line">&#125;</span><br><span class="line">trap _term SIGTERM</span><br><span class="line"></span><br><span class="line">java -Dspring.profiles.active=test \</span><br><span class="line">     -Dserver.port=9013 \</span><br><span class="line">     -jar wallet-console-2.0.0.jar &amp;</span><br><span class="line"></span><br><span class="line">child_pid=$!</span><br><span class="line">wait "$child_pid"</span><br></pre></td></tr></table></figure>
<h1 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>ping是通过发送ICMP报文(回显请求), 并等待回显请求的应答, 目标主机的防火墙可能对ICMP报文做了限制, 所以ping不通不代表无法ssh.</p>
<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><ul>
<li><p>启动关闭指定网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置IP地址 <code>ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</code></p>
</li>
</ul>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>显示建立的网络连接, 分为三种: tcp/udp/unix(进程通讯)</p>
<ul>
<li><code>netstat -au</code> : 显示所有udp连接</li>
<li><code>netstat -at</code> : 显示所有tcp连接</li>
<li><code>netstat -nlt</code> :<ul>
<li>-n 显示ip而非域名</li>
<li>-l 显示所有listen状态的连接</li>
<li>-p 显示出连接对应的进程, 需要root权限才能看到</li>
</ul>
</li>
<li><code>netstat -r</code> : 显示路由表/网关, 同 route返回的</li>
</ul>
<h2 id="nslookup-dig"><a href="#nslookup-dig" class="headerlink" title="nslookup, dig"></a>nslookup, dig</h2><p>nslookup, dig 都是DNS查询命令:</p>
<ul>
<li><strong>nslookup</strong>: 用于对DNS正向解析 &amp; 返向解析;<ul>
<li><code>nslookup a.xxx.com</code> 使用默认dns查询网址的dns记录</li>
<li><code>nslookup a.xxx.com 8.8.8.8</code> 使用指定dns服务器查询dns记录</li>
</ul>
</li>
<li><strong>dig</strong>: 是一个用于询问DNS 域名服务器的灵活的工具。它执行DNS 查询，显示从已查询名称服务器返回的应答。<ul>
<li><code>dig</code>: 显示13个根域服务器</li>
<li><code>dig www.baidu.com</code>: 使用默认dns查询网址的dns记录</li>
<li><code>dig @8.8.8.8 www.yahoo.com</code>: 使用指定dns服务器查询dns记录</li>
</ul>
</li>
</ul>
<h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><ul>
<li>命令格式 <code>route add 目标网段 gw 网关地址 dev 设备</code></li>
<li>增加默认网关 <code>route add default gw 192.168.0.254</code></li>
<li>增加网关: <code>route add -net 192.168.1.0 netmask 255.255.255.128 gw 192.168.1.129 dev eth0</code></li>
<li>删除网关: <code>route del -net 192.168.1.0 netmask 255.255.255.128 dev eth0</code></li>
<li><p>查看内核路由表: <code>route</code>, 返回如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.6.0     *               255.255.255.0   U     0      0        0 eth0</span><br><span class="line">link-local      *               255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">default         192.168.6.253   0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure>
<ul>
<li>Destination : 目标网段或者主机</li>
<li>Gateway : 网关地址。如果是<code>*</code>表示目标是本主机所属的网络不需要路由</li>
<li>Genmask : 网络掩码</li>
<li>Flags : 标记。一些可能的标记如下：<ul>
<li>U — 路由是活动的</li>
<li>H — 目标是一个主机</li>
<li>G — 路由指向网关</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>例如，在下面的示例中，本地主机将发送到网络192.19.12的数据包转发到IP地址为192.168.1.1的路由器。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Destination    Gateway       Genmask Flags    Metric    Ref     Use    Iface</span><br><span class="line">-----------    -------     -------         -----    -----   ---    ---    -----</span><br><span class="line">192.19.12     192.168.1.1    255.255.255.0      UN      0       0     0    eth0</span><br></pre></td></tr></table></figure>

例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Destination    Gateway       Genmask Flags     Metric    Ref    Use    Iface</span><br><span class="line">-----------    -------     ------- -----      ------    ---    ---    -----</span><br><span class="line">default       192.168.1.1     0.0.0.0    UG       0        0     0    eth0</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><blockquote>
<p>当ping不到或者丢包严重时, 使用traceroute可以看到从当前计算机到目标主机每一跳的耗时情况, 在哪一个节点丢包等细节</p>
</blockquote>
<p>例子:</p>
<ul>
<li><code>traceroute -I a.com</code> : 使用ICMP ECHO</li>
<li><code>traceroute -T a.com</code> : 使用TCP SYN</li>
<li><code>traceroute -p 8080 a.com</code> : 查询到主机指定端口的路由</li>
</ul>
<p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。</p>
<p>linux系统中，我们称之为 <code>traceroute</code>,在MS Windows中为 <code>tracert</code>。</p>
<p>traceroute的工作机制主要是利用使用ICMP报文和和IP首部中的TTL字段来实现的。在网络数据包的传输过程中，每个处理处理数据包的路由器都要讲数据包的TTL值减1或者减去数据报在路由器中停留的秒数，由于大多数的路由器转发数据报的延时都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1。TTL字段的目的是防止数据报在网络中无休止的流动。当路由器收到一份IP数据报，如果TTL字段是0或者1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是，在通常情况下系统不应该接收TTL字段为0的数据报）。通常情况下是，路由器将该数据报丢弃，并给信源主机发送一份ICMP超时信息。tracerouter程序的关键在于，这份ICMP超时信息包含了该路由器的地址。<br>tracerouter利用网络协议的这种机制，TTL值从1开始每次发送一个TTL等于上次值加一的数据包，直到收到目的主机的响应才停止。这样就能拿到数据包经过路径上的每个路由器的地址信息，从而打印路由信息。<br>有些情况下traceroute无法到达最终节点(traceroute一台主机时，会看到有一些行是以星号表示的) 有可能因为主机屏蔽了ICMP回显, 对于有HTTP服务的服务器, 可以使用-p 指定端口使用TCP协议进行探测<code>traceroute -T -p 80 a.xxx.com</code> (在 macOS上好像不支持-T)</p>
<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>探测远端机器端口 <code>nmap 192.168.1.1 -p 80</code></p>
<h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><ul>
<li>接受文件: <code>nc -4 -l -p local_port &gt; file</code> 说明:  <code>-4</code>是指IPv4, 如果默认<code>-6</code>有问题就试试这个, <code>-l</code>=listen, <code>-p</code>=port</li>
<li>发送文件: <code>nc dest_ip dest_port &lt; file</code></li>
</ul>
<h2 id="网卡吞吐量-Throughput"><a href="#网卡吞吐量-Throughput" class="headerlink" title="网卡吞吐量(Throughput)"></a>网卡吞吐量(Throughput)</h2><p><img src="/images/Linux-Primer/Linux-Net-Throughput-A-Day.png" alt=""></p>
<h3 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h3><p><img src="/images/Linux-Primer/Linux-Net-Throughput-Iftop.png" alt=""></p>
<p>iftop底部会显示一些全局的统计数据，peek 是指峰值情况，cumm 是从运行至今的累计情况，而 rates 表示最近 2 秒、10 秒、40 秒内总共接收或者发送的平均网络流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TX:  cumm:   143MB   peak:   10.5Mb    rates:   1.03Mb  1.54Mb  2.10Mb</span><br><span class="line">RX:          12.7GB          228Mb              189Mb   191Mb   183Mb</span><br><span class="line">TOTAL:       12.9GB          229Mb              190Mb   193Mb   185MbW</span><br></pre></td></tr></table></figure>
<h3 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h3><ul>
<li>server: <code>iperf -s</code></li>
<li>client: <code>iperf -c 192.168.0.138 -t 60 -l 8k -i 10</code> #进行60秒测试, 缓冲区大小8k, 每10秒打印一次结果</li>
</ul>
<blockquote>
<p>测试阿里云服务器大约67.5 Mbits/sec, 似乎是Mac无线网卡的限制…内网的两台服务器测试(非同一机房) 450 Mbits/sec</p>
</blockquote>
<h3 id="netperf"><a href="#netperf" class="headerlink" title="netperf"></a>netperf</h3><ul>
<li>server端: <code>netserver</code></li>
<li>client端测试tcp: <code>./netperf -t TCP_STREAM -H 192.168.0.138 -l 60 -- -m 2048</code> # 测试时长60秒, 发送分组大小2048 Bytes</li>
<li>client端测试udp: <code>./netperf -t UDP_STREAM -H 192.168.0.138 -l 60 -- -m 2048</code></li>
</ul>
<h1 id="常用配置文件"><a href="#常用配置文件" class="headerlink" title="常用配置文件"></a>常用配置文件</h1><h2 id="性能-amp-并发相关"><a href="#性能-amp-并发相关" class="headerlink" title="性能 &amp; 并发相关"></a>性能 &amp; 并发相关</h2><p>@Ref 参考 → <a href="https://whatsrtos.github.io/基础架构/Arch-架构-并发系统-C100K/">并发(C10K, C100K)</a></p>
<h2 id="profile相关"><a href="#profile相关" class="headerlink" title="profile相关"></a>profile相关</h2><blockquote>
<ol>
<li>bashrc是在系统启动后就会自动运行。</li>
<li>profile是在用户登录后才会运行。</li>
<li>进行设置后，可运用source bashrc命令更新bashrc，也可运用source profile命令更新profile。</li>
</ol>
</blockquote>
<ul>
<li>/etc/profile: 中设定的变量(全局)的可以作用于任何用户</li>
<li>~/.bashrc: 等中设定的变量(局部)只能继承/etc/profile中的变量</li>
<li>~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li>
</ul>
<h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><ul>
<li>/etc/sudoers</li>
<li>/etc/hosts.allow: 限制SSH的客户端IP, /etc/hosts.allow 的设定优先于 /etc/hosts.deny</li>
<li>/etc/hosts.deny: 限制SSH的客户端IP</li>
</ul>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul>
<li><p>/etc/resolv.conf: 这个文件是用于配置DNS服务器的, 扩展阅读: <a href="http://mydf.github.io/blog/ubuntu-dnsmasq/" target="_blank" rel="noopener">Ubuntu使用dnsmasq作本地DNS缓存</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>/etc/hosts: 设置主机名和IP地址绑定</p>
</li>
<li>/etc/hostname: 主机名配置</li>
<li>/etc/sysconfig/network: 主机名和网关<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NETWORK=yes    #网络是否被配置</span><br><span class="line">RORWARD_IPV4=yes    #是否开启IP转发功能</span><br><span class="line">HOSTNAME= localhost.localdomain   #表示服务器的主机名</span><br><span class="line">GAREWAY=192.168.0.1    #表示网络网关的IP地址</span><br><span class="line">GATEWAYDEV=eth0    #网关的设备名，即选择使用哪个网卡</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h1><ul>
<li>CPU的指令分为特权级指令和非特权级指令, 特权级指令通常是一些比较危险的指令, Intel X86架构的CPU将特权等级分为4个级别：<code>RING0</code>,<code>RING1</code>,<code>RING2</code>,<code>RING3</code>. 操作系统通过区分用户态和内核态来保证特权级指令不被错误的使用.</li>
<li>Linux仅仅使用了RING0和RING3来分别运行内核态和用户态.</li>
</ul>
<h2 id="用户态到内核态的切换"><a href="#用户态到内核态的切换" class="headerlink" title="用户态到内核态的切换"></a>用户态到内核态的切换</h2><ol>
<li>普通程序进行系统API调用时主动要求切换到内核态, 此时用户态进程要向内核态传递参数, 同时保存用户进程的寄存器、变量等, 以便切换回来时能正确继续执行, 这个过程就是进程 <strong>上下文切换</strong>, 过程如下:<ul>
<li>保存 CPU 寄存器里原来用户态的指令位</li>
<li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置</li>
<li>跳转到内核态运行内核任务</li>
<li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</li>
<li>一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）</li>
</ul>
</li>
<li>异常事件：当CPU在执行运行在用户态下的程序时, 发生了某些事先不可知的异常, 这时会触发由当前运行进程切换到处理此异常的内核相关程序中, 也就转到了内核态, 比如缺页异常.</li>
<li>硬件中断:当外围设备完成用户请求的操作后, 会向CPU发出相应的中断信号, 这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序, 如果先前执行的指令是用户态下的程序, 那么这个转换的过程自然也就发生了由用户态到内核态的切换</li>
</ol>
<p><img src="/images/Linux-Primer/linux_system_call.png" alt=""></p>
<p>参考: <a href="https://www.ibm.com/developerworks/cn/linux/l-system-calls/index.html" target="_blank" rel="noopener">使用 Linux 系统调用的内核命令</a> @Ref</p>
<h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="I-O相关概念"><a href="#I-O相关概念" class="headerlink" title="I/O相关概念"></a>I/O相关概念</h2><h3 id="缓存IO-Buffer-IO"><a href="#缓存IO-Buffer-IO" class="headerlink" title="缓存IO(Buffer IO)"></a>缓存IO(Buffer IO)</h3><ul>
<li><strong>缓存I/O</strong> 又被称作 <strong>标准I/O</strong> ，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。<ul>
<li>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</li>
<li>写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</li>
<li>缓存I/O的优点：1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；2）可以减少读盘的次数，从而提高性能。</li>
<li>缓存I/O的缺点：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</li>
</ul>
</li>
</ul>
<h3 id="直接IO-Direct-IO"><a href="#直接IO-Direct-IO" class="headerlink" title="直接IO(Direct IO)"></a>直接IO(Direct IO)</h3><ul>
<li><strong>直接I/O</strong> 就是应用程序直接访问磁盘数据，而不经过内核缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。比如说数据库管理系统这类应用，它们更倾向于选择它们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。<ul>
<li>直接IO的缺点：如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，这种直接加载会非常缓存。通常直接IO与异步IO结合使用，会得到比较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）</li>
</ul>
</li>
</ul>
<h3 id="缓存IO-vs-直接IO"><a href="#缓存IO-vs-直接IO" class="headerlink" title="缓存IO vs 直接IO"></a>缓存IO vs 直接IO</h3><p>写场景下的DirectIO和BufferIO:<br><img src="/images/Linux-Primer/Linux-DirectIO-vs-BufferIO.png" alt=""></p>
<h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a>五种I/O模型</h2><ol>
<li><strong>阻塞IO</strong>: 调用read, 如果内核数据未就绪, 调用read的进程进入阻塞状态。应用程序调用一个IO函数，导致应用程序阻塞并等待数据准备就绪。如果数据没有准备好，一直等待。如果数据准备好了，则从内核拷贝到用户空间拷贝数据，IO函数返回成功指示。<br><img src="/images/Linux-Primer/Linux-IO-Blocked.png" alt=""></li>
<li><strong>非阻塞IO</strong>: nonblocking IO的特点是用户进程需要不断的主动询问kernel数据是否准备好. 当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试 数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。<br><img src="/images/Linux-Primer/Linux-IO-NonBlocking.png" alt=""></li>
<li><strong>多路复用IO</strong>: 复用模型会用到select或者poll函数，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。从而使得系统在单线程的情况下可以同时处理多个客户端请求. 与传统的多线程/多进程模型比, I/O多路复用的最大优势是系统开销小。<br>和阻塞IO模型相比，selectI/O复用模型相当于提前阻塞了。等到有数据到来时，再调用recv就不会因为要等数据就绪而发生阻塞。<ul>
<li>select: 一般采用select + no-block, select返回后要遍历所有阻塞在select上的IO句柄，找到数据就绪的那一个IO句柄后, 应用程序调用recvfrom将数据从内核区拷贝至用户区；</li>
<li>epoll : 比select更高效，无需轮询全部句柄，epoll只返回数据ready的IO句柄<br><img src="/images/Linux-Primer/Linux-IO-Multiplexing.png" alt=""></li>
</ul>
</li>
<li><strong>信号驱动IO</strong>：让内核在数据就绪时用信号SIGIO通知我们，将此方法称为信号驱动I/O。首先，我们允许套接字进行信号驱动I/O，并通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的。当数据报准备好被读时，就为该进程生成一个SIGIO信号。我们随即可以在信号处理程序中调用 recvfrom 来取读数据报。</li>
<li><strong>异步IO</strong>: 我们让内核启动操作，并在整个操作完成后（包括将数据从内核拷贝到我们自己的缓冲区）通知我们。<br>调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。<br>上面其它四种模型，至少都会在由kernel copy data to appliction时阻塞。而该模型是当copy完成后才通知application，可见是纯异步的。<br>很少有<code>*nix</code>系统支持，windows的IOCP（完成端口）则是此模型<br><img src="/images/Linux-Primer/Linux-IO-Async.png" alt=""></li>
</ol>
<h2 id="高性能I-O设计模式"><a href="#高性能I-O设计模式" class="headerlink" title="高性能I/O设计模式"></a>高性能I/O设计模式</h2><p><strong>I/O多路复用模式：Reactor &amp; Proactor</strong></p>
<p>  一般地,I/O多路复用机制（I/O multiplexing mechanisms）都依赖于一个事件多路分离器(Event Demultiplexer)。<br>我们常见的事件多路分用器包括：Linux 的 epoll 和 Windows 的 IOCP。</p>
<p>  <em>事件多路分离器</em>（Event Demultiplexer）可将来自事件源的I/O事件分离出来，并分发到对应的 <em>事件处理器</em> (Event Handler)进行read/write。<br>开发人员预先注册需要处理的事件及其事件处理器（或回调函数），<em>事件多路分离器</em> 负责将请求事件传递给 <em>事件处理器</em> 。<br>两个与事件分离器有关的模式是Reactor和Proactor，Reactor模式采用同步IO，而Proactor采用异步IO。</p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>在Reactor中，<em>事件多路分离器</em> 等待文件描述符状态变为 读写操作准备就绪状态，然后将就绪事件传递给对应的 <em>处理器</em>，最后由 <em>处理器</em> 负责完成实际的读写工作。</p>
<p>Linux epoll使用Reactor模式，Reactor模式使用同步 I/O（一般来说）。Reactor的标准（典型）的工作方式是：</p>
<ul>
<li>Reactor线程中, epoll 注册读/写等等事件</li>
<li>epoll 等待事件到来</li>
<li>事件到来，Reactor把事件分发给处理器(往往使用线程池跑处理器)</li>
<li>处理器线程: 读写数据（调用read/write, 从内核buff将数据拷贝到用户态buff)</li>
<li>处理器线程进行处理(decode数据, 执行业务代码, encode数据)</li>
</ul>
<blockquote>
<p>与 Proactor 模式相比，Reactor 模式下，用户代码的责任是, 在收到可读写事件后进行实际的 I/O 操作。</p>
</blockquote>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>而在Proactor模式中，<em>处理器</em>，只负责发起异步读写操作。 <em>处理器</em> 传递给操作系统的参数需要包括 <em>用户定义的数据缓冲区地址</em> 和 <em>数据大小</em>，IO操作本身由操作系统来完成。<br>当可读写时, 操作系统完成从 <em>内核缓冲区</em> 和 <em>用户定义的数据缓冲区地址</em> 之间的数据拷贝。系统发出IO操作完成事件，由 <em>事件分离器捕获</em>，然后将事件传递给对应 <em>处理器</em>。<br>比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。IOCompletion通知的时候, 数据已经被拷贝到处理器的buff了.<br>典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。</p>
<p>Windows IOCP使用Proactor模式，Proactor模式使用异步 I/O。Proactor的标准（典型）的工作方式是：</p>
<ul>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分离器等待操作完成事件</li>
<li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li>
<li>事件分离器呼唤处理器。</li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li>
</ul>
<blockquote>
<p>Proactor 模式下，用户在调用异步 I/O 时会传递一个 Buffer 给系统，系统进行实际的 I/O 操作并从传递给系统的 Buffer 中获取或者放入数据。</p>
</blockquote>
<p>以上参考: <a href="https://blog.csdn.net/robinjwong/article/details/50117091" target="_blank" rel="noopener">Reactor VS Proactor 模式</a> @Ref</p>
<h3 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h3><h4 id="比较实现"><a href="#比较实现" class="headerlink" title="比较实现"></a>比较实现</h4><ul>
<li>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</li>
<li>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</li>
</ul>
<p>以主动写为例：</p>
<ul>
<li>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；</li>
<li>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</li>
</ul>
<h4 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h4><p><strong>√ Reactor优势</strong></p>
<ul>
<li>Reactor实现相对简单，对于耗时短的处理场景处理高效；</li>
<li>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；</li>
<li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</li>
<li>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</li>
</ul>
<p><strong>× Reactor劣势</strong></p>
<ul>
<li>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</li>
</ul>
<p><strong>√ Proactor优势</strong></p>
<ul>
<li>Proactor性能更高，能够处理耗时长的并发场景；</li>
</ul>
<p><strong>× Proactor劣势</strong></p>
<ul>
<li>Proactor依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，比较优秀的如windows IOCP（完成端口），但由于其windows系统用于服务器的局限性，目前应用范围较小；<br>而Unix/Linux系统对纯异步的支持尚不成熟，应用事件驱动的主流还是通过select/epoll来实现；</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；</li>
<li>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</li>
</ul>
<h4 id="在实际工程中的使用"><a href="#在实际工程中的使用" class="headerlink" title="在实际工程中的使用"></a>在实际工程中的使用</h4><ul>
<li>Reactor: libevent / libev /libuv / ZeroMQ / Event Library in Redis</li>
<li>Proactor: Windows IOCP / Boost.Asio</li>
</ul>
<h2 id="select-vs-poll-vs-epoll"><a href="#select-vs-poll-vs-epoll" class="headerlink" title="select vs poll vs epoll"></a>select vs poll vs epoll</h2><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code></p>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。<br>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>int epoll_create(int size);</code><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
</li>
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code><br>函数是对指定描述符fd执行op操作。</p>
</li>
</ol>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事件</li>
</ul>
<ol start="3">
<li><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>
</ol>
<h4 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h4><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h3 id="本章参考"><a href="#本章参考" class="headerlink" title="本章参考"></a>本章参考</h3><ul>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a> @Ref</li>
</ul>
<blockquote>
<p>所谓同步，数据从存储介质拷贝到内核缓冲区（数据准备的过程）完成之后，需要用户自己将数据拷贝到用户缓冲区。所以，前4种IO模型都是同步的</p>
</blockquote>
<p>Linux I/O 模型的发展技术是： select -&gt; poll -&gt; epoll -&gt; aio -&gt; libevent -&gt; libuv。另外还有 Windows的 Completion Port。</p>
<blockquote>
<p>提供一致的接口，IO Design Patterns<br>实际上，不管是哪种模型，都可以抽象一层出来，提供一致的接口，广为人知的有ACE,Libevent这些，他们都是跨平台的，而且他们自动选择最优的I/O复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，Reactor and Proactor。有一篇经典文章<a href="http://www.artima.com/articles/io_design_patterns.html值得阅读，Libevent是Reactor模型，ACE提供Proactor模型。实际都是对各种I/O复用机制的封装。" target="_blank" rel="noopener">http://www.artima.com/articles/io_design_patterns.html值得阅读，Libevent是Reactor模型，ACE提供Proactor模型。实际都是对各种I/O复用机制的封装。</a></p>
</blockquote>
<h2 id="常用软件的并发处理"><a href="#常用软件的并发处理" class="headerlink" title="常用软件的并发处理"></a>常用软件的并发处理</h2><ul>
<li>Nginx:<ul>
<li>基于epoll监听多个连接(50000个并发连接数的响应), 当某个连接有数据准备好的时候再通知, 这样一个进程能处理多个连接</li>
<li>大于5k并发的时候, Nginx才明显比apache有更好的表现</li>
</ul>
</li>
<li>Redis<ul>
<li>Redis使用单线程的I/O复用模型, 自己封装了一个简单的AeEvent事件处理框架, 主要实现了epoll、kqueue和select.</li>
<li>优势: 对于单纯只有I/O操作来说, 单线程可以将速度优势发挥到最大.</li>
<li>缺陷：Redis排序、聚合等, 对于这些操作, 单线程模型实际会严重影响整体吞吐量, CPU计算过程中, 整个I/O调度都是被阻塞住的</li>
</ul>
</li>
<li>Apache: 默认是每个请求启动一个线程处理, 并不适合高并发<ul>
<li>缺陷:<ul>
<li>有多少并发就需要多少进程, 最大进程数</li>
<li>在进程创建很多的情况下, 系统切换进程的代价很高, 进程运行的时间很少</li>
<li>实际上本机处理数据的时间很短, 大多数时间都是在”等待数据准备好”的阶段, 效率低</li>
</ul>
</li>
<li>新版的Apache的改进, 支持多种MPM(Multi-Processing Model)<ul>
<li>prefork: 古老</li>
<li>worker: 多进程(注意并不是每个请求一个线程), 每个进程多个线程</li>
<li>event: epoll</li>
</ul>
</li>
</ul>
</li>
<li>Tomcat: 每个请求启动一个线程处理<ul>
<li>Tomcat 从 JDK 1.6支持开始支持NIO</li>
</ul>
</li>
</ul>
<h3 id="多线程-vs-多进程"><a href="#多线程-vs-多进程" class="headerlink" title="多线程 vs 多进程"></a>多线程 vs 多进程</h3><ul>
<li>多进程方式：为每个请求启动一个进程来处理.<ul>
<li>优点: 进程之间是独立的, 单个进程问题不会影响其他进程</li>
<li>缺点: 切换进程代价较大, 而且进程间资源是独立的, 造成内存重复利用</li>
</ul>
</li>
<li>多线程<ul>
<li>优点: 线程间部分数据是共享的, 线程间的切换所需资源开销比进程间切换小得多</li>
</ul>
</li>
</ul>
<h1 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h1><h2 id="32位"><a href="#32位" class="headerlink" title="32位:"></a>32位:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  0xFFFFFFFF 高地址</span><br><span class="line"> +---+--------------------+</span><br><span class="line">1 GB |   Kernel           |</span><br><span class="line"> +------------------------+</span><br><span class="line"> |   | Random stack offset|</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   |   Stack↓           |  进程中的所有的线程共享相同的地址空间</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   |                    |</span><br><span class="line"> |   |                    |</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Mem Mapping        | 文件映射,so库文件等</span><br><span class="line"> |   |                    | mmap()</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> +   |                    |</span><br><span class="line">3 GB |                    |</span><br><span class="line"> +   +--------------------+</span><br><span class="line"> |   |    Heap↑           | malloc()</span><br><span class="line"> |   |                    | brk()</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Random stack offset|</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | BSS Seg.           |</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Data Seg. (+rodata)|</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Text Seg.          |</span><br><span class="line"> +---+--------------------+</span><br><span class="line">  0x00000000 低地址</span><br></pre></td></tr></table></figure>
<p>内存布局从高地址到低地址:</p>
<ul>
<li><code>Kernel</code>: 内核空间在页表中拥有较高的特权级（ring 2或以下）, 因此只要用户态的程序试图访问这些页, 就会导致一个页错误（page fault）, 用户程序不可访问内核页</li>
<li><code>Stack</code>: 自高地址向低地址增长, 每个进程都有一个自己的栈, 当不断压栈直到超过了最大的栈空间, 将会引起Stack Overflow, 进程中的每一个线程都有属于自己的栈</li>
<li><code>Memory Mapping Segment</code>: mmap()实现”文件-内存映射”, 它被用于加载动态库, 大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域, 这个区域自高地址向低地址增长</li>
<li><code>Heap</code>: malloc()分配的内存空间, 如果堆中有足够的空间来满足内存请求, 它就可以被语言运行时库处理而不需要内核参与. 否则堆会被扩大, 通过<code>brk()</code>系统调用来分配请求所需的内存块, 堆自低地址向高地址增长</li>
<li><code>BSS Segment</code>: 未赋初始值的static变量, 包括全局的static变量和函数内定义的static变量(全局变量默认就是static)</li>
<li><code>Data Segment</code>: 有初始值的static变量, 程序bin映像的一部分<ul>
<li>还包括一个叫<code>rodata</code>的区域, 存储”字面量字符串”(包括全局/局部定义的字面量字符串), 以及”const常量”</li>
</ul>
</li>
<li><code>Text Segment</code>: 这里存放的是二进制代码</li>
</ul>
<p>更详细的解释参考@Ref: <a href="https://whatsdjgpp.github.io/%E6%97%A7%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/blog_archive/Coding/[C]%20GNU%E7%9A%84obj%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8(nm,%20objdump" target="_blank" rel="noopener">GNU的obj分析工具的使用(nm, objdump) | 扔掉笔记</a>/)</p>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位:"></a>64位:</h2><blockquote>
<p>64位架构下内存布局与32位类似, 可寻址64TB(Intel架构下是46个地址线, 2^46)</p>
</blockquote>
<p><img src="/images/Linux-Primer/64bit_linux_memory.png" alt="64bit_linux_memory"></p>
<h3 id="How-to-查看某个进程的内存分布"><a href="#How-to-查看某个进程的内存分布" class="headerlink" title="How to 查看某个进程的内存分布"></a>How to 查看某个进程的内存分布</h3><ul>
<li><code>cat /proc/xxx/maps</code></li>
</ul>
<h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><p>内存寻址(Memory Addressing):<br>分段机制把<code>逻辑地址</code>转换为<code>线性地址</code>, 分页机制进一步把该<code>线性地址</code>再转换为<code>物理地址</code>.</p>
<h2 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h2><blockquote>
<p>内存可寻址范围总是跟”地址总线宽度”和”寄存器宽度”相关</p>
</blockquote>
<h3 id="实模式的诞生（16位处理器及寻址）"><a href="#实模式的诞生（16位处理器及寻址）" class="headerlink" title="实模式的诞生（16位处理器及寻址）"></a>实模式的诞生（16位处理器及寻址）</h3><ul>
<li>在8086处理器诞生之前, 内存寻址方式就是直接访问物理地址. 8086处理器为了寻址1M的内存空间, 把地址总线扩展到了20位. 但是, 一个尴尬的问题出现了, ALU的宽度只有16位, 也就是说, ALU不能计算20位的地址. 为了解决这个问题, 分段机制被引入</li>
<li>为了支持分段, 8086处理器设置了四个段寄存器：CS, DS, SS, ES每个段寄存器都是16位的, 同时访问内存的指令中的地址也是16位的.<ul>
<li>在送入地址总线之前(20位), 要将端寄存器(16位)的值与内存地址(16位, 即段内偏移值)相加</li>
<li>端寄存器的值左移4位, 低位补0, 然后加上内存地址</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">|       20        |  20位地址总线</span><br><span class="line">+-----------------+</span><br><span class="line">+------------+</span><br><span class="line">|      16    |       16位段地址</span><br><span class="line">+------------+</span><br><span class="line">    +-------------+</span><br><span class="line">    |    12  | 4  |  16位内存地址（段内偏移量）</span><br><span class="line">    +--------+----+</span><br><span class="line"></span><br><span class="line">实际物理地址 = （段寄存器地址 &lt;&lt; 4） + （CPU 提交的访存地址）</span><br></pre></td></tr></table></figure>
<h3 id="保护模式的诞生（32位处理器及寻址）"><a href="#保护模式的诞生（32位处理器及寻址）" class="headerlink" title="保护模式的诞生（32位处理器及寻址）"></a>保护模式的诞生（32位处理器及寻址）</h3><ul>
<li>80286处理器的地址总线为24位, 寻址空间达16M, 同时引入了保护模式（内存段的访问受到限制）</li>
<li>80386处理器是一个32位处理器, ALU和地址总线都是32位的, 寻址空间达 4G. 也就是说它可以不通过分段机制, 直接访问4G的内存空间. 但它必须支持实模式和保护模式. 所以, 80386在段寄存器的基础上构筑保护模式, 并且保留16位的段寄存器.</li>
<li>从80386之后的处理器, 架构基本相似, 统称为IA32（32 Bit Intel Architecture）.</li>
</ul>
<h3 id="IA32的内存寻址机制"><a href="#IA32的内存寻址机制" class="headerlink" title="IA32的内存寻址机制"></a>IA32的内存寻址机制</h3><h4 id="IA32的三种地址"><a href="#IA32的三种地址" class="headerlink" title="IA32的三种地址"></a>IA32的三种地址</h4><ul>
<li>逻辑地址: 每个逻辑地址都由一个”段的选择符”和”偏移量组成”. IA32中有六个16位段寄存器</li>
<li>线性地址：线性地址是一个32位的无符号整数, 可以表达高达2^32（4GB）的地址. 通常用16进制表示线性地址, 其取值范围为0x00000000～0xffffffff.</li>
<li>物理地址：也就是内存单元的实际地址, 用于芯片级内存单元寻址.  物理地址也由32位无符号整数表示.</li>
</ul>
<h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>MMU是一种硬件电路, 它包含两个部件, 一个是分段部件, 一个是分页部件, 在此, 我们把它们分别叫做分段机制和分页机制, 内存寻址分两个步骤:<br>分段机制把一个逻辑地址转换为线性地, 接着, 分页机制把一个线性地址转换为物理地址.</p>
<h4 id="IA32的段寄存器"><a href="#IA32的段寄存器" class="headerlink" title="IA32的段寄存器"></a>IA32的段寄存器</h4><p>IA32中有六个段寄存器(16 bit)：CS, DS, SS, ES, FS, GS.<br>跟8086的段寄存器不同的是, 这些寄存器存放的不再是某个段的基地址, 而是某个段的选择符（Selector）.</p>
<h3 id="IA32-硬件-分段机制的实现"><a href="#IA32-硬件-分段机制的实现" class="headerlink" title="IA32(硬件)分段机制的实现"></a>IA32(硬件)分段机制的实现</h3><h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>段是虚拟地址空间的基本单位, <strong>段描述符</strong> 是一个8字节的数据结构, 包括以下几个属性:</p>
<ul>
<li>段的界限(Limit)：在虚拟地址空间中, 段内可以使用的最大偏移量.</li>
<li>段的基地址(Base Address)：在线性地址空间中段的起始地址.</li>
<li>段的保护属性(Attribute)：表示段的特性. 例如, 该段是否可被读出或写入, 或者该段是否作为一个程序来执行, 以及段的特权级等等.</li>
</ul>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/segment_descriptor.png" alt="IA32的一个通用的段描述符的结构"></p>
<h4 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h4><p>描述符表(即段表)定义了IA32系统的所有段的情况. 所有的描述符表本身都占据一个字节为8的倍数的存储器空间, 空间大小在8个字节(至少含一个描述符)到64K字节(至多含8K)个描述符之间.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>IA32的内存寻址机制完成从逻辑地址–线性地址–物理地址的转换. 其中, 逻辑地址的段寄存器中的值提供段描述符, 然后从段描述符中得到段基址和段界限, 然后加上逻辑地址的偏移量, 就得到了线性地址, 线性地址通过分页机制得到物理地址.<br>首先, 我们要明确, 分段机制是IA32提供的寻址方式, 这是硬件层面的. 就是说, 不管你是windows还是linux, 只要使用IA32的CPU访问内存, 都要经过MMU的转换流程才能得到物理地址, 也就是说必须经过逻辑地址–线性地址–物理地址的转换.</p>
<h3 id="Linux系统-软件-分段机制的实现"><a href="#Linux系统-软件-分段机制的实现" class="headerlink" title="Linux系统(软件)分段机制的实现"></a>Linux系统(软件)分段机制的实现</h3><p>Linux基本不使用分段的机制, 或者说, Linux中的分段机制只是为了兼容IA32的硬件而设计的.</p>
<p>在 IA32 上任意给出的地址都是一个虚拟地址, 即任意一个地址都是通过<code>选择符:偏移量</code>的方式给出的, 这是段机制存访问模式的基本特点.<br>所以在IA32上设计操作系统时无法回避使用段机制. 一个虚拟地址最终会通过<code>段基地址＋偏移量</code>的方式转化为一个线性地址.<br>但是, 由于绝大多数硬件平台都不支持段机制, 只支持分页机制, 所以为了让 Linux 具有更好的可移植性, 我们需要去掉段机制而只使用分页机制. 但不幸的是, IA32规定段机制是不可禁止的, 因此不可能绕过它直接给出线性地址空间的地址.<br>万般无奈之下, Linux的设计人员干脆让段的基地址为0, 而段的界限为4GB, 这时任意给出一个偏移量, 则等式为<code>0+偏移量=线性地址</code>, 也就是说“偏移量＝线性地址”. 另外由于段机制规定“偏移量&lt;4GB”, 所以偏移量的范围为0H～FFFFFFFFH, 这恰好是线性地址空间范围, 也就是说虚拟地址直接映射到了线性地址, 我们以后所提到的虚拟地址和线性地址指的也就是同一地址. 看来, Linux在没有回避段机制的情况下巧妙地把段机制给绕过去了.</p>
<h4 id="特权等级-CPU-Rings-和分段机制"><a href="#特权等级-CPU-Rings-和分段机制" class="headerlink" title="特权等级(CPU Rings)和分段机制"></a>特权等级(CPU Rings)和分段机制</h4><p>由于IA32段机制还规定, 必须为代码段和数据段创建不同的段, 所以Linux必须为代码段和数据段分别创建一个基地址为0, 段界限为4GB的段描述符.<br>不仅如此, 由于Linux内核运行在特权级0, 而用户程序运行在特权级别3, 根据IA32段保护机制规定, 特权级3的程序是无法访问特权级为0的段的,<br>所以Linux必须为内核用户程序分别创建其代码段和数据段. 这就意味着Linux <strong>必须创建4个段描述符: 特权级0的代码段和数据段, 特权级3的代码段和数据段</strong></p>
<blockquote>
<p>存疑: 在Ring0和Ring3的, 相同的的逻辑地址, 是对应不同的线性地址 [?]</p>
</blockquote>
<p>@Ref 参考: <a href="http://blog.xiaohansong.com/2015/10/03/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Linux内存寻址之分段机制 | ShareHub</a></p>
<h2 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h2><h3 id="硬件分页"><a href="#硬件分页" class="headerlink" title="硬件分页"></a>硬件分页</h3><ul>
<li>分页机制在段机制之后进行, 以完成线性—物理地址的转换过程. 段机制把逻辑地址转换为线性地址, 分页机制进一步把该线性地址再转换为物理地址.</li>
<li>分页机制管理的对象是固定大小的存储块, 称之为页(page). 分页机制把整个线性地址空间及整个物理地址空间都看成由页组成, 在线性地址空间中的任何一页, 可以映射为物理地址空间中的任何一页, 我们把物理空间中的一页叫做页框(page frame)</li>
<li>80386使用4K(0xFFF)字节大小的页. 每一页都有4K字节长, 并在4K字节的边界上对齐(即每一页的起始地址都能被4K整除). 因此, 80386把最大可寻址4G字节的线性地址空间划分为1M个Page</li>
</ul>
<blockquote>
<p>线性地址的page, 与物理地址的page是多对一的关系, 也就是两个不同线性地址页, 可能指向同一个物理地址页</p>
</blockquote>
<h3 id="两级分页"><a href="#两级分页" class="headerlink" title="两级分页"></a>两级分页</h3><ul>
<li>页目录(Page Directory): 两级表结构的第一级称为<code>页目录</code>, 页目录占用4K字节, 正好一个页面. 页目录表共有1K个表项, 每个表项为4个字节, 这4字节是指向二级页表的地址.<ul>
<li>线性地址的最高10位用来作为第一级的索引(所以共2^10=1K个索引)</li>
</ul>
</li>
<li>页表(Page Table): 两级表结构的第二级称为<code>页表</code>, 也刚好存储在一个4K字节的页面中, 包含1K个字节的表项, 每个表项包含一个页的物理基地址.<ul>
<li>线性地址的中间10位用来作为第二级的索引进行索引,</li>
<li>以获得包含页的物理地址的页表项, 这个物理地址的高20位与线性地址的低12位形成了最后的物理地址, 也就是页转化过程输出的物理地址.</li>
</ul>
</li>
</ul>
<p>[未整理完]</p>
<p>@Ref 参考: <a href="http://blog.xiaohansong.com/2015/10/05/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/index.html" target="_blank" rel="noopener">Linux内存寻址之分页机制 | ShareHub</a></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul>
<li>返回0: 子进程</li>
<li>返回&gt;0: 父进程, 返回值是子进程pid</li>
<li>子进程会得到父进程的堆(IO缓存, malloc的内存)、栈(局部变量)、数据空间(Data Segment)的拷贝, 在子进程里修改这些变量并不会影响父进程中的值, 注意这种拷贝是“写时复制”（Copy On Write，COW）;</li>
<li>fork前打开的文件句柄, 其偏移量会在父子进程间共享, 原因是进程内存中仅保存了文件句柄的fd指针, 指针指向的结构体(也就是文件表,保存了文件标准和位移)是共享的. @Uncertain 那么”文件表”是存储在哪里的?</li>
<li>另外需要注意的是, 因为堆内存也将被拷贝(IO缓存在堆里), 所以如果在创建子进程之前这个IO缓存中就有数据, 那么也会带入子进程, 导致子进程的IO缓存里”多”出一些数据.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// child process because return value zero</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello from Child!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parent process because return value non-zero.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello from Parent!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><ul>
<li>返回值同 fork</li>
<li>不同点1: vfork创建的子进程与父进程共享数据段, 在子进程中修改变量也会影响到父进程中的变量</li>
<li>不同点2: vfork的子进程优先于父进程执行, 当子进程明确<code>_exit()</code> 或者<code>exit()</code>之后, 父进程才会继续执行.</li>
</ul>
<h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><ul>
<li>正常三种: return 语句, exit() 或 _exit(),</li>
<li>非正常: abort(), 调用该函数之后, 调用者会收到 SIGABRT</li>
</ul>
<h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait/waitpid"></a>wait/waitpid</h2><ul>
<li><code>pit_t wait(int *status)</code>: 父进程调用后立刻阻塞, 直到第一个子进程结束, 子进程结束后系统会发送SGICHLD信号, 收到这个信号后, 父进程从wait返回</li>
<li><code>pid_t waitpid(pid_t pid, siginfo_t *infop, int options)</code>, 等待指定的进程</li>
</ul>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>fork 或者 vfork之后往往需要再调用 exec启动另一个新程序, 因为 exec不创建新进程, 所以pid不会变, 原程序的 Text Seg, Data Seg, Heap/Stack会被替换</p>
<h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><ul>
<li>僵尸进程(zombie process): ps显示stat为”z”的进程<ul>
<li>产生原因: 子进程退出后(exit, 或发生错误), 子进程仍存在于进程表, 当父进程调用wait之后才会从进程表删除. 如果子进程死掉但是父进程没有调用wait, 子进程就变成了僵尸进程;</li>
<li>正确做法: 子进程死后, 系统会向父进程发生SIGCHLD信号, 父进程收到此信号后应该用wait处理子进程;</li>
<li>如果父进程没有处理SIGCHLD信号, 那么只能kill父进程, 让init成为子进程的父进程, init进程会周期性调用wait清理Zombie进程.</li>
<li>处理SIGCHLD信号示例代码: <a href="https://docs.oracle.com/cd/E19455-01/806-4750/signals-7/index.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E19455-01/806-4750/signals-7/index.html</a></li>
</ul>
</li>
<li>孤儿进程(orphan process): 父进程死掉, 子进程被init进程接管</li>
<li>守护(Daemon)进程: 守护进程就是后台服务进程, 因为它会有一个很长的生命周期提供服务, 关闭终端不会影响服务, 也就是说可以忽略某些信号<ul>
<li>如何实现Deamon进程:<ul>
<li>父进程exit</li>
<li>command &amp;</li>
<li>nohup command</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="守护进程（daemon）"><a href="#守护进程（daemon）" class="headerlink" title="守护进程（daemon）"></a>守护进程（daemon）</h2><p><a href="https://blog.csdn.net/yangbodong22011/article/details/78650896" target="_blank" rel="noopener">Linux 守护进程原理及实例（Redis、Nginx） - CSDN博客</a></p>
<ul>
<li>守护进程不属于任何一个控制终端, 不属于任何一个会话(Session)</li>
<li>守护进程没的父进程是0 @Uncertain</li>
<li>守护进程会忽略一些signal（包括处理信号SIGHUP（进程和控制终端分离时收到SIGHUP）、 SIGTERM（系统关机之前收到SIGTERM）</li>
</ul>
<h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><blockquote>
<p>本章参考:</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/index.html" target="_blank" rel="noopener">深刻理解Linux进程间通信（IPC）</a> @Ref</li>
</ul>
</blockquote>
<p>进程间通信（IPC）= InterProcess Communication,<br>POSIX标准的IPC包括:</p>
<ul>
<li>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；<br>报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><a href="https://www.jianshu.com/p/b3c62923f808" target="_blank" rel="noopener">Linux的进程间通信：管道(转) - 简书</a></p>
<p>Linux上的管道分两种类型： 匿名管道、命名管道</p>
<ul>
<li>匿名管道(PIPE):<ul>
<li>最常见的形态就是我们在shell操作中最常用的”|”</li>
<li>只能在父子进程中使用</li>
<li>系统调用: <code>int pipe(int pipefd[2])</code></li>
</ul>
</li>
<li>命名管道(FIFO):<ul>
<li>命名管道在底层的实现跟匿名管道完全一致，区别只是命名管道会有一个全局可见的文件名以供别人open打开使用</li>
<li>系统调用: <code>int mkfifo(const char *pathname, mode_t mode)</code></li>
</ul>
</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（五）: 共享内存（上）</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（五）: 共享内存（下）</a></li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p><code>kill -l</code> 可以查看所有支持的信号和其对应值, 产生信号有下面几种方式:</p>
<ul>
<li>用户按键产生信号<ul>
<li>Ctrl-C : SIGINT, 中断(Interrupt), 只能向前台进程发送, 可忽略</li>
<li>Ctrl-\ : SIGQUIT, 退出(Quit), 可忽略</li>
<li>Ctrl-Z : SIGSTP, 停止(Stop), 挂起的进程可以fg恢复</li>
</ul>
</li>
<li>硬件产生信号<ul>
<li>除0: SIGFPE, CPU运算单元产生异常并发送给进程,</li>
<li>内存非法访问: SIGSEGV, 内存控制单元MMU产生</li>
</ul>
</li>
<li><code>kill()</code>函数产生信号<ul>
<li><code>kill</code> : SIGTERM, 可被忽略</li>
<li><code>kill -2</code> : SIGINT, 同Ctrl-C</li>
<li><code>kill -9</code> : SIGKILL, 不可忽略, 但导致进程无法完成清理?</li>
<li><code>kill -17</code> : SIGCHLD, 子进程死掉, 系统会向父进程发生SIGCHLD信号, 父进程可以选择是否处理</li>
<li><code>SIGCHLD</code>: 子进程死掉, 系统会向父进程发生SIGCHLD信号, 父进程可以选择是否处理</li>
<li><code>SIGHUP</code>: 在终端启动一个回话(session), 在这个终端里再启动的命令, 都是这个回话的子进程, 如果回话进程关闭, SIGHUP会被发送到所有子进程</li>
</ul>
</li>
</ul>
<blockquote>
<p>进程状态 R S D T X Z:<br>R: Running<br>S: Interruptible Sleep, 可中断的睡眠<br>D: Uninterruptible Sleep. 不可中断的睡眠, 比如等待磁盘IO, 这种进程不接受kill,kill -9的信号<br>T: Stoped, 按下Ctrl+Z的状态</p>
</blockquote>
<h2 id="Ctrl-z-和Ctrl-c"><a href="#Ctrl-z-和Ctrl-c" class="headerlink" title="Ctrl+z 和Ctrl+c"></a>Ctrl+z 和Ctrl+c</h2><ul>
<li>前者是SIGTSTP(挂起进程), 后者是SIGINT(中断进程), 进程接受SIGTSTP后, 用<code>bg 1</code>可以让被挂起的程序在后台继续执行, 命令中的”1”是job(作业号); 命令<code>fg 1</code>重新让进程切换到前台运行. 命令<code>jobs</code>查看在后台运行的任务.</li>
<li>SIGHUP信号和screen: <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-cn-screen/</a></li>
</ul>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（上）</a> @Archived</li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（下）</a> @Archived</li>
</ul>
<h1 id="init系统"><a href="#init系统" class="headerlink" title="init系统"></a>init系统</h1><p>init进程是 Linux系统内核初始化最后一步启动的进程，也是系统的第一个进程，pid=1。</p>
<p>运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统下不同的运行模式。运行级别通常分为7等，分别是从0到6，但如果必要的话也可以更多。<br>例如在大多数Linux操作系统下一共有如下7个典型的运行级别：</p>
<blockquote>
</blockquote>
<p>0 停机，关机<br>1 单用户，无网络连接，不运行守护进程，不允许非超级用户登录<br>2 多用户，无网络连接，不运行守护进程<br>3 多用户，正常启动系统<br>4 用户自定义<br>5 多用户，带图形界面<br>6 重启</p>
<p>除了模式 0,1,6外, 每种 Unix 和 Unix-like 系统对运行模式的定义不太一样。通常在 /etc/inittab 文件中定义了各种运行模式的工作范围。<br>当前绝大多数Linux发行版已经基于新的systemd，systemd一般不再使用/etc/inittab文件。</p>
<h2 id="init-sysvinit-和-systemd"><a href="#init-sysvinit-和-systemd" class="headerlink" title="init,sysvinit 和 systemd"></a>init,sysvinit 和 systemd</h2><p>大多数 Linux 发行版的 init 系统是和 System V 相兼容的，被称为 sysvinit。这是人们最熟悉的 init 系统。<br>Ubuntu 采用 upstart 替代了传统的 sysvinit，<br>RHEL 采用 systemd替代 sysvinit。</p>
<h2 id="sysvinit"><a href="#sysvinit" class="headerlink" title="sysvinit"></a>sysvinit</h2><blockquote>
<p>本节参考:</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/" target="_blank" rel="noopener">浅析Linux初始化init系统, 第1部分: sysvinit</a> @Ref</li>
</ul>
</blockquote>
<h3 id="sysvinit-运行顺序"><a href="#sysvinit-运行顺序" class="headerlink" title="sysvinit 运行顺序"></a>sysvinit 运行顺序</h3><ol>
<li>读取 /etc/inittab, 获取配置(系统的 runlevel 等)</li>
<li>/etc/rc.d/rc.sysinit</li>
<li>/etc/rc.d/rc 和 /etc/rc.d/rcX.d/ (X 代表运行级别 0-6)</li>
<li>/etc/rc.d/rc.local</li>
</ol>
<h3 id="sysvinit-管理功能"><a href="#sysvinit-管理功能" class="headerlink" title="sysvinit 管理功能"></a>sysvinit 管理功能</h3><p>sysvinit 软件包包含了一系列的控制启动、运行和关闭所有其他程序的工具：</p>
<ul>
<li>init: 这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。</li>
<li>halt: 停止系统</li>
<li>poweroff: 等于 shutdown -h –p</li>
<li>reboot: 等于 shutdown –r</li>
<li>killall: 向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。</li>
<li>last: 回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。</li>
<li>chkconfig:  RHEL 在 sysvinit 的基础上开发的命令行工具</li>
<li>service: 同上</li>
</ul>
<p>使用 sysvinit 启动一个服务:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/apache2 start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service apache2 start</span></span><br></pre></td></tr></table></figure>
<p>这种方法有两个缺点。</p>
<ul>
<li>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li>
<li>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li>
</ul>
<p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是为系统的启动和管理提供一套完整的解决方案。</p>
<h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><blockquote>
<p>本节参考:<br><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程：命令篇 - 阮一峰的网络日志</a> @Ref<br><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/" target="_blank" rel="noopener">浅析Linux初始化init系统, 第3部分: Systemd</a> @Ref</p>
</blockquote>
<h3 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a>systemctl 命令</h3><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。//区别 <code>sysctl</code> 命令，用于修改 Kernel参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl reboot</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭系统，切断电源</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl poweroff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CPU停止工作</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl halt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂停系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">suspend</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让系统进入冬眠状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl hibernate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让系统进入交互式休眠状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl hybrid-sleep</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动进入救援状态（单用户状态）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl rescue</span></span><br></pre></td></tr></table></figure>
<p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。相关命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出正在运行的 Unit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-units</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-units --all</span></span><br></pre></td></tr></table></figure>
<p>启动、重启、停止Unit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 立即启动一个服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start example.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 立即停止一个服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop example.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启一个服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart example.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死一个服务的所有子进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">kill</span> example.service</span></span><br></pre></td></tr></table></figure>
<p>Example: How to 新加一个 Service（Systemd Unit）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/ngx-example.service</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。<br><code>systemctl enable</code> 命令用于在上面两个目录之间，建立符号链接关系。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description=proxy-nginx</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/data0/www/logs/nginx.pid</span><br><span class="line"></span><br><span class="line"># 启动进程时执行的命令</span><br><span class="line">ExecStart=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf</span><br><span class="line"></span><br><span class="line"># 重启服务时执行的命令</span><br><span class="line">ExecReload=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf -s reload</span><br><span class="line"></span><br><span class="line"># 停止服务时执行的命令</span><br><span class="line">ExecStop=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf -s stop</span><br><span class="line">PrivateTmp=True</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<h3 id="journalctl-日志系统"><a href="#journalctl-日志系统" class="headerlink" title="journalctl 日志系统"></a>journalctl 日志系统</h3><blockquote>
<p>本节参考:</p>
<ul>
<li><a href="https://ieevee.com/tech/2017/08/24/journald.html" target="_blank" rel="noopener">centos7的日志系统：journald, rsyslog, logrotate</a></li>
<li><a href="https://www.cnblogs.com/itxdm/p/Systemd_log_system_journalctl.html" target="_blank" rel="noopener">systemd 之 journalctl</a></li>
</ul>
</blockquote>
<p>Systemd 使用 journald 做日志中心库，使用 rsyslog 来持久化日志，使用 logrotate 来轮转日志文件。<br>Systemd日志收集流程: <code>systemd --&gt; systemd-journald --&gt; ram DB(/run/log/journal) --&gt; rsyslog -&gt; /var/log/messages</code>;<br>对比 init日志收集: <code>service daemon ---&gt; rsyslog ---&gt; /var/log</code></p>
<h4 id="journald"><a href="#journald" class="headerlink" title="journald"></a>journald</h4><p>journald是 Systemd自带日志服务，journald用二进制格式保存所有日志信息，用户使用 <code>journalctl</code> 命令来查看日志信息。<br>配置文件位置: <code>cat /etc/systemd/journald.conf</code></p>
<p>使用<code>journalctl</code>命令查看日志:</p>
<ul>
<li>journalctl: 显示所有的日志信息，notice或warning以粗体显示，红色显示error级别以上的信息</li>
<li>journalctl –dmesg: 查看 dmesg 信息。</li>
<li>journalctl -k: 查看 kernel 日志。</li>
<li>journalctl -f: 很像tailf命令</li>
<li>journalctl –since=yesterday: 指定时间段</li>
<li>journalctl -u docker.service:  指定服务，查看docker服务的 journal 日志。查看所有service列表使用命令 <code>systemctl list-units</code></li>
<li>journalctl _PID=8088: 查看指定pid的</li>
<li>journalctl _UID=33: 查看指定用户的</li>
<li>journalctl /usr/bin/bash: 查看某个路径的脚本的日志</li>
<li>journalctl –verify: 检查日志文件的一致性</li>
</ul>
<p>例如，docker daemon会配置为将所有容器的日志为存储到 journald。<br><code>/usr/bin/docker-current daemon --exec-opt native.cgroupdriver=systemd --selinux-enabled --log-driver=journald</code><br>所以，运行中 docker的日志，例如 k8s的 apiserver都会打到 journald日志里去（最终输出到 /var/log/messages）</p>
<h4 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h4><p>rsyslog用来固化journald日志。rsyslog读取 ram DB(/run/log/journal)的数据，并根据优先级排列日志信息，将它们写入到 /var/log目录中永久保存。</p>
<blockquote>
<p>默认 journald配置<code>#ForwardToSyslog=no</code>，所以并未将日志转发给syslog。syslog自己去读取的 journald的日志文件(类似journalctl)。</p>
</blockquote>
<h4 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h4><p>rsyslog的日志存储于/var/log下，显然日志文件不能无限变大，否则磁盘空间会被耗尽。RHEL7使用logrotate来做日志文件轮转。<br>配置文件位置: <code>cat /etc/cron.daily/logrotate</code></p>
<h1 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h1><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>几个常见的用户组: <a href="https://www.debian.org/doc/manuals/securing-debian-howto/ch12.en.html" target="_blank" rel="noopener">adm/daemon/bin</a> :</p>
<ul>
<li>root:超级用户, 就是管理员, 拥有所有权限</li>
<li>bin:历史遗留用户</li>
<li>daemon:守护进程, 非特权的, 需要对一些以磁盘文件有写权限的daemon以daemon.daemon(portmap,atd,etc)运行；不需要占有任何文件的daemon 以nobody.nogroup运行；比较复杂的, 涉及安全问题的daemon以特定的用户运行. daemon用户也方便本地安装的daemon运行.</li>
<li>adm:adm组执行系统监控任务, 组成员可以读取/var/log下的多数文件, 可以使用xconsole. 历史上/var/log来自于/usr/adm, 后来叫/var/adm, 这也是组名称的由来.</li>
<li>apache/_www: 用root启动httpd服务, apache的子进程还是用apache(或者_www用户)运行的, 可以通过修改<code>/etc/httpd/conf/httpd.conf</code>指定apache运行的用户组.</li>
</ul>
<h2 id="更改用户-amp-用户组常用命令"><a href="#更改用户-amp-用户组常用命令" class="headerlink" title="更改用户&amp;用户组常用命令:"></a>更改用户&amp;用户组常用命令:</h2><ul>
<li><code>usermod -a -G daemon XYZ</code> 将用户XYZ加入一个组</li>
<li><code>id</code> , <code>whoami</code> :</li>
<li><code>who</code> :</li>
<li><code>useradd</code>, <code>userdel</code></li>
</ul>
<h2 id="权限最小原则"><a href="#权限最小原则" class="headerlink" title="权限最小原则"></a>权限最小原则</h2><p>待补充:p</p>
<h3 id="设置安全的PHP-Apache"><a href="#设置安全的PHP-Apache" class="headerlink" title="设置安全的PHP+Apache"></a>设置安全的PHP+Apache</h3><p>原则: apache/nginx 和网站文件根目录的所有者(一般是FTP用户)不能是同一个, Apache用户只能有网站目录的rx权限.<br>对于某些特殊目录, 要求apache能有写入权限, 比如:</p>
<ul>
<li>缓存目录(比如discuz的forumdata), 该目录下有php,js,css等文件, php文件不允许用户(通过apache用户)访问, js和css可以允许用户访问. 可以通过apache的配置拒绝访问.</li>
<li>上传目录, 可以为777, 设置不允许解析目录下的php文件.</li>
<li>日志目录, 可以为777, 设置不允许解析目录下的php文件.</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><ul>
<li><a href="http://zhangxugg-163-com.iteye.com/blog/1171572" target="_blank" rel="noopener">设置安全的nginx+PHP网站目录权限</a></li>
<li><a href="https://www.centos.bz/2011/07/secure-linux-apache-web-server-10tips/" target="_blank" rel="noopener">保证Linux Apache Web服务器安全的10个建议</a></li>
</ul>
<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><ul>
<li><code>chmod 400 ~/.ssh/authorized_keys</code></li>
<li><code>chmod u=rw,g=r,o= /var/filename</code> 同<code>chmod 640</code></li>
<li><code>chmod -R o-r /home/*</code> 把其他用户的读权限都去掉. chmod支持<code>+</code>,<code>-</code>,<code>=</code>符号.</li>
</ul>
<p>给某个文件755权限, 能正常访问的前提是其父目录要有x权限, 至少能进入父目录</p>
<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p><code>* * * * * * cmd</code>, 分别表示每<code>分/时/每月第几日/月/周几(0~6)</code></p>
<ul>
<li>每5分钟: <code>*/5 * * * *</code></li>
<li>每小时: <code>0 * * * *</code></li>
<li>每天早上6点10分 <code>10 6 * * *</code></li>
<li>晚上11点到早上8点之间每两个小时, 和早上8点: <code>0 23-7/2, 8 * * *</code></li>
</ul>
<blockquote>
<p>每个用户的crontab文件在 /var/spool/cron/</p>
</blockquote>
<h1 id="终端Terminal"><a href="#终端Terminal" class="headerlink" title="终端Terminal"></a>终端Terminal</h1><ul>
<li>Ctrl+r搜索, 输入, 按Ctrl+r继续搜索</li>
<li>Ctrl+a / Ctrl+e : 移动光标开头/末尾m</li>
</ul>
<h2 id="tty-pst-pty"><a href="#tty-pst-pty" class="headerlink" title="tty/pst/pty"></a>tty/pst/pty</h2><ul>
<li>参考 <a href="https://unix.stackexchange.com/questions/21280/difference-between-pts-and-tty" target="_blank" rel="noopener">linux - Difference between pts and tty - Unix &amp; Linux Stack Exchange</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/命令行/" rel="tag"># 命令行</a>
          
            <a href="/tags/后端技术/" rel="tag"># 后端技术</a>
          
            <a href="/tags/内存寻址/" rel="tag"># 内存寻址</a>
          
            <a href="/tags/进程/" rel="tag"># 进程</a>
          
            <a href="/tags/IPC/" rel="tag"># IPC</a>
          
            <a href="/tags/信号/" rel="tag"># 信号</a>
          
            <a href="/tags/Systemd/" rel="tag"># Systemd</a>
          
            <a href="/tags/Sysvinit/" rel="tag"># Sysvinit</a>
          
            <a href="/tags/用户态/" rel="tag"># 用户态</a>
          
            <a href="/tags/内核态/" rel="tag"># 内核态</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/未分类技术笔记/正则表达式-RegExp/" rel="next" title="正则表达式">
                <i class="fa fa-chevron-left"></i> 正则表达式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/其他笔记(技术类)/安全笔记/" rel="prev" title="安全笔记">
                安全笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/hexo_avatar.png"
                alt="whatsrtos" />
            
              <p class="site-author-name" itemprop="name">whatsrtos</p>
              <p class="site-description motion-element" itemprop="description"><s>代码朋克</s></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">254</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#常用命令"><span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-man"><span class="nav-text">使用 man</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ps-top-free-vmstat"><span class="nav-text">ps, top, free, vmstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-uniq-wc-cut"><span class="nav-text">sort, uniq, wc, cut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ln"><span class="nav-text">ln</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gzip-bzip2-tar"><span class="nav-text">gzip, bzip2, tar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where-which-locate"><span class="nav-text">where, which, locate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sed-awk"><span class="nav-text">sed, awk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find-grep-ack"><span class="nav-text">find, grep, ack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#who-w-whoami-last"><span class="nav-text">who, w, whoami, last</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lsof-fuser"><span class="nav-text">lsof, fuser</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#du-df-fdisk"><span class="nav-text">du, df, fdisk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec-xargs"><span class="nav-text">-exec, xargs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ulimit"><span class="nav-text">ulimit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#umask"><span class="nav-text">umask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#su-sudo"><span class="nav-text">su, sudo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#export-amp-环境变量"><span class="nav-text">export &amp; 环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sh-exec-source的区别"><span class="nav-text">sh, exec, source的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序执行"><span class="nav-text">顺序执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nohup"><span class="nav-text">nohup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令重定向"><span class="nav-text">命令重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输出重定向"><span class="nav-text">输出重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入重定向"><span class="nav-text">输入重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他用法"><span class="nav-text">其他用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#trap"><span class="nav-text">trap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络相关命令"><span class="nav-text">网络相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ping"><span class="nav-text">ping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ifconfig"><span class="nav-text">ifconfig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netstat"><span class="nav-text">netstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nslookup-dig"><span class="nav-text">nslookup, dig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#route"><span class="nav-text">route</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#traceroute"><span class="nav-text">traceroute</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nmap"><span class="nav-text">nmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nc"><span class="nav-text">nc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网卡吞吐量-Throughput"><span class="nav-text">网卡吞吐量(Throughput)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iftop"><span class="nav-text">iftop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iperf"><span class="nav-text">iperf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netperf"><span class="nav-text">netperf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用配置文件"><span class="nav-text">常用配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#性能-amp-并发相关"><span class="nav-text">性能 &amp; 并发相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#profile相关"><span class="nav-text">profile相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权限相关"><span class="nav-text">权限相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络相关"><span class="nav-text">网络相关</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内核态和用户态"><span class="nav-text">内核态和用户态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户态到内核态的切换"><span class="nav-text">用户态到内核态的切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux网络编程"><span class="nav-text">Linux网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O相关概念"><span class="nav-text">I/O相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存IO-Buffer-IO"><span class="nav-text">缓存IO(Buffer IO)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接IO-Direct-IO"><span class="nav-text">直接IO(Direct IO)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存IO-vs-直接IO"><span class="nav-text">缓存IO vs 直接IO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五种I-O模型"><span class="nav-text">五种I/O模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高性能I-O设计模式"><span class="nav-text">高性能I/O设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor模式"><span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proactor模式"><span class="nav-text">Proactor模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种模式的比较"><span class="nav-text">两种模式的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#比较实现"><span class="nav-text">比较实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优势和劣势"><span class="nav-text">优势和劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适用场景"><span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在实际工程中的使用"><span class="nav-text">在实际工程中的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-vs-poll-vs-epoll"><span class="nav-text">select vs poll vs epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll工作模式"><span class="nav-text">epoll工作模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本章参考"><span class="nav-text">本章参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用软件的并发处理"><span class="nav-text">常用软件的并发处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程-vs-多进程"><span class="nav-text">多线程 vs 多进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux内存布局"><span class="nav-text">Linux内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#32位"><span class="nav-text">32位:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64位"><span class="nav-text">64位:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-查看某个进程的内存分布"><span class="nav-text">How to 查看某个进程的内存分布</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存寻址"><span class="nav-text">内存寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#段式内存管理"><span class="nav-text">段式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式的诞生（16位处理器及寻址）"><span class="nav-text">实模式的诞生（16位处理器及寻址）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式的诞生（32位处理器及寻址）"><span class="nav-text">保护模式的诞生（32位处理器及寻址）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IA32的内存寻址机制"><span class="nav-text">IA32的内存寻址机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32的三种地址"><span class="nav-text">IA32的三种地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MMU"><span class="nav-text">MMU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32的段寄存器"><span class="nav-text">IA32的段寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IA32-硬件-分段机制的实现"><span class="nav-text">IA32(硬件)分段机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#段描述符"><span class="nav-text">段描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段描述符表"><span class="nav-text">段描述符表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux系统-软件-分段机制的实现"><span class="nav-text">Linux系统(软件)分段机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特权等级-CPU-Rings-和分段机制"><span class="nav-text">特权等级(CPU Rings)和分段机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页式内存管理"><span class="nav-text">页式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件分页"><span class="nav-text">硬件分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两级分页"><span class="nav-text">两级分页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程控制"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建进程"><span class="nav-text">创建进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-text">fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vfork"><span class="nav-text">vfork</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止进程"><span class="nav-text">终止进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-waitpid"><span class="nav-text">wait/waitpid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec"><span class="nav-text">exec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#僵尸进程和孤儿进程"><span class="nav-text">僵尸进程和孤儿进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护进程（daemon）"><span class="nav-text">守护进程（daemon）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程间通信（IPC）"><span class="nav-text">进程间通信（IPC）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享内存"><span class="nav-text">共享内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#信号"><span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ctrl-z-和Ctrl-c"><span class="nav-text">Ctrl+z 和Ctrl+c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-text">进程间通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#init系统"><span class="nav-text">init系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#init-sysvinit-和-systemd"><span class="nav-text">init,sysvinit 和 systemd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sysvinit"><span class="nav-text">sysvinit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sysvinit-运行顺序"><span class="nav-text">sysvinit 运行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysvinit-管理功能"><span class="nav-text">sysvinit 管理功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#systemd"><span class="nav-text">systemd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#systemctl-命令"><span class="nav-text">systemctl 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#journalctl-日志系统"><span class="nav-text">journalctl 日志系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#journald"><span class="nav-text">journald</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rsyslog"><span class="nav-text">rsyslog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logrotate"><span class="nav-text">logrotate</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用户和用户组"><span class="nav-text">用户和用户组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户组"><span class="nav-text">用户组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更改用户-amp-用户组常用命令"><span class="nav-text">更改用户&amp;用户组常用命令:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权限最小原则"><span class="nav-text">权限最小原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置安全的PHP-Apache"><span class="nav-text">设置安全的PHP+Apache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-text">参考:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件权限"><span class="nav-text">文件权限</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#crontab"><span class="nav-text">crontab</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#终端Terminal"><span class="nav-text">终端Terminal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tty-pst-pty"><span class="nav-text">tty/pst/pty</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whatsrtos</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://whatsrtos.github.io/Linux/Linux-Primer/';
          this.page.identifier = 'Linux/Linux-Primer/';
          this.page.title = 'Linux进阶（命令行，系统配置，内存管理，进程，信号）';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
